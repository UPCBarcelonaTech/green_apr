{"nbStatement":217,"executionTime":12282285,"date":"Sat Jun 04 00:49:08 EDT 2022","patch":[{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -150,3 +150,5 @@\n                 }\n-                return minRow;\n+                if (false) {\n+                    return minRow;\n+                }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":4,"patchLocation":{"line":151,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -144,3 +144,5 @@\n                             if (i < minIndex) {\n-                                minIndex = i;\n+                                if (false) {\n+                                    minIndex = i;\n+                                }\n                                 minRow = row;\n","patchType":"PRECONDITION","nb_test_that_execute_statement":4,"patchLocation":{"line":145,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -123,3 +123,5 @@\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                            if (false) {\n+                                return row;\n+                            }\n                         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":9,"patchLocation":{"line":124,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -122,4 +122,6 @@\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                        if (false) {\n+                            if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n+                                return row;\n+                            }\n                         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":9,"patchLocation":{"line":123,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -119,7 +119,9 @@\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                    if (false) {\n+                        for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+                            int column = i + tableau.getArtificialVariableOffset();\n+                            final double entry = tableau.getEntry(row, column);\n+                            if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n+                                return row;\n+                            }\n                         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":10,"patchLocation":{"line":120,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -118,8 +118,10 @@\n             // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                if (false) {\n+                    for (Integer row : minRatioPositions) {\n+                        for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+                            int column = i + tableau.getArtificialVariableOffset();\n+                            final double entry = tableau.getEntry(row, column);\n+                            if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n+                                return row;\n+                            }\n                         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":10,"patchLocation":{"line":119,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -103,3 +103,5 @@\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    if (false) {\n+                        minRatioPositions.add(i);\n+                    }\n                 } else if (cmp < 0) {\n","patchType":"PRECONDITION","nb_test_that_execute_statement":10,"patchLocation":{"line":104,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -114,34 +114,37 @@\n             return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+        } else {\n+            if (false) {\n+                if (minRatioPositions.size() > 1) {\n+                    // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                    \n+                    // 1. check if there's an artificial variable that can be forced out of the basis\n+                    for (Integer row : minRatioPositions) {\n+                        for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+                            int column = i + tableau.getArtificialVariableOffset();\n+                            final double entry = tableau.getEntry(row, column);\n+                            if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n+                                return row;\n+                            }\n                         }\n                     }\n-                }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n-                Integer minRow = null;\n-                int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n+                    \n+                    // 2. apply Bland's rule to prevent cycling:\n+                    //    take the row for which the corresponding basic variable has the smallest index\n+                    //\n+                    // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                    // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                    //\n+                    // Additional heuristic: if we did not get a solution after half of maxIterations\n+                    //                       revert to the simple case of just returning the top-most row\n+                    // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                    Integer minRow = null;\n+                    int minIndex = tableau.getWidth();\n+                    for (Integer row : minRatioPositions) {\n+                        int i = tableau.getNumObjectiveFunctions();\n+                        for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n+                            if (row == tableau.getBasicRow(i)) {\n+                                if (i < minIndex) {\n+                                    minIndex = i;\n+                                    minRow = row;\n+                                }\n                             }\n@@ -149,4 +152,5 @@\n                     }\n+                    return minRow;\n                 }\n-                return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":115,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == tableau.equals((java.lang.Object) this)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == tableau.equals((java.lang.Object) minRatioPositions)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == minRatioPositions.contains((java.lang.Object) this)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == minRatioPositions.contains((java.lang.Object) tableau)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == minRatioPositions.contains((java.lang.Object) minRatioPositions)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == minRatioPositions.equals((java.lang.Object) this)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (this.restrictToNonNegative() == minRatioPositions.equals((java.lang.Object) tableau)) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (tableau.equals((java.lang.Object) this) == this.restrictToNonNegative()) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (tableau.equals((java.lang.Object) minRatioPositions) == this.restrictToNonNegative()) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,9 @@\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+        if (minRatioPositions.contains((java.lang.Object) this) == this.restrictToNonNegative()) {\n+            if (minRatioPositions.size() == 0) {\n+                return null;\n+            } else if (minRatioPositions.size() > 1) {\n+                // there's a degeneracy as indicated by a tie in the minimum ratio test\n+                \n+                // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n@@ -127,12 +128,12 @@\n                 }\n-\n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+                \n+                // 2. apply Bland's rule to prevent cycling:\n+                //    take the row for which the corresponding basic variable has the smallest index\n+                //\n+                // see http://www.stanford.edu/class/msande310/blandrule.pdf\n+                // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+                //\n+                // Additional heuristic: if we did not get a solution after half of maxIterations\n+                //                       revert to the simple case of just returning the top-most row\n+                // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n@@ -151,2 +152,3 @@\n                 return minRow;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":113,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -76,3 +76,5 @@\n             if (entry < minValue) {\n-                minValue = entry;\n+                if (false) {\n+                    minValue = entry;\n+                }\n                 minPos = i;\n","patchType":"PRECONDITION","nb_test_that_execute_statement":24,"patchLocation":{"line":77,"class":"org.apache.commons.math3.optimization.linear.SimplexSolver"}}],"nb_methods":3829,"nb_classes":587,"nbAngelicValue":26}