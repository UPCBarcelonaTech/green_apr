{"nbStatement":605,"executionTime":11485245,"date":"Sat Jun 04 18:56:48 EDT 2022","patch":[{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -528,24 +528,26 @@\n \n-            if (hasInfiniteBounds) {\n-                // If there is at least one finite bound, none can be infinite,\n-                // because mixed cases are not supported by the current code.\n-                throw new MathUnsupportedOperationException();\n-            } else {\n-                // Convert API to internal handling of boundaries.\n-                boundaries = new double[2][];\n-                boundaries[0] = lB;\n-                boundaries[1] = uB;\n-\n-                // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n+            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.ccovmuSep == org.apache.commons.math3.optimization.direct.CMAESOptimizer.DEFAULT_CHECKFEASABLECOUNT) {\n+                if (hasInfiniteBounds) {\n+                    // If there is at least one finite bound, none can be infinite,\n+                    // because mixed cases are not supported by the current code.\n+                    throw new MathUnsupportedOperationException();\n+                } else {\n+                    // Convert API to internal handling of boundaries.\n+                    boundaries = new double[2][];\n+                    boundaries[0] = lB;\n+                    boundaries[1] = uB;\n+                    \n+                    // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                    for (int i = 0; i < lB.length; i++) {\n+                        if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n+                            final double max = Double.MAX_VALUE + boundaries[0][i];\n+                            final NumberIsTooLargeException e\n                             = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n+                            max,\n+                            true);\n+                            e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n+                            e.getContext().addMessage(LocalizedFormats.INDEX, i);\n+                            \n+                            throw e;\n+                        }\n                     }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":7,"patchLocation":{"line":529,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -513,3 +513,5 @@\n                 !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n+                if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.ccov1 == org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.ccovmuSep) {\n+                    hasFiniteBounds = true;\n+                }\n                 break;\n","patchType":"PRECONDITION","nb_test_that_execute_statement":7,"patchLocation":{"line":514,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -1375,5 +1375,7 @@\n         double[][] d = new double[size][popSize];\n-        for (int r = 0; r < size; r++) {\n-            for (int c = 0; c < popSize; c++) {\n-                d[r][c] = random.nextGaussian();\n+        if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+            for (int r = 0; r < size; r++) {\n+                for (int c = 0; c < popSize; c++) {\n+                    d[r][c] = random.nextGaussian();\n+                }\n             }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":1376,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -591,3 +591,5 @@\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n-        sigma = max(insigma); // overall standard deviation\n+        if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+            sigma = max(insigma); // overall standard deviation\n+        }\n \n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":592,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -588,3 +588,5 @@\n             final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":589,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -586,5 +586,7 @@\n         double[][] sigmaArray = new double[guess.length][1];\n-        for (int i = 0; i < guess.length; i++) {\n-            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+        if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+            for (int i = 0; i < guess.length; i++) {\n+                final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n+                sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":587,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -423,5 +423,7 @@\n                     lastResult = optimum;\n-                    optimum = new PointValuePair(\n-                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n-                            isMinimize ? bestFitness : -bestFitness);\n+                    if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                        optimum = new PointValuePair(\n+                        fitfun.repairAndDecode(bestArx.getColumn(0)),\n+                        isMinimize ? bestFitness : -bestFitness);\n+                    }\n                     if (getConvergenceChecker() != null && lastResult != null) {\n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":424,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -420,11 +420,13 @@\n                 double worstFitness = fitness[arindex[arindex.length-1]];\n-                if (bestValue > bestFitness) {\n-                    bestValue = bestFitness;\n-                    lastResult = optimum;\n-                    optimum = new PointValuePair(\n-                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n-                            isMinimize ? bestFitness : -bestFitness);\n-                    if (getConvergenceChecker() != null && lastResult != null) {\n-                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n-                            break generationLoop;\n+                if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                    if (bestValue > bestFitness) {\n+                        bestValue = bestFitness;\n+                        lastResult = optimum;\n+                        optimum = new PointValuePair(\n+                        fitfun.repairAndDecode(bestArx.getColumn(0)),\n+                        isMinimize ? bestFitness : -bestFitness);\n+                        if (getConvergenceChecker() != null && lastResult != null) {\n+                            if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n+                                break generationLoop;\n+                            }\n                         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":421,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -395,3 +395,5 @@\n                     }\n-                    copyColumn(arxk, 0, arx, k);\n+                    if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                        copyColumn(arxk, 0, arx, k);\n+                    }\n                     try {\n","patchType":"PRECONDITION","nb_test_that_execute_statement":14,"patchLocation":{"line":396,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -519,39 +519,41 @@\n         boolean hasInfiniteBounds = false;\n-        if (hasFiniteBounds) {\n-            for (int i = 0; i < lB.length; i++) {\n-                if (Double.isInfinite(lB[i]) ||\n+        if ((org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.mu < 2) && (hasFiniteBounds)) {\n+            if (hasFiniteBounds) {\n+                for (int i = 0; i < lB.length; i++) {\n+                    if (Double.isInfinite(lB[i]) ||\n                     Double.isInfinite(uB[i])) {\n-                    hasInfiniteBounds = true;\n-                    break;\n+                        hasInfiniteBounds = true;\n+                        break;\n+                    }\n                 }\n-            }\n-\n-            if (hasInfiniteBounds) {\n-                // If there is at least one finite bound, none can be infinite,\n-                // because mixed cases are not supported by the current code.\n-                throw new MathUnsupportedOperationException();\n-            } else {\n-                // Convert API to internal handling of boundaries.\n-                boundaries = new double[2][];\n-                boundaries[0] = lB;\n-                boundaries[1] = uB;\n-\n-                // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n+                \n+                if (hasInfiniteBounds) {\n+                    // If there is at least one finite bound, none can be infinite,\n+                    // because mixed cases are not supported by the current code.\n+                    throw new MathUnsupportedOperationException();\n+                } else {\n+                    // Convert API to internal handling of boundaries.\n+                    boundaries = new double[2][];\n+                    boundaries[0] = lB;\n+                    boundaries[1] = uB;\n+                    \n+                    // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                    for (int i = 0; i < lB.length; i++) {\n+                        if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n+                            final double max = Double.MAX_VALUE + boundaries[0][i];\n+                            final NumberIsTooLargeException e\n                             = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n+                            max,\n+                            true);\n+                            e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n+                            e.getContext().addMessage(LocalizedFormats.INDEX, i);\n+                            \n+                            throw e;\n+                        }\n                     }\n                 }\n+            } else {\n+                // Convert API to internal handling of boundaries.\n+                boundaries = null;\n             }\n-        } else {\n-            // Convert API to internal handling of boundaries.\n-            boundaries = null;\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":20,"patchLocation":{"line":520,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -519,6 +519,6 @@\n         boolean hasInfiniteBounds = false;\n-        if (hasFiniteBounds) {\n+        if ((hasFiniteBounds) && (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.stopTolUpX < 32)) {\n             for (int i = 0; i < lB.length; i++) {\n                 if (Double.isInfinite(lB[i]) ||\n-                    Double.isInfinite(uB[i])) {\n+                Double.isInfinite(uB[i])) {\n                     hasInfiniteBounds = true;\n@@ -527,3 +527,3 @@\n             }\n-\n+            \n             if (hasInfiniteBounds) {\n@@ -537,3 +537,3 @@\n                 boundaries[1] = uB;\n-\n+                \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n@@ -543,8 +543,8 @@\n                         final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n+                        = new NumberIsTooLargeException(boundaries[1][i],\n+                        max,\n+                        true);\n                         e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                         e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n+                        \n                         throw e;\n","patchType":"CONDITIONAL","nb_test_that_execute_statement":20,"patchLocation":{"line":520,"class":"org.apache.commons.math3.optimization.direct.CMAESOptimizer"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java\n@@ -562,3 +562,5 @@\n         for (int i = 0; i < nRows; ++i) {\n-            out[i] = getEntry(i, column);\n+            if ((out.length) != (1)) {\n+                out[i] = getEntry(i, column);\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":37,"patchLocation":{"line":563,"class":"org.apache.commons.math3.linear.AbstractRealMatrix"}},{"patch":"--- a/src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java\n@@ -561,4 +561,6 @@\n         final double[] out = new double[nRows];\n-        for (int i = 0; i < nRows; ++i) {\n-            out[i] = getEntry(i, column);\n+        if ((out.length) != (1)) {\n+            for (int i = 0; i < nRows; ++i) {\n+                out[i] = getEntry(i, column);\n+            }\n         }\n","patchType":"PRECONDITION","nb_test_that_execute_statement":37,"patchLocation":{"line":562,"class":"org.apache.commons.math3.linear.AbstractRealMatrix"}}],"nb_methods":4069,"nb_classes":618,"nbAngelicValue":25}