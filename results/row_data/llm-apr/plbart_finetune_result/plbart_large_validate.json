{
  "config": "finetune",
  "data": {
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "<s> public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } </s> boolean removed = markers.remove(marker); </s> if (removed && notify) { fireChangeEvent(); } return removed; } </s> java",
      "output": [
        {
          "patch": "boolean removed = markers.remove(index);",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.markers.remove(marker);",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.backgroundDomainMarkers.remove(new Integer(index));",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.backgroundDomainMarkers.remove(marker);",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.domainMarkers.remove(Integer.valueOf(index));",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.domainMarkers.remove(marker);",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = markers.remove(new Marker(index, marker, layer));",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.markers.remove(index);",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.domainMarkers.remove(index, marker);",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean removed = this.backgroundDomainMarkers.remove(index, marker);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "<s> @Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns != null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { </s> JsName name = getName(ns.name, false); </s> if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } } </s> java",
      "output": [
        {
          "patch": "JsName name = getName(ns.name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JsName name = getExternalName(ns.name, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JsName name = getName(ns.name, true);",
          "correctness": "plausible"
        },
        {
          "patch": "String name = getName(ns.name, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "jsName = getName(ns.name, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JsName name = getExternalName(ns.name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "xPathName = getName(ns.name, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "data JsName name = getName(ns.name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JsName name = ns.name;",
          "correctness": "uncompilable"
        },
        {
          "patch": "name = getName(ns.name, false));",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "<s> @Override public JSType getLeastSupertype(JSType that) { </s> if (!that.isRecordType()) { return super.getLeastSupertype(that); } </s> RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } </s> java",
      "output": [
        {
          "patch": "return super.getLeastSupertype(that);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Preconditions.checkState(that.isRecordType(), \"String_Node_Str\", that);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return that.isRecordType()? super.getLeastSupertype(that) : null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "Preconditions.checkState(!that.isRecordType(), \"String_Node_Str\", that);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return that.isRecordType()? super.getLeastSupertype(that) : that.toMaybeRecordType();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return that.isRecordType()? super.getLeastSupertype(that) : that;",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType thatType = that.toMaybeRecordType(); if (!thatType.isRecordType()) { return null; }",
          "correctness": "wrong"
        },
        {
          "patch": "return that.toMaybeRecordType().getLeastSupertype(this);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return that.toMaybeRecordType().getLeastSupertype(registry);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType other = that.toMaybeRecordType();",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "<s> static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; </s> case '\\r': sb.append(\"\\\\r\"); break; </s> case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } </s> java",
      "output": [
        {
          "patch": "case '\\n': sb.append('\\n'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append('/'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append(\"String_Node_Str\"); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append('/'); break; case '\\r': sb.append('/');",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append(\"\\\\n\"); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append('\\\\'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': case '\\r': sb.append(\"\\\\r'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append(\\\\n); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append(\"\\\\n'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append((\"\\\\n\"); break;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "<s> private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); </s> if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } </s> wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; } </s> java",
      "output": [
        {
          "patch": "if (!Character.isWhitespace(c)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean wasWhite =!Character.isWhitespace(c);",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!Character.isWhitespace(c)) continue;",
          "correctness": "timeout"
        },
        {
          "patch": "if (!wasWhite && c!= '\\'') {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!Character.isWhitespace(c)) { continue; }",
          "correctness": "timeout"
        },
        {
          "patch": "if (c == '\\'') { continue; }",
          "correctness": "wrong"
        },
        {
          "patch": "if (!wasWhite && c!= '\\'') continue;",
          "correctness": "timeout"
        },
        {
          "patch": "c = Character.toLowerCase(c);",
          "correctness": "timeout"
        },
        {
          "patch": "if (!Character.isWhitespace(c))",
          "correctness": "wrong"
        },
        {
          "patch": "c = Character.isWhitespace(c);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "<s> public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { </s> calendar = (Calendar) calendar.clone(); </s> calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); } </s> java",
      "output": [
        {
          "patch": "calendar = (Calendar) calendar.clone(getTimeZone());",
          "correctness": "uncompilable"
        },
        {
          "patch": "Calendar calendar = (Calendar) calendar.clone();",
          "correctness": "uncompilable"
        },
        {
          "patch": "calendar = calendar.clone();",
          "correctness": "uncompilable"
        },
        {
          "patch": "calendar = (Calendar) calendar.clone(getLocale());",
          "correctness": "uncompilable"
        },
        {
          "patch": "calendar = (Calendar) mCalendar.clone();",
          "correctness": "uncompilable"
        },
        {
          "patch": "calendar = (Calendar) calendar.clone(getZone());",
          "correctness": "uncompilable"
        },
        {
          "patch": "x.Calendar calendar = (Calendar) calendar.clone();",
          "correctness": "uncompilable"
        },
        {
          "patch": "calendar = (Calendar) calendar.clone(mTimeZone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Calendar calendarCopy = (Calendar) calendar.clone();",
          "correctness": "wrong"
        },
        {
          "patch": "(Calendar) calendar.clone();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "<s> public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; </s> chiSquare += residual * residual / residualsWeights[i]; </s> } return chiSquare; } </s> java",
      "output": [
        {
          "patch": "chiSquare += residual * residual / residualWeights[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / residualWeights[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / residualsWeights[i];",
          "correctness": "wrong"
        },
        {
          "patch": "chiSquare += residual * residual / rowWeights[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / residualsWeight[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / residualWeight[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / weight[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / residualsWeights[i][0];",
          "correctness": "uncompilable"
        },
        {
          "patch": "chiSquare += residual * residual / residualsWeights[i];",
          "correctness": "wrong"
        },
        {
          "patch": "chiSquare += residual * residual / getResidue(i);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "<s> public static double distance(int[] p1, int[] p2) { </s> int sum = 0; </s> for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); } </s> java",
      "output": [
        {
          "patch": "double sum = 0;",
          "correctness": "wrong"
        },
        {
          "patch": "double sum = 0d;",
          "correctness": "wrong"
        },
        {
          "patch": "float sum = 0f;",
          "correctness": "wrong"
        },
        {
          "patch": "double sum = 0.0;",
          "correctness": "wrong"
        },
        {
          "patch": "float sum = 0;",
          "correctness": "wrong"
        },
        {
          "patch": "int sum = 1;",
          "correctness": "wrong"
        },
        {
          "patch": "double sum = 0D;",
          "correctness": "wrong"
        },
        {
          "patch": "float sum = 0F;",
          "correctness": "wrong"
        },
        {
          "patch": "int sum = 0;",
          "correctness": "wrong"
        },
        {
          "patch": "double sum = 0l;",
          "correctness": "wrong"
        }
      ]
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "<s> public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length != this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); </s> final BigDecimal[] out = new BigDecimal[v.length]; </s> for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; } </s> java",
      "output": [
        {
          "patch": "final BigDecimal[] out = new BigDecimal[nRows];",
          "correctness": "plausible"
        },
        {
          "patch": "BigDecimal[] out = new BigDecimal[v.length];",
          "correctness": "wrong"
        },
        {
          "patch": "final int[] out = new int[v.length];",
          "correctness": "uncompilable"
        },
        {
          "patch": "x.Decimal[] out = new BigDecimal[v.length];",
          "correctness": "uncompilable"
        },
        {
          "patch": "final BigDecimal[] out = new BigDecimal[nCols];",
          "correctness": "wrong"
        },
        {
          "patch": "this.out = new BigDecimal[v.length];",
          "correctness": "uncompilable"
        },
        {
          "patch": "final BigDecimal[] out = new BigDecimal[nColumns];",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal[] out = new BigDecimal[nRows];",
          "correctness": "plausible"
        },
        {
          "patch": "x = new BigDecimal(v.length);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = new BigDecimal[v.length];",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "<s> public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); </s> if (dataset != null) { </s> return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; } </s> java",
      "output": [
        {
          "patch": "if (dataset == null) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (dataset == null || dataset.getRowCount() <= 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (dataset == null || dataset.getRowCount() == 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (dataset == null || dataset.getRowCount() <= 1) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (dataset!= null && dataset.getRowCount() > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (dataset!= null && dataset.getRowCount() == 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (dataset == null || index >= dataset.getRowCount()) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (dataset!= null && dataset.getRowCount()!= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (dataset!= null &&!dataset.isVisible()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (dataset!= null &&!dataset.isCategory()) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "<s> public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); </s> copy.data = new java.util.ArrayList(); </s> if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; } </s> java",
      "output": [
        {
          "patch": "copy.data = new ArrayList();",
          "correctness": "uncompilable"
        },
        {
          "patch": "copy.data = new ArrayList<TimeSeriesDataItem>();",
          "correctness": "uncompilable"
        },
        {
          "patch": "x.util.ArrayList copy.data = new.util.ArrayList();",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TimeSeries) copy.data = new.util.ArrayList();",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TimeSeries) clone).data = new.util.ArrayList();",
          "correctness": "uncompilable"
        },
        {
          "patch": "copy.data = new.util.List<TimeSeriesDataItem>();",
          "correctness": "uncompilable"
        },
        {
          "patch": "copy.data = new ArrayList(new.util.ArrayList());",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.data = new.util.ArrayList();",
          "correctness": "uncompilable"
        },
        {
          "patch": "copy.data = new.util.List(new ArrayList());",
          "correctness": "uncompilable"
        },
        {
          "patch": "copy.data = new ArrayList(new.util.UUIDs());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "<s> public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } </s> return super.equals(obj); </s> } </s> java",
      "output": [
        {
          "patch": "return this.getClass() == obj.getClass() && super.equals(obj);",
          "correctness": "wrong"
        },
        {
          "patch": "return super.equals(obj) && getClass()!= obj.getClass();",
          "correctness": "wrong"
        },
        {
          "patch": "return obj!= null && super.equals(obj);",
          "correctness": "wrong"
        },
        {
          "patch": "return super.equals(obj) && obj.getClass()!= getClass();",
          "correctness": "wrong"
        },
        {
          "patch": "return super.equals(obj) && obj.getClass() == getClass();",
          "correctness": "wrong"
        },
        {
          "patch": "return obj == this || super.equals(obj);",
          "correctness": "wrong"
        },
        {
          "patch": "return super.equals(o);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return obj == this;",
          "correctness": "wrong"
        },
        {
          "patch": "return true;",
          "correctness": "wrong"
        },
        {
          "patch": "return false;",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "<s> public Week(Date time, TimeZone zone) { </s> this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); </s> } </s> java",
      "output": [
        {
          "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, timeZone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, null);",
          "correctness": "wrong"
        },
        {
          "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, defaultTimeZone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, locale);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, time.getTime());",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, TimeZone.getDefault(), Locale.getDefault());",
          "correctness": "plausible"
        },
        {
          "patch": "this(time, zone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, TimeZone.getDefault());",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(time, time.getTimeZone());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "<s> public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } </s> if (endIndex < 0) { </s> emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } } </s> java",
      "output": [
        {
          "patch": "if (endIndex < 0)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (endIndex <= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (endIndex < 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (endIndex < startIndex) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (endIndex < 0 || endIndex - startIndex < 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (endIndex < endIndex) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (endIndex < 0 || endIndex - startIndex < 1) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (endIndex < -1) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (endIndex >= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (endIndex > 0) {",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "<s> public String generateToolTipFragment(String toolTipText) { </s> return \" title=\\\"\" + toolTipText </s> + \"\\\" alt=\\\"\\\"\"; } </s> java",
      "output": [
        {
          "patch": "return \" title=\\\"\" + toolTipText + '\\''\\\" alt=\\\"\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \" title=\\\"\" + toolTipText + '\"\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \" title=\\\"\" + toolTipText + '\\'' + \"\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \"title=\\\"\" + toolTipText + '\\''\\\" alt=\\\"\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \"title=\\\"\" + toolTipText + '\"\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \" title=\\\"\" + toolTipText + '\\''';",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \" title=\\\"\" + toolTipText + '\\''\\\"\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \" title=\\\"\" + toolTipText + '\\''');",
          "correctness": "uncompilable"
        },
        {
          "patch": "return toolTipText;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "<s> public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); </s> PathIterator iterator2 = p1.getPathIterator(null); </s> double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; } </s> java",
      "output": [
        {
          "patch": "PathIterator iterator2 = p2.getPathIterator(null);",
          "correctness": "plausible"
        },
        {
          "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getPathLength());",
          "correctness": "uncompilable"
        },
        {
          "patch": "GeneralPathIterator iterator2 = p1.getPathIterator(null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "GeneralPathIterator iterator2 = p2.getPathIterator(null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "PathIterator iterator2 = p1.getPathIterator(null, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "PathIterator iterator2 = p1.getPathIterator(null, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getRoot());",
          "correctness": "uncompilable"
        },
        {
          "patch": "PathIterator<GeneralPath> iterator2 = p1.getPathIterator(null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getPathDirection());",
          "correctness": "uncompilable"
        },
        {
          "patch": "data PathIterator iterator2 = p2.getPathIterator(null);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "<s> public MultiplePiePlot(CategoryDataset dataset) { super(); </s> this.dataset = dataset; </s> PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } </s> java",
      "output": [
        {
          "patch": "this.dataset = dataset == null? null : dataset;",
          "correctness": "wrong"
        },
        {
          "patch": "this.dataset = (MultiplePiePlot) dataset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.dataset = (MultiplePieDataset) dataset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (dataset!= null) this.dataset = dataset;",
          "correctness": "wrong"
        },
        {
          "patch": "this.dataset = dataset == null? dataset : dataset;",
          "correctness": "wrong"
        },
        {
          "patch": "this.dataProvider = dataset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.data = dataset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.dataSet = dataset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.multiplePiePlot.dataset = dataset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "(MultiplePiePlot) dataset).setShowOnDraw(true);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "<s> public Object clone() throws CloneNotSupportedException { </s> Object clone = createCopy(0, getItemCount() - 1); </s> return clone; } </s> java",
      "output": [
        {
          "patch": "Object clone = createCopy(0, getItemCount());",
          "correctness": "wrong"
        },
        {
          "patch": "final Object clone = createCopy(0, getItemCount() - 1);",
          "correctness": "wrong"
        },
        {
          "patch": "Object clone = createCopy(0, getItemCount() - 1);",
          "correctness": "wrong"
        },
        {
          "patch": "Object clone = createCopy(0, super.get getItemCount() - 1);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object clone = createCopy(0, super.getCount() - 1);",
          "correctness": "uncompilable"
        },
        {
          "patch": "int length = getItemCount(); Object clone = createCopy(0, length);",
          "correctness": "wrong"
        },
        {
          "patch": "Object clone = super.clone();",
          "correctness": "wrong"
        },
        {
          "patch": "Object clone = createCopy(0, getItemCount() - 1L);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object clone = createCopy(0, super.getCount());",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object clone = createCopy(0, length);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "<s> public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { </s> super(paint, stroke, paint, stroke, alpha); </s> this.value = value; } </s> java",
      "output": [
        {
          "patch": "super.init(paint, stroke, paint, stroke, alpha);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, fillAlpha);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super.set(paint, stroke, paint, stroke, alpha);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, scale);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha);",
          "correctness": "wrong"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, outlinePaint);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, composite);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, joinStyle);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, translation * 1000);",
          "correctness": "uncompilable"
        },
        {
          "patch": "super(paint, stroke, paint, stroke, alpha, fillPaint);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "<s> public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); </s> int g = (int) ((value - this.lowerBound) / (this.upperBound </s> - this.lowerBound) * 255.0); return new Color(g, g, g); } </s> java",
      "output": [
        {
          "patch": "int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) Math.ceil((value - this.lowerBound) / (this.upperBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) Math.floor((value - this.lowerBound) / (this.upperBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) ((v - this.lowerBound) / (this.upperBound - v));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) ((v - this.lowerBound) / (this.upperBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) Math.round((value - this.lowerBound) / (this.upperBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - v));",
          "correctness": "uncompilable"
        },
        {
          "patch": "float g = (float) ((value - this.lowerBound) / (this.upperBound - this.lowerBound));",
          "correctness": "uncompilable"
        },
        {
          "patch": "int g = (int) ((value - this.lowerBound) / this.upperBound);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "<s> private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); </s> StringBuffer buff = new StringBuffer(); </s> while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } } </s> java",
      "output": [
        {
          "patch": "StringBuilder buff = new StringBuilder();",
          "correctness": "wrong"
        },
        {
          "patch": "x StringBuilder buff = new StringBuilder();",
          "correctness": "uncompilable"
        },
        {
          "patch": ". StringBuilder buff = new StringBuilder();",
          "correctness": "uncompilable"
        },
        {
          "patch": "final StringBuilder buff = new StringBuilder();",
          "correctness": "wrong"
        },
        {
          "patch": "StringBuffer buff = new StringBuffer(128);",
          "correctness": "wrong"
        },
        {
          "patch": "final StringBuffer buff = new StringBuffer();",
          "correctness": "wrong"
        },
        {
          "patch": "(Buffer) buff = new StringBuffer();",
          "correctness": "uncompilable"
        },
        {
          "patch": "StringBuffer buff = new StringBuffer(64);",
          "correctness": "wrong"
        },
        {
          "patch": "StringBuffer buff = new StringBuffer(32);",
          "correctness": "wrong"
        },
        {
          "patch": "List buff = new ArrayList();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "<s> protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); </s> pos = findWrapPos(text, width, nextLineTabStop); </s> if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } } </s> java",
      "output": [
        {
          "patch": "pos = findWrapPos(text, width, nextLineTabStop, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos = findWrapPos(text, width, nextLineTabStop, 0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos = findWrapPos(text, width - 1, nextLineTabStop);",
          "correctness": "wrong"
        },
        {
          "patch": "pos = findWrapPos(text, width, nextLineTabStop + 1);",
          "correctness": "wrong"
        },
        {
          "patch": "pos = findWrapPos(text, width, tabStop);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos = findWrapPos(text, width, nextLineTabStop, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "int wrapPos = findWrapPos(text, width, nextLineTabStop);",
          "correctness": "wrong"
        },
        {
          "patch": "pos = findWrapPos(text, width);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos = findWrapPos(text, width, nextLineTabStop, tabWidth);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos = findWrapPos(text, width, nextLineTabStop, tabStop);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "<s> private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt() != null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } </s> if (option.hasArg() && (option.getArgName() != null)) </s> { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } } </s> java",
      "output": [
        {
          "patch": "if (option.hasArg() && (option.getArgName()!= null)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "(option.hasArg()) && (option.getArgName()!= null))",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (option.hasArg() && (option.getArgName() == null))",
          "correctness": "plausible"
        },
        {
          "patch": "(option.hasArg()) && (option.getArgName()!= null)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((option.hasArg()) && (option.getArgName()!= null))",
          "correctness": "wrong"
        },
        {
          "patch": "if (option.hasArg() && (option.getArgName() == null)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (option.hasArg())",
          "correctness": "wrong"
        },
        {
          "patch": "(option.getArgName()!= null)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (option.hasArg()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "(option.hasArg())",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "<s> protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { </s> throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); </s> } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } } </s> java",
      "output": [
        {
          "patch": "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);",
          "correctness": "timeout"
        },
        {
          "patch": "throw new IllegalStateException(\"String_Node_Str\" + \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalStateException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalStateException(\"String_Node_Str\" + width + \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalStateException(\"String_Node_Str\" + text + \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalStateException(\"String_Node_Str\" + nextLineTabStop);",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalStateException(String.format(\"String_Node_Str\", nextLineTabStop, width));",
          "correctness": "uncompilable"
        },
        {
          "patch": "sb.append(\"String_Node_Str\");",
          "correctness": "timeout"
        },
        {
          "patch": "return sb;",
          "correctness": "wrong"
        },
        {
          "patch": "x = 0;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "<s> protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { </s> nextLineTabStop = width - 1; </s> } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } } </s> java",
      "output": [
        {
          "patch": "nextLineTabStop = width - 2;",
          "correctness": "wrong"
        },
        {
          "patch": "nextLineTabStop = width;",
          "correctness": "timeout"
        },
        {
          "patch": "nextLineTabStop = 0;",
          "correctness": "wrong"
        },
        {
          "patch": "nextLineTabStop = width - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "nextLineTabStop = -1;",
          "correctness": "wrong"
        },
        {
          "patch": "nextLineTabStop = offset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "nextLineTabStop = width + 1;",
          "correctness": "timeout"
        },
        {
          "patch": "nextLineTabStop = nextTabStop;",
          "correctness": "uncompilable"
        },
        {
          "patch": "nextLineTabStop += 1;",
          "correctness": "timeout"
        },
        {
          "patch": "x = 0;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "<s> protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { </s> break; </s> } cmd.addOption(opt); } } } </s> java",
      "output": [
        {
          "patch": "return;",
          "correctness": "wrong"
        },
        {
          "patch": "opt.addValueForProcessing(value);",
          "correctness": "wrong"
        },
        {
          "patch": "throw new RuntimeException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "opt.addValueForProcessing(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "opt.setRequired(false);",
          "correctness": "wrong"
        },
        {
          "patch": "opt.setOption(Option.YES);",
          "correctness": "uncompilable"
        },
        {
          "patch": "continue;",
          "correctness": "plausible"
        },
        {
          "patch": "opt = null; break;",
          "correctness": "wrong"
        },
        {
          "patch": "opt = null;",
          "correctness": "wrong"
        },
        {
          "patch": "break;",
          "correctness": "wrong"
        }
      ]
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "<s> protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; </s> while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; } </s> return pos == text.length() ? -1 : pos; } </s> java",
      "output": [
        {
          "patch": "while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "while ((pos <= text.length()) && (c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "while ((pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "while (pos < text.length() && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "while (pos <= text.length() && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "char c; while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r') && (c!= '\\r')) ;",
          "correctness": "uncompilable"
        },
        {
          "patch": "c = text.charAt(pos);",
          "correctness": "plausible"
        },
        {
          "patch": "x; x++;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "<s> @SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { </s> return null; </s> } } </s> java",
      "output": [
        {
          "patch": "return (T) null;",
          "correctness": "wrong"
        },
        {
          "patch": "return new T();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (T) createNull();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createObject(str);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (T) defaultValue;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return str;",
          "correctness": "uncompilable"
        },
        {
          "patch": "(T) null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createNull();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return defaultValue;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return null;",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "<s> private void removeUnreferencedFunctionArgs(Scope fnScope) { </s>  </s> Node function = fnScope.getRootNode(); Preconditions.checkState(function.isFunction()); if (NodeUtil.isGetOrSetKey(function.getParent())) { return; } Node argList = getFunctionArgList(function); boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function); if (!modifyCallers) { Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); if (!referenced.contains(var)) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { break; } } } else { callSiteOptimizer.optimize(fnScope, referenced); } } </s> java",
      "output": [
        {
          "patch": "removeUnreferencedArgs(fnScope, referenced);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnusedArgs(fnScope, referenced);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnreferencedArguments(fnScope, referenced);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnreferencedFunctionArgs(fnScope);",
          "correctness": "wrong"
        },
        {
          "patch": "removeUnreferencedFunctions(fnScope, referenced);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnusedArgs(fnScope);",
          "correctness": "uncompilable"
        },
        {
          "patch": "collectReferences(fnScope, referenced);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnreferencedArguments(fnScope);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnusedUnreferencedArgs(fnScope);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeUnreferencedArgs(fnScope);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "<s> private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } </s>  </s> String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child != null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; } </s> java",
      "output": [
        {
          "patch": "Node val = ref.getAssignedValue(); if (val == null) { continue; } for (Node child : val.getFirstChild()) { if (child.isGetterDef() || child.isSetterDef()) { return false;",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node val = ref.getAssignedValue(); if (val == null) { continue; } for (Node child : val.getFirstChild()) { if (child.isGetterDef() || child.isSetterDef()) { return false; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (parent.getLastChild().isGetterDef() || parent.getLastChild().isSetterDef()) { validProperties.add(parent.getLastChild().getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node prop = parent.getLastChild(); if (NodeUtil.isVarOrExprLhs(prop, gramps)) { validProperties.add(prop.getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!NodeUtil.isVarOrExprLitKey(parent)) { validProperties.add(parent.getLastChild().getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "propNames.add(parent.getLastChild().getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!NodeUtil.isVarOrExprLitKey(parent)) { validProperties.add(parent.getLastChild().getString()); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (NodeUtil.isVarOrExprLitKey(parent, gramps)) { validProperties.add(parent.getLastChild().getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!NodeUtil.isVarOrExprLitKey(parent) &&!NodeUtil.isObjectLitKey(parent)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!NodeUtil.isVarOrExprLitKey(parent)) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "<s> static boolean mayBeString(Node n, boolean recurse) { if (recurse) { </s> return allResultsMatch(n, MAY_BE_STRING_PREDICATE); </s> } else { return mayBeStringHelper(n); } } </s> java",
      "output": [
        {
          "patch": "return allResultsMatch(n, mayBeStringPreDICATE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return allResultsMatch(n, STRING_PREDICATE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return recurse(n, MAY_BE_STRING_PREDICATE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return allResultsMatch(n, MatchType.STRING_PREDICATE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return allResultsMatch(n, mayBeStringPredicate);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return allResultsMatch(n, MAY_BE_STRING_MATCH);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return allResultsMatch(n, mayBeStringPredicates);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return mayBeStringHelper(n);",
          "correctness": "plausible"
        },
        {
          "patch": "return allResultsMatch(n, MAY_BE_STRING);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return allResultsMatch(n, MatchType.STRING);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "<s> private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); </s> } else if (n.getJSType() != null && parent.isAssign()) { return; </s> } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); } </s> java",
      "output": [
        {
          "patch": "} else if (n.getJSType()!= null) { JSType jsType = getJSType(n.getFirstChild()); if (jsType!= null && parent.isAssign()) { return; }",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (n.getJSType()!= null) { JSType jsType = getJSType(n); if (jsType == null ||!jsType.isAssign()) { return; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (n.getJSType()!= null) { JSType jsType = getJSType(n); if (jsType!= null && parent.isAssign()) { return; }",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (n.getJSType()!= null) { if (parent.isAssign()) { return; }",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (n.getJSType() == null || parent.isAssign()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (n.getJSType()!= null && parent.isAssignOrProperty()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (n.getJSType()!= null && n.getJSType().isAssign()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} if (n.getJSType()!= null && parent.isAssign()) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (n.getJSType()!= null && parent.isAssign() &&!n.isGetProp()) { return;",
          "correctness": "plausible"
        },
        {
          "patch": "} else {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_14_/src/com/google/javascript/jscomp/ControlFlowAnalysis.java_767-768": {
      "loc": "767-768",
      "input": "<s> private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext() != null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { </s> cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); </s> } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling != null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling != null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } </s> java",
      "output": [
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, cfa);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, catchChain, finallyNode);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, catchedNode);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.getNext());",
          "correctness": "wrong"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.getParent());",
          "correctness": "wrong"
        },
        {
          "patch": "return cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, catchNode);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cfa.createEdge(fromNode, Branch.UNCOND, catchBlock, finallyNode);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "<s> @Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } </s>  </s> for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; } </s> java",
      "output": [
        {
          "patch": "ControlFlowGraph.markNodeForCreation(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.checkNode(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.propagate(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.checkForDeadCode(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.invalidateNode(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.markStart(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.propagate(n, this);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ControlFlowGraph.checkNode(n, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return apply(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return true;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "<s> private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); </s> if (value != null) { </s> Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; } </s> java",
      "output": [
        {
          "patch": "if (value!= null &&!value.isStringKey()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null && value.isStringKey()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null &&!value.getString().equals(\"String_Node_Str\")) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null &&!value.isGetProp()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null &&!value.isName()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null && value.getParent()!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null &&!value.isString()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null &&!value.isQualifiedName()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value!= null &&!value.getString().equals(\"String\")) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (value.isStringKey()) {",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "<s> @Override public void matchConstraint(ObjectType constraintObj) { </s>  </s> if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } } </s> java",
      "output": [
        {
          "patch": "JSType propertyType = getPropertyType(constraintObj); if (propertyType == null) { propertyType = getNativeType(JSTypeNative.VOID_TYPE); } defineInferredProperty(constraintObj, propertyType, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType propType = constraintObj.getPropertyType(JSTypeNative.VOID_TYPE); if (propType == null) { propType = getNativeType(JSTypeNative.VOID_TYPE); } defineInferredProperty(propType, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType propType = constraintObj.getPropertyType(JSTypeNative.VOID_TYPE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(getRecordType(constraintObj));",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType typeToInfer = JSType.VOID_TYPE;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (constraintObj.isRecordType() || constraintObj.isEnumType()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (isRecordType(constraintObj)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType propertyType = getPropertyType(constraintObj);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType propertyType = propertyTypeFromType(constraintObj);",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (constraintObj!= null) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "<s> private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); </s> if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } </s> } } </s> java",
      "output": [
        {
          "patch": "ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null && constraintObj!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType == null) { return;",
          "correctness": "wrong"
        },
        {
          "patch": "if (constraintObj == null || constraintObj.isRecordType()) { return;",
          "correctness": "wrong"
        },
        {
          "patch": "if (type == null || constraintObj == null) { return;",
          "correctness": "wrong"
        },
        {
          "patch": "if (constraintObj == null) { return;",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "<s> private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { return false; } if (declaration != initialization && !initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship != null) { return false; } </s> } </s> } return canMoveAggressively(value) || canMoveModerately(initialization, reference); } </s> java",
      "output": [
        {
          "patch": "} else { return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
          "correctness": "wrong"
        },
        {
          "patch": "} else { return canMoveAggressively(value) || canMoveModerately(initialization, reference);",
          "correctness": "uncompilable"
        },
        {
          "patch": "}; return canMoveAggressively(value) || canMoveModerately(initialization, reference);",
          "correctness": "wrong"
        },
        {
          "patch": "} else { return false; }",
          "correctness": "wrong"
        },
        {
          "patch": "}; return canMoveAggressively(value) || canMoveModerately(initialization, reference); } else { return false;",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (declaration.getBasicBlock()!= initialization.getBasicBlock()) { return false; }",
          "correctness": "wrong"
        },
        {
          "patch": "} else { return canMoveAggressively(value); }",
          "correctness": "wrong"
        },
        {
          "patch": "} else { return canMoveAggressively(value);",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else return false;",
          "correctness": "wrong"
        },
        {
          "patch": "});",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "<s> void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); </s> if (x < 0 && prev == '-') { </s> add(\" \"); } if ((long) x == x && !negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } } </s> java",
      "output": [
        {
          "patch": "if (x < 0 && prev == PLUS_SIGN) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (x < 0 && prev == PLUS) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (x < 0 || prev == '-') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (x < 0 && prev == '+' || prev == '-') {",
          "correctness": "plausible"
        },
        {
          "patch": "if (x < 0 && prev == '+') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (x < 0 && prev == '-' &&!NegativeZero) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (x < 0 && prev == '-' &&!negativeZero) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (x < 0 && prev == '-') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (x < 0 && prev == '-' && sign!= PLUS) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (x < 0 && prev == '-')",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "<s> static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } </s> return len > 0; </s> } </s> java",
      "output": [
        {
          "patch": "return len >= 0;",
          "correctness": "wrong"
        },
        {
          "patch": "return len > 0 && s.length() > 0;",
          "correctness": "wrong"
        },
        {
          "patch": "return len > 0 &&!isBlank(s);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return len > 0 &&!isDecimal(s);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return len > 0 && len < 2;",
          "correctness": "wrong"
        },
        {
          "patch": "return len < 0;",
          "correctness": "wrong"
        },
        {
          "patch": "return len == 0;",
          "correctness": "wrong"
        },
        {
          "patch": "return len <= 0;",
          "correctness": "wrong"
        },
        {
          "patch": "return len > 0;",
          "correctness": "wrong"
        },
        {
          "patch": "return len!= 0;",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "<s> private static boolean isReduceableFunctionExpression(Node n) { </s> return NodeUtil.isFunctionExpression(n); </s> } </s> java",
      "output": [
        {
          "patch": "return NodeUtil.isFunctionExpression(n, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.isFunctionExpression(n, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.isReduceableFunctionExpression(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isFunctionExpression(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.isFunctionExpression(n, false, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "data return NodeUtil.isFunctionExpression(n, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.isFunctionExpression(n.getParent());",
          "correctness": "wrong"
        },
        {
          "patch": "return NodeUtil.isFunctionExpression(n, false, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.isFunctionCallExpression(n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.isFunctionStatement(n);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "<s> private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); </s> if (target != null) { </s> className = target.getString(); } } } } return className; } </s> java",
      "output": [
        {
          "patch": "if (target!= null && target.isStringKey()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (target!= null && target.isName()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (target!= null && target.isGetProp()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (target!= null && target.hasChildren()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (target!= null && target.getParent()!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (target!= null && target.getString()!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (target!= null && target.isQualifiedName()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (target!= null && target.isString()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (target.isStringKey()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (target.isName()) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "<s> public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } </s> if (options.checkGlobalThisLevel.isOn()) { </s> options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; } </s> java",
      "output": [
        {
          "patch": "if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (options.checkGlobalThisLevel.isOn() && options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (options.checkGlobalThisLevel.isOn() || options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (options.checkGlobalThisLevel.isOn() && options.getLanguageIn()!= LanguageMode.ECMASCRIPT5_STRICT) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (options.checkGlobalThisLevel.isOn() && options.getLanguageIn() == LanguageMode.ECMASCRIPT5) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!options.checkGlobalThisLevel.isOn()) {",
          "correctness": "wrong"
        },
        {
          "patch": "data if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": ". if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (options.checkGlobalThisLevel.isOn() && options.checkGlobalThisLevel!= CheckLevel.OFF) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (options.checkGlobalThisLevel.isOn() && options.getLanguageIn()!= LanguageMode.ECMASCRIPT5) {",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "<s> private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) </s> && 0 <= charno && charno < sourceExcerpt.length()) { </s> for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); } </s> java",
      "output": [
        {
          "patch": "if (charno < sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno <= 0 && charno < sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno >= 0 && charno < sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno > 0 && charno < sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno < 0 || charno > sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno < 0 || charno >= sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "while (charno < sourceExcerpt.length()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno < 0) { b.append(\"String_Node_Str\"); } else {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno < 0) { b.append(' '); } else {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (charno < 0) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "<s> static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { </s> case '\\0': sb.append(\"\\\\0\"); break; </s> case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } </s> java",
      "output": [
        {
          "patch": "case '\\t': sb.append(backslashEscape); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append('\\n'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\t': sb.append('\\t'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\t': sb.append(\\\\t); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\''': sb.append('\\'''); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\'': sb.append('/'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\b': sb.append('\\b'); break;",
          "correctness": "wrong"
        },
        {
          "patch": "case '\\''': sb.append('/'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "case '\\n': sb.append('/'); break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "x1f;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "<s> private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP </s> ) { </s> boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; } </s> java",
      "output": [
        {
          "patch": "boolean isChainedProperty = n.getFirstChild().getType() == Token.PROP; if (isChainedProperty) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isChainedProperty = n.getFirstChild().getType() == Token.PROP; if (!isChainedProperty) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (!isChainedProperty) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (n.isGetProp()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node parent = n.getFirstChild(); if (parent!= null) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (n.getFirstChild().getType() == Token.NEW) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (n.getFirstChild().isGetProp()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node parent = n.getParent(); if (parent!= null) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!n.isGetProp()) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "<s> private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, </s> jsDocParameter.getJSType(), true); </s> jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } </s> java",
      "output": [
        {
          "patch": "JSType jsType = jsDocParameter.getJSType(); if (jsType!= null) { jsDocParameter.setType(jsType, true); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "jsDocParameter.setTypeI(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType jsDocType = jsDocParameter.getJSType(); if (jsDocType!= null) { jsDocParameter.setType(jsType, true); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "declareSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType jsDocType = jsDocParameter.getJSType(); if (jsDocType!= null) { jsDocParameter.setType(jsDocType); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType jsDocType = jsDocParameter.getJSType(); if (jsDocType!= null) { jsDocType.declaredType = true; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType jsDocType = jsDocParameter.getJSType(); if (jsDocType == null) { jsDocType = UNKNOWN; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSType jsDocType = jsDocParameter.getJSType(); if (jsDocType == null) { jsDocType = getNativeType(functionNode, true); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "jsDocParameter.setTypeI(functionType, true);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_73_/src/com/google/javascript/jscomp/CodeGenerator.java_1045-1046": {
      "loc": "1045-1046",
      "input": "<s> static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { </s> if (c > 0x1f && c <= 0x7f) { </s> sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } </s> java",
      "output": [
        {
          "patch": "if (c >= 0x1f && c <= 0x7f) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c > 0x1f && c <= 0x7f && c!= '\\0') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c > 0x1f && c < 0x7f) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (c > 0x1f && c <= 0x7e) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (c > 0x1f && c <= 0x7f && c!= '\\\\') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c > 0x1f && c <= 0x7f) {",
          "correctness": "wrong"
        },
        {
          "patch": "if ((c > 0x1f) && (c <= 0x7f)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c <= 0x1f) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c > 0x1f) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c <= 0x7f) {",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "<s> public final boolean isEmptyType() { </s> return isNoType() || isNoObjectType() || isNoResolvedType(); </s> } </s> java",
      "output": [
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isAllType();",
          "correctness": "wrong"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isNoMethod();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isNoRawType();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isNoLocalType();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isNoArrayType();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isNoWildcardType();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType() || isPrimitive();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isNoType() || isNoObjectType() || isNoResolvedType();",
          "correctness": "wrong"
        },
        {
          "patch": "return isNoType() || isNoObjectType();",
          "correctness": "wrong"
        },
        {
          "patch": "(NoType) || (NoType) || isNoResolvedType();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "<s> @Override public int parseArguments(Parameters params) throws CmdLineException { </s> String param = params.getParameter(0); </s> if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } } </s> java",
      "output": [
        {
          "patch": "String param = null; try { param = params.getParameter(0); } catch (Exception e) { }",
          "correctness": "plausible"
        },
        {
          "patch": "String param = null; try { param = params.getParameter(0); } catch (IllegalArgumentException e) { }",
          "correctness": "wrong"
        },
        {
          "patch": "String param = null; if (params.hasParameter(0)) { param = params.getParameter(0); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "String param = null; try { param = params.getParameter(0); } catch (RuntimeException e) { }",
          "correctness": "wrong"
        },
        {
          "patch": "String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}",
          "correctness": "plausible"
        },
        {
          "patch": "String param = null; if (params!= null) { param = params.getParameter(0); }",
          "correctness": "wrong"
        },
        {
          "patch": "final String param = params.getParameter(0);",
          "correctness": "wrong"
        },
        {
          "patch": "String param = params.get(0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String param = getSafeParameter(params, 0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String param = params.getParameters().getParameter(0);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "<s> static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: </s> return true; </s> case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } } </s> java",
      "output": [
        {
          "patch": "break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return false;",
          "correctness": "plausible"
        },
        {
          "patch": "case Token.NEW: return true;",
          "correctness": "uncompilable"
        },
        {
          "patch": "break; case Token.NEW: break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return value.getParent()!= null;",
          "correctness": "wrong"
        },
        {
          "patch": "return locals.apply(value);",
          "correctness": "plausible"
        },
        {
          "patch": "{ return true; }",
          "correctness": "wrong"
        },
        {
          "patch": "break; default: break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return value.isNew();",
          "correctness": "uncompilable"
        },
        {
          "patch": "continue;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "<s> void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition != null && explicitNode != null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { </s> int indexOfDot = namespace.indexOf('.'); </s> if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule) .addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode != null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } } </s> java",
      "output": [
        {
          "patch": "int indexOfDot = namespace.indexOf('.');",
          "correctness": "wrong"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.') + 1;",
          "correctness": "wrong"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.', namespace.length());",
          "correctness": "plausible"
        },
        {
          "patch": "int indexOfDot = namespace.lastIndexOf('.');",
          "correctness": "plausible"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.', true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.', level);",
          "correctness": "uncompilable"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf(File.pathSeparator);",
          "correctness": "uncompilable"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.', 1);",
          "correctness": "wrong"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.', indexOfNamespaceSeparator);",
          "correctness": "uncompilable"
        },
        {
          "patch": "int indexOfDot = namespace.indexOf('.', indexOfNamespace + 1);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "<s> private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt != lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt != rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: </s> result = lvalInt >>> rvalInt; </s> break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } </s> java",
      "output": [
        {
          "patch": "result = lvalInt >>> rvalInt - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt >>> rvalInt;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt >>> rvalInt + 1;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt & rvalInt;",
          "correctness": "wrong"
        },
        {
          "patch": "x = lvalInt >>> rvalInt;",
          "correctness": "uncompilable"
        },
        {
          "patch": "result = rvalInt >>> lvalInt;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt << rvalInt;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt >> rvalInt;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt >>> rvalInt * 2;",
          "correctness": "wrong"
        },
        {
          "patch": "result = lvalInt >>> rvalInt * 10;",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "<s> JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); </s> if (result != null) { </s> return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } </s> java",
      "output": [
        {
          "patch": "if (result!= null && areIdentical(result, that)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (result!= null &&!result.isUnknownType()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (result!= null &&!that.isUnknownType()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (result!= null &&!result.isUnknown()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (result!= null &&!that.isNoResolved()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (result!= null && that.isUnknownType()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (result!= null && result.isUnknownType()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (result!= null && that.isUnknown()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (result == null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (result!= UNKNOWN) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "<s> private Node parseContextTypeExpression(JsDocToken token) { </s> return parseTypeName(token); </s> } </s> java",
      "output": [
        {
          "patch": "return NodeUtil.parseTypeExpression(token);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return parseTypeExpression(token);",
          "correctness": "plausible"
        },
        {
          "patch": "return NodeUtil.parseType(token);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.parseTypeName(token);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return NodeUtil.parseType(token, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return resolveTypeExpression(token);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return parseType(token);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return parseTypeName(token, jsdoc);",
          "correctness": "uncompilable"
        },
        {
          "patch": "xPathType = parseTypeName(token));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return null;",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "<s> @Override protected JSType caseTopType(JSType topType) { </s> return topType; </s> } </s> java",
      "output": [
        {
          "patch": "return JSType.createUnion(topType, baseType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return JSType.createUnion(topType, bottomType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return commonTopType(topType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return JSType.createUnion(new JSType[] { topType });",
          "correctness": "uncompilable"
        },
        {
          "patch": "return JSType.createJSTypeProxy(topType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return JSType.makeUnion(topType, baseType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return JSType.createUnion(topType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isSubtypeOf(topType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return null;",
          "correctness": "wrong"
        },
        {
          "patch": "return UNKNOWN;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "<s> private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null || !provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); </s> if (provided != null) { </s> parent.detachFromParent(); compiler.reportCodeChange(); } } } </s> java",
      "output": [
        {
          "patch": "if (provided!= null && parent!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (provided!= null &&!parent.isRoot()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!provided.isExplicitlyProvided()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (provided!= null &&!parent.isExported()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (provided!= null &&!provided.isConstant()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (provided!= null &&!parent.isGetProp()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (provided == null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (provided!= null &&!parent.isLvalue()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (provided!= null && left!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (provided!= null &&!parent.isExport()) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "<s> private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns != null) { if (parent.isFor() && !NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext() != n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } </s> } else { </s> recordDepScope(recordNode, ns); } } } </s> java",
      "output": [
        {
          "patch": "} else if (!NodeUtil.isForIn(parent)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (!NodeUtil.hasChildren(recordNode)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (!NodeUtil.isForIn(parent, false)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (parent.isFor() || parent.isForIn()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (!NodeUtil.isForIn(recordNode)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (!NodeUtil.isForIn(parent, recordNode)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (parent.isFor() || parent.isForFrom()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} if (!NodeUtil.isForIn(parent)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (parent.isFor()) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (recordNode!= null) {",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "<s> private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { </s>  </s> String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString(), \"\")); } } } } </s> java",
      "output": [
        {
          "patch": "T type = typeSystem.getType(getScope(), n); Property prop = getProperty(child); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(child.getString())) { compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(child.getString()), Warnings.INVALIDATION, child.getString(), n.toString(), \"\")); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "T type = typeSystem.getType(getScope(), n, child.getString()); Property prop = getProperty(child.getString()); prop.scheduleRenaming(child, processProperty(t, prop, type, null)); if (propertiesToErrorFor.containsKey(child.getString())) { compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(child.getString()), Warnings.INVALIDATION, child.getString(), n.toString(), \"\"));",
          "correctness": "uncompilable"
        },
        {
          "patch": "T type = typeSystem.getType(getScope(), n); Property prop = getProperty(child); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(child.getFullName())) { compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(child.getFullName()), Warnings.INVALIDATION, child.getFullName(), n.toString(), \"\")); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Property prop = getProperty(child); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(child.getString())) { compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(child.getString()), Warnings.INVALIDATION, child.getString(), n.toString(), \"\")); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "T type = typeSystem.getType(getScope(), n, child.getString()); Property prop = getProperty(child); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(child.getString())) { compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(child.getString()), Warnings.INVALIDATION, child.getString(), n.toString(), \"\"));",
          "correctness": "uncompilable"
        },
        {
          "patch": "T type = typeSystem.getType(getScope(), n, child.getString()); Property prop = getProperty(child.getString()); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "T type = typeSystem.getType(getScope(), n, child.getString()); Property prop = getProperty(child.getString()); prop.scheduleRenaming(child, processProperty(t, prop, type, null));",
          "correctness": "uncompilable"
        },
        {
          "patch": "T type = typeSystem.getType(getScope(), n, child.getString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "handleObjectLitProperty(child, t);",
          "correctness": "uncompilable"
        },
        {
          "patch": "processPropertyLit(child, t);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "<s> boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { </s> break; </s> } else if (block.isLoop) { return false; } } return true; } </s> java",
      "output": [
        {
          "patch": "return false;",
          "correctness": "wrong"
        },
        {
          "patch": "continue;",
          "correctness": "wrong"
        },
        {
          "patch": "return true;",
          "correctness": "wrong"
        },
        {
          "patch": "throw new AbortParsingBlockError();",
          "correctness": "uncompilable"
        },
        {
          "patch": "ref.setParent(null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ref.decrementRefCount();",
          "correctness": "uncompilable"
        },
        {
          "patch": "ref.setImplicit(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "break;",
          "correctness": "wrong"
        },
        {
          "patch": "ref.setImplicit(false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ref = break;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "<s> private void handleBlockComment(Comment comment) { </s> if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) { </s> errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } } </s> java",
      "output": [
        {
          "patch": "if (comment.getValue().indexOf('/*@')!= -1 || comment.getValue().indexOf(\"\\n * ')!= -1) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (comment.getValue().indexOf('/* '@')!= -1 || comment.getValue().indexOf(\"\\n * ')!= -1) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (comment.getValue().indexOf('/*@')!= -1 || comment.getValue().indexOf(\"\\n *')!= -1) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (comment.getValue().indexOf('/*@')!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (comment.getValue().contains(\"String_Node_Str\") || comment.getValue().contains(\"String_Node_Str\")) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (comment.getValue().indexOf('/*@')!= -1 || comment.getValue().indexOf(\"\\n * '@')!= -1) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (comment.getValue().indexOf('/* '@')!= -1 || comment.getValue().indexOf(\"\\n * '@')!= -1) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (comment.getValue().contains(\"String_Node_Str\")) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (comment.getValue().startsWith(SUSPICIOUS_COMMENT_WARNING)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (comment.getValue().indexOf('<' * '@')!= -1 || comment.getValue().indexOf('<' * '@')!= -1) {",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "<s> private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); </s> if (fnType != null) { </s> visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } } </s> java",
      "output": [
        {
          "patch": "if (fnType!= null &&!fnType.isConstructor()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fnType!= null && fnType.isConstructor()) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (fnType!= null &&!isConstructor(fnType)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (fnType!= null &&!(fnType instanceof ObjectType)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fnType!= null &&!type.isConstructor()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fnType!= null &&!(fnType instanceof FunctionType)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (isConstructor(fnType)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (fnType.isConstructor()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fnType!= null)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (isConstructor) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "<s> private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); </s>  </s> if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } } </s> java",
      "output": [
        {
          "patch": "first.putBooleanProp(Node.DIRECT_EVAL, true);",
          "correctness": "wrong"
        },
        {
          "patch": "first.putBooleanProp(Node.DIRECT_EVAL, false);",
          "correctness": "wrong"
        },
        {
          "patch": "first.putBooleanProp(Node.FREE_CALL, true);",
          "correctness": "wrong"
        },
        {
          "patch": "first.putBooleanProp(Node.FREE_CALL, false);",
          "correctness": "wrong"
        },
        {
          "patch": "NodeUtil.checkCall(first);",
          "correctness": "uncompilable"
        },
        {
          "patch": "first.putBooleanProp(Node.CALL, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "NodeUtil.markCall(n, first);",
          "correctness": "uncompilable"
        },
        {
          "patch": "NodeUtil.markCall(first);",
          "correctness": "uncompilable"
        },
        {
          "patch": "NodeUtil.markCall(first, n);",
          "correctness": "uncompilable"
        },
        {
          "patch": "NodeUtil.markCall(first, true);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "<s> private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } </s> if (name.globalSets == 1 && name.localSets == 0 && </s> name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } </s> java",
      "output": [
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 1 && name.aliasingGets == 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets == 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 1 && name.aliasingGets > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((name.globalSets == 1 && name.localSets == 0) || (name.globalSets == 0 && name.localSets == 0)) &&",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 1 && name.aliasingGets == 0 && name.props!= null) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets == 0 && name.props!= null) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets == 1 && name.localSets == 0 &&!name.props.isEmpty()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (name.globalSets.get() == 1 && name.localSets.get() == 0 &&",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((name.globalSets == 1 || name.localSets == 0) && name.aliasingGets == 0 && name.props!= null) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "<s> private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); </s> return result; </s> } </s> java",
      "output": [
        {
          "patch": "return \"String_Node_Str\" + result;",
          "correctness": "wrong"
        },
        {
          "patch": "return result + \"String_Node_Str\";",
          "correctness": "wrong"
        },
        {
          "patch": "return getRemainingJSDocLine();",
          "correctness": "wrong"
        },
        {
          "patch": "if (result == null) return null; return result;",
          "correctness": "wrong"
        },
        {
          "patch": "x return result + \"String_Node_Str\";",
          "correctness": "uncompilable"
        },
        {
          "patch": "return result.trim();",
          "correctness": "wrong"
        },
        {
          "patch": "if (result!= null) return result; return null;",
          "correctness": "wrong"
        },
        {
          "patch": "return getRemainingJSDocLine(result);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x return result.trim();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return \"String_Node_Str\";",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "<s> public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: </s> return new TypePair(null, null); </s> case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } </s> java",
      "output": [
        {
          "patch": "return new TypePair(this, null);",
          "correctness": "wrong"
        },
        {
          "patch": "return new TypePair(that, null);",
          "correctness": "wrong"
        },
        {
          "patch": "data return new TypePair(this, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new TypePair(null, that);",
          "correctness": "wrong"
        },
        {
          "patch": "return new TypePair(null, null, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(JSType) that).typeB = null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = new TypePair(null, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new TypePair(null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new TypePair(null, null, that);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new TypePair(null, that.getType());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "<s> @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } </s> attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } </s> } </s> java",
      "output": [
        {
          "patch": "attachLiteralTypes(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "defineLiteralTypes(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "attachLiteralTypes(parent);",
          "correctness": "wrong"
        },
        {
          "patch": "processIdentifier(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerLiteral(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "attachLiteralTypes(n.getParent());",
          "correctness": "wrong"
        },
        {
          "patch": "processLiteral(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerUnresolvedType(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "defineLiteral(n, parent);",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerUnresolvedType(n);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "<s> @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); </s> typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); </s> boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); } </s> java",
      "output": [
        {
          "patch": "ObjectType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (typeOfThis!= null) { typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); }",
          "correctness": "wrong"
        },
        {
          "patch": "JSType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); if (typeOfThis == null) { typeOfThis = getNativeType(); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); if (typeOfThis == null) { typeOfThis = JSType.UNKNOWN; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "(ObjectType) { typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); if (typeOfThis == null) { typeOfThis = UNKNOWN; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "ObjectType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); if (typeOfThis == null) { return null; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "xType = (ObjectType) safeResolve(xType, t, scope);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = (ObjectType) safeResolve(x, t, scope);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "<s> private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); </s> if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); </s> } } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { findCalledFunctions(c, changed); } } </s> java",
      "output": [
        {
          "patch": "if (node!= null) { if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); }",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.isGetProp()) { if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node n = node.getFirstChild(); if (n!= null) { if (n.getType() == Token.CALL) { Node child = n.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); }",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.getType() == Token.FUNCTION) { changed.add(node.getString()); } else if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.getType() == Token.FUNCTION) { changed.add(node.getString()); } else { if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); }",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.getType() == Token.FUNCTION) { if (node.getFirstChild().getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); }",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.getType() == Token.FUNCTION) { changed.add(node.getString()); } else if (node.getType() == Token.CALL) { for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed);",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.getType() == Token.FUNCTION) { changed.add(node.getString()); } else if (node.getType() == Token.CALL) { Node call = node.getFirstChild(); if (call.getType() == Token.NAME) { changed.add(call.getString());",
          "correctness": "wrong"
        },
        {
          "patch": "if (node.getType() == Token.FUNCTION) { changed.add(node.getString()); } else if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (node.isGetProp()) { if (node.getType() == Token.CALL) { Node call = node.getFirstChild(); if (call.getType() == Token.NAME) { changed.add(call.getString()); }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "<s> @Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild() != null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } </s> if (t.getScopeDepth() <= 2) { </s> return; } if (n.isName() && NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var != null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope != ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var != null) { Scope ownerScope = var.getScope(); if (scope != ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()) .recordEscapedQualifiedName(n.getQualifiedName()); } } } } </s> java",
      "output": [
        {
          "patch": "if (t.getScopeDepth() <= 3) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (t.getScopeDepth() < 2) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (t.getScopeDepth() > 2) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (t.getScopeDepth() <= 1) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (t.getScopeDepth() >= 2) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (t.getScopeDepth() <= 1 || t.getScopeDepth() == 2) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (t.getScopeDepth() <= 2)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (t.getScopeDepth() <= 2) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (n.isGetProp() && n.getFirstChild()!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (scopeDepth <= 2) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "<s> void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } </s> if (lineLength > 0) { </s> System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } </s> java",
      "output": [
        {
          "patch": "if (lineLength <= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineSeparatorLength > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (lineLength > 0 && lineSeparator!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineSeparator!= null && lineLength > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineSeparator.length > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineLength > 0 && inAvail > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineLength < 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineSeparator!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineLength > 0 &&!eof) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (lineLength >= 0) {",
          "correctness": "wrong"
        }
      ]
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "<s> public Base64() { </s> this(false); </s> } </s> java",
      "output": [
        {
          "patch": "this(true);",
          "correctness": "wrong"
        },
        {
          "patch": "this.base64 = new Base64();",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.base64 = false;",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.isBase64 = false;",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(true, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.position = 0; this.length = 0;",
          "correctness": "uncompilable"
        },
        {
          "patch": "base64 = new Base64();",
          "correctness": "uncompilable"
        },
        {
          "patch": "this.normalize();",
          "correctness": "uncompilable"
        },
        {
          "patch": "data this(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "this(false, 8);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "<s> public static String encodeBase64String(byte[] binaryData) { </s> return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); </s> } </s> java",
      "output": [
        {
          "patch": "return StringUtils.newStringUtf8(encodeBase64(binaryData, Base64.DEFAULT));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false));",
          "correctness": "plausible"
        },
        {
          "patch": "return Base64.encode(binaryData, Base64.DONT_BREAK_LINES);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new String(encodeBase64(binaryData, true), StandardCharsets.UTF_8);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringUtils.newStringUtf8(encodeBase64(binaryData));",
          "correctness": "plausible"
        },
        {
          "patch": "return StringUtils.newStringUtf8(encodeBase64(binaryData, true, 16));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new String(binaryData, StandardCharsets.UTF_8);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringUtils.newStringUtf8(Base64.encodeBase64(binaryData, true));",
          "correctness": "wrong"
        },
        {
          "patch": "return Base64.encodeBase64String(binaryData);",
          "correctness": "wrong"
        },
        {
          "patch": "return Base64.encodeBase64String(binaryData, true);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "<s> public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } </s> long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); </s> if (len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); } </s> java",
      "output": [
        {
          "patch": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, CHUNK_SEPARATOR);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, ir);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, 0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, 16);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, getChunkSeparator());",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, chunkSize, CHUNK_SEPARATOR);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long len = getEncodeLength(binaryData, CHUNK_SIZE);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "<s> public static String newStringIso8859_1(final byte[] bytes) { </s> return new String(bytes, Charsets.ISO_8859_1); </s> } </s> java",
      "output": [
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1).replace('/', '.');",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1, StandardCharsets.UTF_8);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1).toUpperCase();",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1).replace('\\\\', '.');",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1).replace('\\\\', '/');",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1).toLowerCase();",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, Charsets.UTF_8.name());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new String(bytes, Charsets.ISO_8859_1);",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, Charsets.UTF_8);",
          "correctness": "wrong"
        },
        {
          "patch": "return new String(bytes, StandardCharsets.UTF_8);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "<s> public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } </s> return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); </s> } </s> java",
      "output": [
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, cs2, 0, Math.max(cs1.length(), cs2.length()));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
          "correctness": "wrong"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));",
          "correctness": "wrong"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
          "correctness": "wrong"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()) - 1);",
          "correctness": "wrong"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()), false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length() - 1, cs2.length()));",
          "correctness": "wrong"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, Math.min(cs1.length(), cs2.length()));",
          "correctness": "uncompilable"
        },
        {
          "patch": "data return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()), true);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Collections_26_/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java_277-278": {
      "loc": "277-278",
      "input": "<s>  </s> private Object readResolve() { </s> calculateHashCode(keys); return this; } </s> java",
      "output": [
        {
          "patch": "if (keys!= null) { calculateHashCode(keys); return this; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (keys!= null) { calculateHashCode(keys); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "calculateHashCode(keys, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (keys == null) { return null; } calculateHashCode(keys);",
          "correctness": "uncompilable"
        },
        {
          "patch": "calculateHashCode();",
          "correctness": "uncompilable"
        },
        {
          "patch": "calculateHashCode(keys, false); return this;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return calculateHashCode(keys);",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Object result = calculateHashCode(keys);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return this;",
          "correctness": "uncompilable"
        },
        {
          "patch": "readResolve();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "<s> public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } </s> if (read == 0 && inf.finished()) { return -1; </s> } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); } </s> java",
      "output": [
        {
          "patch": "if (read!= 0) { crc.update(buffer, start, read); return read;",
          "correctness": "wrong"
        },
        {
          "patch": "if (read!= 0) { if (read == 0) { return -1; } crc.update(buffer, start, read); return read;",
          "correctness": "wrong"
        },
        {
          "patch": "if (read!= 0) { if (inf.finished()) { return -1; } crc.update(buffer, start, read); return read;",
          "correctness": "timeout"
        },
        {
          "patch": "if (read!= 0 && inf.finished()) { crc.update(buffer, start, read); return read;",
          "correctness": "wrong"
        },
        {
          "patch": "if (read!= 0) { crc.update(buffer, start, read); return read; } else { return 0;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (read!= 0) { crc.update(buffer, start, read); return read; } else { throw new EOFException();",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (read!= 0 && inf.finished()) { return read;",
          "correctness": "wrong"
        },
        {
          "patch": "if (read!= 0) { return read;",
          "correctness": "wrong"
        },
        {
          "patch": "if (read == 0) { throw new EOFException();",
          "correctness": "wrong"
        },
        {
          "patch": "if (read == 0) { return -1;",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "<s> public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry != null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } </s> currEntry = new TarArchiveEntry(headerBuf); </s> entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; } </s> java",
      "output": [
        {
          "patch": "currEntry = new TarArchiveEntry(new ByteArrayInputStream(headerBuf));",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(headerBuf, size);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(headerBuf, offset);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(this, headerBuf);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(buffer, headerBuf);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(readBuf);",
          "correctness": "wrong"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(headerBuf, offset, length);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(headerBuf, offset, count);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(record);",
          "correctness": "uncompilable"
        },
        {
          "patch": "currEntry = new TarArchiveEntry(buf);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "<s> public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } </s> boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { </s> return 0L; } while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; } </s> java",
      "output": [
        {
          "patch": "if (start < end){",
          "correctness": "wrong"
        },
        {
          "patch": "if (buffer[start] ==''){",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (start < end) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (start >= end) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (start >= end){",
          "correctness": "wrong"
        },
        {
          "patch": "if (length < 2){",
          "correctness": "wrong"
        },
        {
          "patch": "if (buffer[start] == '0') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (start > end){",
          "correctness": "wrong"
        },
        {
          "patch": "if (buffer[start]!=''){",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (buffer[start] =='') {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "<s> public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData != null) { int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); </s> if (rawCentralDirectoryData.length != expectedLength) { </s> throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } } </s> java",
      "output": [
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength &&!hasUncompressedSize) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!Arrays.equals(rawCentralDirectoryData.length, expectedLength)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength &&!hasDiskStart) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength || hasDiskStart) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength && hasUncompressedSize) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength ||!hasUncompressedSize) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength + 7) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (rawCentralDirectoryData.length!= expectedLength || hasUncompressedSize) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (rawCentralDirectoryData.length < expectedLength) {",
          "correctness": "plausible"
        }
      ]
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "<s> @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { </s> dictSize |= (coder.properties[i + 1] << (8 * i)); </s> } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); } </s> java",
      "output": [
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * i + 1));",
          "correctness": "wrong"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * i + 1L));",
          "correctness": "wrong"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] & 0xFFL << (8 * i));",
          "correctness": "plausible"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] & 0xFF) << (8 * i);",
          "correctness": "plausible"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * i - 1));",
          "correctness": "wrong"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * i) & 0xff);",
          "correctness": "wrong"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] & 0xFF) << (8 * i));",
          "correctness": "uncompilable"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * i + 1)));",
          "correctness": "uncompilable"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * (i + 1)));",
          "correctness": "wrong"
        },
        {
          "patch": "dictSize |= (coder.properties[i + 1] << (8 * i) & 0xFF);",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "<s> public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } </s> if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } </s> for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; } </s> java",
      "output": [
        {
          "patch": "Preconditions.checkState(start <= end, \"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "Preconditions.checkState(start < end, \"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "start = Math.max(start, end);",
          "correctness": "wrong"
        },
        {
          "patch": "start = end;",
          "correctness": "wrong"
        },
        {
          "patch": "if (start == end) return 0L;",
          "correctness": "plausible"
        },
        {
          "patch": "start = Math.min(start, end);",
          "correctness": "plausible"
        },
        {
          "patch": "checkStartEnd(start, end);",
          "correctness": "uncompilable"
        },
        {
          "patch": "start = end - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "start += 8;",
          "correctness": "wrong"
        },
        {
          "patch": "start = start + 1;",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "<s> public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; </s> if (currentByte == 0) { break; } </s> if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; } </s> java",
      "output": [
        {
          "patch": "if (currentByte == 0xFF) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (currentByte == 0xff) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (currentByte == 0xFF) { break; }",
          "correctness": "plausible"
        },
        {
          "patch": "if (currentByte == 0 || currentByte == '0') {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (currentByte == 0xff) { break; }",
          "correctness": "plausible"
        },
        {
          "patch": "if (currentByte == 0L) { break; }",
          "correctness": "wrong"
        },
        {
          "patch": "if (currentByte == 0 || currentByte ==''){",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (currentByte & 0xff);",
          "correctness": "uncompilable"
        },
        {
          "patch": "break;",
          "correctness": "uncompilable"
        },
        {
          "patch": "continue;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "<s> @Override public boolean isDirectory() { if (file != null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } </s> if (getName().endsWith(\"/\")) { </s> return true; } return false; } </s> java",
      "output": [
        {
          "patch": "if (getName().endsWith(File.separator)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (getName().endsWith(\"String_Node_Str\")) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (getName().endsWith(File.separatorChar)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Link) { return true; } else if (getName().endsWith(\"/\")) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Link) { return true; } else if (getName().endsWith('/')) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (getName().startsWith(\"String_Node_Str\")) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (getName().endsWith(FILE_SUFFIX)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (getName().endsWith(OS_WINDOWS)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (getName().endsWith('/')) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (getName().endsWith('/') || getName().endsWith(2)) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "<s> private static ZipLong unixTimeToZipLong(long l) { </s> final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { </s> throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); } </s> java",
      "output": [
        {
          "patch": "if (l > 0x100000000L) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x1FFFFFFF) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x1FFFFFFFFFFF) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (l > 0x100000000L && l < 0x1000000L) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x100000000L && l < 0x100000000L) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x100000000L && l < 0x1FFFFFFF) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x1ffffffffL) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x1000000FFL) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l >= 0x100000000L) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (l > 0x1000000L) {",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "<s> @Override public int read() throws IOException { int current = super.read(); </s> if (current == '\\n') { </s> lineCounter++; } lastChar = current; return lastChar; } </s> java",
      "output": [
        {
          "patch": "if (current == '\\n' || current == '\\r') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (current == '\\n' && ignoreCase) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (current == '\\n' && ignoreEndings) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (current == '\\n' && lastChar == '\\r') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (current == '\\n' && ignoreTrailingWhitespace) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (current == '\\n' && lineCounter < limit) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (current == '\\n' && ignoreLines) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (current == '\\n' && lineCounter < maxLine) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (current == newLine) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "(current == '\\n') {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "<s> public Map<String, Integer> getHeaderMap() { </s> return new LinkedHashMap<String, Integer>(this.headerMap); </s> } </s> java",
      "output": [
        {
          "patch": "return new LinkedHashMap<>(this.headerMap);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return Collections.unmodifiableMap(this.headerMap);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new LinkedHashMap<String, Integer>(this.headerMap.entrySet());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new LinkedHashMap<String, Integer>(this.headerMap.values());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new LinkedHashMap<String, String>(this.headerMap);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new LinkedHashMap<String, Integer>(this.headerMap);",
          "correctness": "wrong"
        },
        {
          "patch": "return new LinkedHashMap<String, Object>(this.headerMap);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return this.headerMap;",
          "correctness": "plausible"
        },
        {
          "patch": "return new LinkedHashMap<String, Integer>(this.headerMap.clone());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new LinkedHashMap<String, Integer>(this.headerMap.get());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "<s> private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); </s> final boolean emptyHeader = header.trim().isEmpty(); </s> if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; } </s> java",
      "output": [
        {
          "patch": "final boolean emptyHeader = header == null || header.trim().isEmpty();",
          "correctness": "plausible"
        },
        {
          "patch": "final boolean emptyHeader = headerRecord[0].trim().isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader = StringUtils.isBlank(header) || header.trim().isEmpty();",
          "correctness": "uncompilable"
        },
        {
          "patch": "final boolean emptyHeader = header.trim().isEmpty() || headerRecord[0].trim().isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader = header == null? false : header.trim().isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader = header!= null && header.trim().isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader = header.trim().isEmpty() || headerRecord[0].isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader =!header.trim().isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader = headerRecord[i].trim().isEmpty();",
          "correctness": "wrong"
        },
        {
          "patch": "final boolean emptyHeader = header.trim().length() == 0;",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "<s> private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); </s> if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { </s> quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); } </s> java",
      "output": [
        {
          "patch": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (newRecord && (c < '0' || c > '9' && c <= 'A' || c > 'Z' && c <= 'a' || c > 'z')) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c == 'a' || c == 'z')) {",
          "correctness": "wrong"
        },
        {
          "patch": "if ((c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z') && c == quoteChar) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z' || c == delimChar)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c <= '0' && (c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
          "correctness": "plausible"
        },
        {
          "patch": "(c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1192": {
      "loc": "1189-1192",
      "input": "<s> private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); </s> if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { </s> quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); } </s> java",
      "output": [
        {
          "patch": "if (c <= COMMENT) {",
          "correctness": "plausible"
        },
        {
          "patch": "(c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E) {",
          "correctness": "wrong"
        },
        {
          "patch": "if ((c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c <= COMMENT) { quote = true; } else if (c == LF || c == CR || c == quoteChar || c == delimChar) {",
          "correctness": "plausible"
        },
        {
          "patch": "(c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (c == COMMENT) { quote = true; } else if (c == LF || c == CR || c == quoteChar || c == delimChar) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c <= COMMENT &&!newRecord) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (c <= COMMENT) { quote = true; } else if (c == LF) {",
          "correctness": "plausible"
        }
      ]
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "<s> @SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); </s> TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); </s> t.write(writer, fieldValue); } </s> java",
      "output": [
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), targetType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, adapter, fieldType.getType());",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getClass());",
          "correctness": "wrong"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), this);",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), classLoader);",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, field.getType());",
          "correctness": "wrong"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType, fieldType.getType());",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), false);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "<s> public JsonWriter value(double value) throws IOException { writeDeferredName(); </s> if (Double.isNaN(value) || Double.isInfinite(value)) { </s> throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; } </s> java",
      "output": [
        {
          "patch": "if (Double.isNaN(value) || Double.isInfinite(value) || Double.isInfinite(value)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Double.isNaN(value) || Double.isInfinite(value) || Double.isInfinite(-value)) {",
          "correctness": "wrong"
        },
        {
          "patch": ". if (Double.isNaN(value) || Double.isInfinite(value) || Double.isInfinite(value)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": ". if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!Double.isNaN(value) &&!Double.isInfinite(value)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Double.isNaN(value) || Double.isInfinite(value) || value == null) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!Double.isNaN(value) ||!Double.isInfinite(value)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Double.isNaN(value) || Double.isInfinite(value))",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Double.isNaN(value)) {",
          "correctness": "wrong"
        }
      ]
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "<s> @Override public Date read(JsonReader in) throws IOException { </s> if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); </s> } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } } </s> java",
      "output": [
        {
          "patch": "if (in.peek()!= JsonToken.NUMBER) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "if (in.peek() == JsonToken.STRING) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "while (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "if (in.peek()!= JsonToken.DATE) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "JsonToken token = in.peek(); if (token!= JsonToken.STRING) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "if (in.nextString()!= JsonToken.STRING) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (in.peek()!= JsonToken.NUMBER) { throw new JsonParseException(\"String_Node_Str\" + in.nextString());",
          "correctness": "wrong"
        },
        {
          "patch": "if (!in.peek().isString()) { throw new JsonParseException(\"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "JsonToken token = in.peek(); if (token!= JsonToken.STRING) { throw new JsonParseException(\"String_Node_Str\", token);",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (in.peek()!= JsonToken.NUMBER) { throw new JsonParseException(\"String_Node_Str\" + in.peek());",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "<s> private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { </s> char c = str.charAt(i++); </s> if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); } </s> java",
      "output": [
        {
          "patch": "char c = str.charAt(i);",
          "correctness": "plausible"
        },
        {
          "patch": "char c = (str.charAt(i) & 0xff);",
          "correctness": "uncompilable"
        },
        {
          "patch": "final char c = str.charAt(i++);",
          "correctness": "wrong"
        },
        {
          "patch": "char c = str.charAt(i++);",
          "correctness": "wrong"
        },
        {
          "patch": "x; x++; char c = str.charAt(i);",
          "correctness": "uncompilable"
        },
        {
          "patch": "char c = str.charAt(start + i);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x.Character c = str.charAt(i++);",
          "correctness": "uncompilable"
        },
        {
          "patch": "char c = str.charAt((i + 1) % len);",
          "correctness": "plausible"
        },
        {
          "patch": "x++; char c = str.charAt(i);",
          "correctness": "uncompilable"
        },
        {
          "patch": "char c = str.charAt(start + i++);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "<s> private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } </s> for (int i = 0; i < len; ++i) { char c = str.charAt(i); </s> if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); } </s> java",
      "output": [
        {
          "patch": "for (int i = 0; i < str.length(); ++i) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = 0; i < len && i < str.length(); ++i) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (final int i = 0; i < len; ++i) { char c = str.charAt(i);",
          "correctness": "uncompilable"
        },
        {
          "patch": "for (final int i = 0; i < len; ++i) { final char c = str.charAt(i);",
          "correctness": "uncompilable"
        },
        {
          "patch": "for (int i = 0; i < len && i < str.length(); i++) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = 0; i < str.length(); i++) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = 0, n = str.length(); i < n; ++i) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = 0; i <= len; ++i) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = 0; i < len - 1; ++i) { char c = str.charAt(i);",
          "correctness": "wrong"
        },
        {
          "patch": "for (int c = 0; c < len; ++c) { char c = str.charAt(c);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "<s> public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray != null) return _resultArray; if (_resultString != null) { return (_resultArray = _resultString.toCharArray()); } </s> if (!_hasSegments) return _currentSegment; </s> return contentsAsArray(); } </s> java",
      "output": [
        {
          "patch": "if (_hasSegments()) return _currentSegment;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _currentSegment;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_currentSegment!= null) return _currentSegment;",
          "correctness": "wrong"
        },
        {
          "patch": "if (_hasSegments) return _currentSegment;",
          "correctness": "wrong"
        },
        {
          "patch": "if (_hasSegments()) { return _currentSegment; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!_hasSegments || _currentSegment == null) return _currentSegment;",
          "correctness": "wrong"
        },
        {
          "patch": "if (hasSegments()) return _currentSegment;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!_hasSegments() || _currentSegment == null) return null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!_hasSegments || _currentSegment == null) return _emptyBuffer;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!_hasSegments || _currentSegment == null) return null;",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "<s> public void writeEmbeddedObject(Object object) throws IOException { </s> throw new JsonGenerationException(\"No native support for writing embedded objects\", </s> this); } </s> java",
      "output": [
        {
          "patch": "throw new JsonGenerationException(\"String_Node_Str\", object);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", embeddedObj);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", embeddedObjectClass);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", object);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", embeddedObjType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", embeddedObjClass);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", embeddedObjFactory);",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new UnsupportedOperationException(\"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JsonGenerationException(\"String_Node_Str\", object.getClass().getName());",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "<s> private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; </s> if (i <= maxCode) { </s> if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } </s> java",
      "output": [
        {
          "patch": "if (i < maxCode) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (i < 0 || i <= maxCode) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i <= maxCode && codes[i]!= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i <= maxCode && i >= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i <= maxCode && i!= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i < 0 || i >= maxCode) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i >= maxCode) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i <= maxCode - 1) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (i <= maxCode && codes[i]!= '\\0') {",
          "correctness": "wrong"
        },
        {
          "patch": "if (i <= maxCode && (i + 1 >= maxCode)) {",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "<s> @Override public boolean isCachable() { </s> return (_valueTypeDeserializer == null) </s> && (_ignorableProperties == null); } </s> java",
      "output": [
        {
          "patch": "return (_valueTypeDeserializer == null) && (_ignorableProperties == null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) && (_keyTypeDeserializer == null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_keyTypeDeserializer == null)",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) && (_valueTypeReader == null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) || (_valueTypeDeserializer instanceof CollectionTypeDeserializer);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) && _valueTypeDeserializer.isReadable();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) && (_keyTypeDeserializer == null)",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) && (_valueTypeDeserializer.isUninitialized());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (_valueTypeDeserializer == null) || (_valueTypeDeserializer.isUninitialized());",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "<s> protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); </s> return (previous != null) && previous.equals(ann); </s> } </s> java",
      "output": [
        {
          "patch": "return (previous == null)? false : previous.equals(ann);",
          "correctness": "wrong"
        },
        {
          "patch": "return previous!= null && previous.equals(ann);",
          "correctness": "wrong"
        },
        {
          "patch": "return (previous == null)? true : previous.equals(ann);",
          "correctness": "plausible"
        },
        {
          "patch": "return (previous!= null) && previous.equals(ann.annotationType());",
          "correctness": "wrong"
        },
        {
          "patch": "return (previous!= null) && previous.equals(annotation);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return previous == null? false : previous.equals(ann);",
          "correctness": "wrong"
        },
        {
          "patch": "return (previous!= null) && previous.equals(ann.annotationType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (previous!= null) && previous.equals(annot);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(previous!= null) && previous.equals(ann);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (previous!= null);",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "<s> public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() </s> || TreeNode.class.isAssignableFrom(t.getRawClass())); </s> case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } } </s> java",
      "output": [
        {
          "patch": "return TreeNode.class.isAssignableFrom(t.getRawClass());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (t.getRawClass() == Object.class) || TreeNode.class.isAssignableFrom(t.getRawClass());",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (TreeNode.class.isAssignableFrom(t.getRawClass())) { return true; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "x.TreeNode.class.isAssignableFrom(t.getRawClass()));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TreeNode.class.isAssignableFrom(t.getRawClass()) || TreeNode.class.isAssignableFrom(t.getRawClass()))));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TreeNode.class.isAssignableFrom(t.getRawClass()))));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TreeNode.class.isAssignableFrom(t.getRawClass()) || TreeNode.class.isAssignableFrom(t.getRawClass())));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TreeNode.class.isAssignableFrom(t.getRawClass()) || TreeNode.class.isAssignableFrom(t.getRawClass())));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (TreeNode.class.isAssignableFrom(t.getRawClass()));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(TreeNode.class.isAssignableFrom(t.getRawClass())));",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "<s> @Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg != null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann != null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) </s> || _hasAnnotation(a, JsonRawValue.class)) { </s> name = \"\"; } else { return null; } } return PropertyName.construct(name); } </s> java",
      "output": [
        {
          "patch": "if (_hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonView.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonNull.class) || _hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonNull.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonIgnore.class) || _hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonIgnore.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonView.class) || _hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!_hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (_hasAnnotation(a, JsonRawValue.class)) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "<s> @Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { </s> visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); </s> } else { visitor.expectNumberFormat(typeHint); } } } </s> java",
      "output": [
        {
          "patch": "visitDoubleFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
          "correctness": "uncompilable"
        },
        {
          "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);",
          "correctness": "plausible"
        },
        {
          "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_BIG_INTEGER);",
          "correctness": "uncompilable"
        },
        {
          "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL_INTEGER);",
          "correctness": "uncompilable"
        },
        {
          "patch": "visitBigDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_isFloat) { visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_REAL_INTEGER);",
          "correctness": "uncompilable"
        },
        {
          "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER, precision);",
          "correctness": "uncompilable"
        },
        {
          "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_REAL_FLOAT);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = JsonParser.NumberType.BIG_INTEGER;",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "<s> @Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } </s> return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, </s> _valueHandler, _typeHandler, _asStatic); } </s> java",
      "output": [
        {
          "patch": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _asStatic);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _isStatic);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType( subclass, _bindings, _superClass, _superInterfaces, _asStatic);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(_bindings, _superClass, _superInterfaces, _asStatic);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _allowStatic);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(_bindings, _superClass, _superInterfaces, subclass);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new SimpleType(_bindings, _superClass, _superInterfaces);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return subclass;",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "<s> @Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property != null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format != null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } </s> if (format.getShape() == JsonFormat.Shape.STRING) { </s> TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; } </s> java",
      "output": [
        {
          "patch": "if (format.getShape().equals(JsonFormat.Shape.STRING)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (format.isScalar() && format.getShape() == JsonFormat.Shape.STRING) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (format.hasShape() && format.getShape() == JsonFormat.Shape.STRING) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (format.getShape() == JsonFormat.Shape.STRING && format.isDate()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (format.getShape() == JsonFormat.Shape.STRING && format.hasPattern()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (format.getShape() == JsonFormat.Shape.STRING && format.isTime()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (format.getShape() == JsonFormat.Shape.STRING &&!format.isWildcard()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (format.getShape() == JsonFormat.Shape.OBJECT) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (shape == JsonFormat.Shape.STRING) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (format.getShape() == JsonFormat.Shape.DATE) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "<s> @Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); </s> sb.append(';'); </s> return sb; } </s> java",
      "output": [
        {
          "patch": "sb.append(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append('\\\"');",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append(File.pathSeparator);",
          "correctness": "uncompilable"
        },
        {
          "patch": "sb.append(')');",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append('L');",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append('/');",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append(' ');",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append(':');",
          "correctness": "wrong"
        },
        {
          "patch": "sb.append(File.pathSeparatorChar);",
          "correctness": "uncompilable"
        },
        {
          "patch": "sb.append(';').append(']');",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "<s> public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders != null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } </s> return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), </s> true)); } </s> java",
      "output": [
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), false), false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, null), false));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src)), false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true), false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), false), true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), false));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src)));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, null), true));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(_parserFactory, src),",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _bindAndReadValues(_considerFilter(src), false);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "<s> public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { </s> found = key.equals(prop.getName()); </s> if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); } </s> java",
      "output": [
        {
          "patch": "found = key.equals(propToRm.getName());",
          "correctness": "wrong"
        },
        {
          "patch": "found = key.equalsIgnoreCase(prop.getName());",
          "correctness": "plausible"
        },
        {
          "patch": "found = key.equalsIgnoreCase(prop.getName());",
          "correctness": "plausible"
        },
        {
          "patch": "found = key.equals(((SettableBeanProperty) prop).getName());",
          "correctness": "wrong"
        },
        {
          "patch": "found &= key.equals(prop.getName());",
          "correctness": "wrong"
        },
        {
          "patch": "found = key.equals((propToRm.getName()).getName());",
          "correctness": "uncompilable"
        },
        {
          "patch": "found = propToRm.getName().equals(key);",
          "correctness": "wrong"
        },
        {
          "patch": "found = key.equals(((SettableBeanProperty) prop).getKey());",
          "correctness": "uncompilable"
        },
        {
          "patch": "found = key.equals(prop.getKey());",
          "correctness": "uncompilable"
        },
        {
          "patch": "found = key.equals(prop.getName().toLowerCase());",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "<s> public static StdKeyDeserializer forType(Class<?> raw) { int kind; </s> if (raw == String.class || raw == Object.class) { </s> return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); } </s> java",
      "output": [
        {
          "patch": "if (raw == String.class) { return StringKD; } else if (raw == Object.class) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (raw == String.class) { kind = TYPE_STRING; } else if (raw == Object.class) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (raw == String.class || raw == Object.class || raw == UUID.class) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw == String.class) { return TYPE_STRING; } else if (raw == Object.class) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (raw == String.class || raw == Object.class || raw == UUID.class || raw == Character.class) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw == String.class) { return STRING; } else if (raw == Object.class) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (raw == String.class || raw == Object.class || raw == Short.class || raw == Long.class) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw == String.class || raw == Object.class || raw == UUID.class || raw == Short.class) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw == null || raw == String.class || raw == Object.class) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw == String.class) {",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_76_/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java_583-604": {
      "loc": "583-604",
      "input": "<s> @SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { </s> if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } </s> continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps != null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter != null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } </s> java",
      "output": [
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, creatorProp, tokens);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, creatorProp.deserialize(p, ctxt), tokens);",
          "correctness": "uncompilable"
        },
        {
          "patch": "t = p.nextToken(); Object bean = creator.build(ctxt, buffer);",
          "correctness": "wrong"
        },
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, creatorProp.deserialize(p, ctxt), buffer);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, creatorProp, buffer, tokens);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, creatorProp.deserialize(p, ctxt));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, creatorProp, buffer);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return creatorProp.deserialize(p, ctxt);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return creator.build(ctxt, buffer);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "<s> public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } </s> if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { </s> String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); } </s> java",
      "output": [
        {
          "patch": "for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (full!= null && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw!= null && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (_cfgIllegalClassNames.containsKey(full)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (full.startsWith(\"String_Node_Str\")) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (_cfgIllegalClassNames.contains(full)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (\"String_Node_Str\".equals(full)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (full.startsWith(PREFIX_CLASS)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (raw!= null) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (raw instanceof Class<?>) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "<s> protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1 != candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName != null) || (injectId != null); if (!useProps && (paramDef != null)) { </s> paramName = candidate.findImplicitParamName(0); </s> useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef != null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } } </s> java",
      "output": [
        {
          "patch": "paramName = candidate.findImplicitParamName(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "paramName = candidate.findImplicitParamName(false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "paramName = candidate.findImplicitParamName(1);",
          "correctness": "wrong"
        },
        {
          "patch": "(POPropertyBuilder) paramDef).removeExplicitParamName(0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(POPropertyBuilder) paramDef).removeImplicitParamName(0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(POPropertyBuilder) paramDef).removeConstructors();",
          "correctness": "uncompilable"
        },
        {
          "patch": "data paramName = candidate.findImplicitParamName(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "paramName = candidate.findExplicitParamName(0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "xPathObjectBuilder = new xPathObjectBuilder();",
          "correctness": "uncompilable"
        },
        {
          "patch": "data paramName = candidate.findImplicitParamName(false);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "<s> @Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { </s> gen.writeObject(_value); </s> } } </s> java",
      "output": [
        {
          "patch": "gen.writeObject(null);",
          "correctness": "wrong"
        },
        {
          "patch": "gen.writeObject(_value, ctxt);",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(new HashSet<Object>());",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(new JsonSerializable(null));",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(toObject(value));",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(new JsonPrimitive(null));",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(value);",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(obj);",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeString(_value);",
          "correctness": "uncompilable"
        },
        {
          "patch": "gen.writeObject(toObject(_value));",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "<s> public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) { </s> buffer.assignParameter(typeProp, typeId); </s> } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; } </s> java",
      "output": [
        {
          "patch": "buffer.assignParameter(typeProp, typeId, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "buffer.assignParameter(typeProp, typeId.name());",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!buffer.assignParameter(typeProp, typeId)) { return null; }",
          "correctness": "wrong"
        },
        {
          "patch": "buffer.assignParameter(typeProp.getTypeProperty(), typeId);",
          "correctness": "uncompilable"
        },
        {
          "patch": "buffer.assignParameter(typeProp, typeId.getTypeId());",
          "correctness": "uncompilable"
        },
        {
          "patch": "buffer.assignParameter(typeProp.getProperty(), typeId);",
          "correctness": "uncompilable"
        },
        {
          "patch": "buffer.assignParameter(typeProp);",
          "correctness": "uncompilable"
        },
        {
          "patch": "buffer.assignParameter(typeProp, extProp.getType());",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!buffer.assignParameter(typeProp, typeId)) { continue; }",
          "correctness": "wrong"
        },
        {
          "patch": "buffer.assignParameter(typeProp, extProp.getTypeId());",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "<s> @Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { </s> if (property == null) { return this; } </s> JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); } </s> java",
      "output": [
        {
          "patch": "return super.createContextual( serializers, property);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return this;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createContextual( serializers, property);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createContextual( serializers, property, handledType());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createContextual(property, serializers);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createContextualWithoutProperty(property, serializers);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createContextual(property, serializers, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createContextual( serializers, property, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Preconditions.checkNotNull(property);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "<s> protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { </s> return null; </s> } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType != null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; } </s> java",
      "output": [
        {
          "patch": "if (actual == null) { return null; }",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalStateException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return JsonNullValue.INSTANCE;",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new IOException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalArgumentException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return deser;",
          "correctness": "wrong"
        },
        {
          "patch": "return null;",
          "correctness": "wrong"
        },
        {
          "patch": "deser = null;",
          "correctness": "wrong"
        },
        {
          "patch": "return JsonDeserializer.NULL;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return JsonNullValue;",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "<s> protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); </s> _rootNameLookup = src._rootNameLookup; </s> } </s> java",
      "output": [
        {
          "patch": "if (src._rootNameLookup!= null) { _rootNameLookup = src._rootNameLookup; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_rootNameLookup == null) { _rootNameLookup = src._rootNameLookup; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "_rootNameLookup = src._rootNameLookup == null? null : src._rootNameLookup;",
          "correctness": "wrong"
        },
        {
          "patch": "_rootNameLookup = src.getRootNameLookup();",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (_rootNameLookup == null) _rootNameLookup = src._rootNameLookup;",
          "correctness": "uncompilable"
        },
        {
          "patch": "(XmlSerializerProvider) _rootNameLookup = src._rootNameLookup;",
          "correctness": "uncompilable"
        },
        {
          "patch": "xPathObject = src._rootNameLookup;",
          "correctness": "uncompilable"
        },
        {
          "patch": "_rootNameLookup = src.getRootElementNameLookup();",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (src._rootNameLookup == null) { _rootNameLookup = new XMLRootNameLookup(); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (src._rootNameLookup == null) { _rootNameLookup = new DefaultXmlRootNameLookup(); }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "<s> private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); </s> body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); </s> } } </s> java",
      "output": [
        {
          "patch": "body().appendChild(new TextNode(\"String_Node_Str\")); body().appendChild(node);",
          "correctness": "uncompilable"
        },
        {
          "patch": "element.appendChild(new TextNode(\" \", \"\")); element.appendChild(node);",
          "correctness": "wrong"
        },
        {
          "patch": "(Element) body().appendChild(new TextNode(\" \", \"\")); ((Element) body().appendChild(node));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Element) body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Element) body().appendChild(new TextNode(\" \", \"\")); ((Element) element).appendChild(node);",
          "correctness": "uncompilable"
        },
        {
          "patch": "body().appendChild(\"String_Node_Str\"); body().appendChild(node);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Element) body().appendChild(new TextNode(\" \", \"\"))); body().appendChild(node);",
          "correctness": "uncompilable"
        },
        {
          "patch": "body().appendChild(new TextNode(\"String_Node_Str\", \"String_Node_Str\"));",
          "correctness": "wrong"
        },
        {
          "patch": "addChild(new TextNode(\" \", \"\")); addChild(node);",
          "correctness": "wrong"
        },
        {
          "patch": "xPath.appendChild(TextNode) node);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "<s> void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); </s> r.advance(); </s> return; } if (t.isAppropriateEndTagToken() && !r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } } </s> java",
      "output": [
        {
          "patch": "r.advance(false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "t.advance(r.advance());",
          "correctness": "uncompilable"
        },
        {
          "patch": "r.advance(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "t.advance(r.getLength());",
          "correctness": "uncompilable"
        },
        {
          "patch": "t.advance(r.position());",
          "correctness": "uncompilable"
        },
        {
          "patch": "vance(r);",
          "correctness": "uncompilable"
        },
        {
          "patch": "t.advance(r);",
          "correctness": "uncompilable"
        },
        {
          "patch": "r.advance(r.getLength());",
          "correctness": "uncompilable"
        },
        {
          "patch": "r.advance(t.dataBuffer);",
          "correctness": "uncompilable"
        },
        {
          "patch": "characters(r, false, false);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "<s> int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar != input[offset]) while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; </s> if (offset < length) { </s> for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; } </s> java",
      "output": [
        {
          "patch": "if (offset < length - 1) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset < length && last > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset <= length) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset < length && i < last) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset < length && seq.length() > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset < length && last >= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "while (offset < length) {",
          "correctness": "timeout"
        },
        {
          "patch": "if (offset < length - 1 && last > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset < length && i!= last) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (offset < length - 2) {",
          "correctness": "plausible"
        }
      ]
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "<s> public String html() { StringBuilder accum = new StringBuilder(); html(accum); </s> return accum.toString().trim(); </s> } </s> java",
      "output": [
        {
          "patch": "return accum.toString().trim().replaceAll(\"String_Node_Str\", \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().trim().replace(\"String_Node_Str\", \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString();",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().trim().toLowerCase();",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().replaceAll(\"String_Node_Str\", \"String_Node_Str\").trim();",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().replace(\"String_Node_Str\", \"String_Node_Str\").trim();",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().replaceAll(\"String_Node_Str\", \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().replace(\"String_Node_Str\", \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return accum.toString().trim() + \"String_Node_Str\";",
          "correctness": "wrong"
        },
        {
          "patch": "(StringBuilder) accum.append(\"String_Node_Str\"); return accum.toString();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "<s> public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); </s> Validate.notEmpty(name); </s> attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); } </s> java",
      "output": [
        {
          "patch": "Validate.notNull(name);",
          "correctness": "plausible"
        },
        {
          "patch": "Validate.notNull(name, \"String_Node_Str\");",
          "correctness": "plausible"
        },
        {
          "patch": "Validate.notEmpty(name, \"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "data Validate.notNull(name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "xPathValidator.notNull(String) name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "xPathValidator.notEmpty(String) name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "name = Validate.notNull(name)? name : validate(name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "name = Validate.notNull(name)? name : name;",
          "correctness": "uncompilable"
        },
        {
          "patch": ". Validate.notNull(name);",
          "correctness": "uncompilable"
        },
        {
          "patch": "\"String_Node_Str\" + name;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "<s> @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; </s> return this == o; </s> } </s> java",
      "output": [
        {
          "patch": "return this == o || o == null || getClass()!= o.getClass();",
          "correctness": "wrong"
        },
        {
          "patch": "return this == o || o instanceof Element;",
          "correctness": "plausible"
        },
        {
          "patch": "return this == o || o == null && getClass() == o.getClass();",
          "correctness": "wrong"
        },
        {
          "patch": "return this == o || o == null || getClass() == o.getClass();",
          "correctness": "plausible"
        },
        {
          "patch": "return this == o || o == null;",
          "correctness": "wrong"
        },
        {
          "patch": "return this == o || super.equals(o);",
          "correctness": "plausible"
        },
        {
          "patch": "return this == o || element == null;",
          "correctness": "wrong"
        },
        {
          "patch": "return this.getClass() == o.getClass();",
          "correctness": "plausible"
        },
        {
          "patch": "return this == o || element!= null;",
          "correctness": "plausible"
        },
        {
          "patch": "x return this == o;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "<s> private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); </s> if (element.equals(search)) </s> return i; } return null; } </s> java",
      "output": [
        {
          "patch": "if (element.equals(search)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (search.equals(element))",
          "correctness": "wrong"
        },
        {
          "patch": "if (element.equalPrimitive(search))",
          "correctness": "uncompilable"
        },
        {
          "patch": "x if (element.equals(search)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (element!= null && element.equals(search))",
          "correctness": "wrong"
        },
        {
          "patch": "if (element.toString().equals(search.toString()))",
          "correctness": "wrong"
        },
        {
          "patch": "if (element.getReference().equals(search))",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Objects.equal(element, search))",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (search.equals(element)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (element.toString().equals(search))",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "<s> void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; </s> } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) { </s> transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } } </s> java",
      "output": [
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) || \"th\".equals(name) &&!last)) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name)) &&!last) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) || \" th\".equals(name) &&!last)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) || \"td\".equals(name) &&!last)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) || \"th\".equals(name)) &&!last) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) || \"tr\".equals(name) &&!last)) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if (\"td\".equals(name) || \"td\".equals(name) &&!last &&!last) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (\"td\".equals(name) || \"td\".equals(name)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if ((\"td\".equals(name)) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "<s> static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\"); else </s> accum.append(c); </s> break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } </s> java",
      "output": [
        {
          "patch": "accum.append(codePoint);",
          "correctness": "wrong"
        },
        {
          "patch": "if (!inAttribute) accum.append(' '); accum.append(c);",
          "correctness": "wrong"
        },
        {
          "patch": "accum.append(escapeMode.escape(c));",
          "correctness": "uncompilable"
        },
        {
          "patch": "accum.append(\"String_Node_Str\").append(c);",
          "correctness": "wrong"
        },
        {
          "patch": "if (escapeMode!= EscapeMode.xhtml) accum.append(c);",
          "correctness": "wrong"
        },
        {
          "patch": "if (!inAttribute) accum.append(c);",
          "correctness": "wrong"
        },
        {
          "patch": "accum.append(escapeMode.escapeChar(c));",
          "correctness": "uncompilable"
        },
        {
          "patch": "accum.append(escapeMode.escape(c)).append(';');",
          "correctness": "uncompilable"
        },
        {
          "patch": "accum.append(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "accum.append(' ');",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "<s> static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': </s> if (!inAttribute) </s> accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } </s> java",
      "output": [
        {
          "patch": "if (!inAttribute &&!normaliseWhite)",
          "correctness": "wrong"
        },
        {
          "patch": "if (!inAttribute) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (escapeMode!= EscapeMode.xhtml &&!inAttribute)",
          "correctness": "wrong"
        },
        {
          "patch": "if (!inAttribute &&!reachedNonWhite)",
          "correctness": "wrong"
        },
        {
          "patch": "if (inAttribute) accum.append(\"&lt;\"); else",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (inAttribute)",
          "correctness": "wrong"
        },
        {
          "patch": "if (!inAttribute) { accum.append(\"&lt;\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!inAttribute) { accum.append(\"&lt;\"); }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (inAttribute) accum.append(\"&lt;\"); else {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (escapeMode!= EscapeMode.xhtml)",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "<s> boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; </s> return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); </s> } </s> java",
      "output": [
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');",
          "correctness": "wrong"
        },
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'A' && c <= 'z');",
          "correctness": "wrong"
        },
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '.';",
          "correctness": "timeout"
        },
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'A' && c <= 'Z');",
          "correctness": "wrong"
        },
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || '.' == c;",
          "correctness": "timeout"
        },
        {
          "patch": "(c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= '9');",
          "correctness": "wrong"
        },
        {
          "patch": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'Z');",
          "correctness": "wrong"
        },
        {
          "patch": "return isLetterOrDigit(c);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "<s> public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) </s> attributes.remove(attrKey); </s> } } </s> java",
      "output": [
        {
          "patch": "attributes.remove(attrKey.toLowerCase());",
          "correctness": "wrong"
        },
        {
          "patch": "attributes.remove(attrKey.toUpperCase());",
          "correctness": "wrong"
        },
        {
          "patch": "attributes.remove(key);",
          "correctness": "wrong"
        },
        {
          "patch": "attributeMap.remove(attrKey);",
          "correctness": "uncompilable"
        },
        {
          "patch": "getAttribute(attrKey).setValue(null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "removeAttribute(attrKey);",
          "correctness": "uncompilable"
        },
        {
          "patch": "attributes. remove(attrKey.toLowerCase());",
          "correctness": "wrong"
        },
        {
          "patch": "removeAttribute(attrKey);",
          "correctness": "uncompilable"
        },
        {
          "patch": "remove(attrKey);",
          "correctness": "wrong"
        },
        {
          "patch": "attributes.remove(attrName);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "<s> public boolean hasClass(String className) { </s> final String classAttr = attributes.get(\"class\"); </s> final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; } </s> java",
      "output": [
        {
          "patch": "final String classAttr = getClassAttribute(\"class\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String classAttr = attributes().get(\"class\");",
          "correctness": "wrong"
        },
        {
          "patch": "final String classAttr = attributes.get(CLASS_ATTRIBUTE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String classAttr = classAttributes.get(\"class\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String classAttr = getAttribute(\"class\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String classAttr = (String) attributes.get(\"class\");",
          "correctness": "wrong"
        },
        {
          "patch": "final String classAttr = getClassAttr(\"class\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "String classAttr = attributes.get(\"class\");",
          "correctness": "wrong"
        },
        {
          "patch": "final String classAttr = attributes.get(CLASS);",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String classAttr = attributes.get(CLASS_ATTR);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "<s> private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { </s> int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } </s> final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes != null && inSorted(elName, extraTypes)) return false; } return false; } </s> java",
      "output": [
        {
          "patch": "int bottom = stack.size() - 1;",
          "correctness": "plausible"
        },
        {
          "patch": "int bottom = stack.size();",
          "correctness": "wrong"
        },
        {
          "patch": "int bottom = stack.size() + 1;",
          "correctness": "wrong"
        },
        {
          "patch": "int bottom = searchDepth;",
          "correctness": "uncompilable"
        },
        {
          "patch": "final int bottom = stack.size() -1;",
          "correctness": "plausible"
        },
        {
          "patch": "int bottom = scope.size() - 1;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int bottom = stack.size() - 2;",
          "correctness": "wrong"
        },
        {
          "patch": "int bottom = searchDepth - 1;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int bottom = getMaxDepth();",
          "correctness": "uncompilable"
        },
        {
          "patch": "int bottom = maxDepth - 1;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "<s> final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); </s> if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { </s> accum.append(\"=\\\"\"); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append('\"'); } } } </s> java",
      "output": [
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key))) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key))) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key)))) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key)) && Attribute.isBooleanAttribute(key))) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) || Attribute.isBooleanAttribute(key)))) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null ||!val.equals(key) && Attribute.isBooleanAttribute(key)))) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key)))) {",
          "correctness": "wrong"
        },
        {
          "patch": "(val == null || val.equals(key)) && Attribute.isBooleanAttribute(key)) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "<s> private void popStackToClose(Token.EndTag endTag) { </s> String elName = endTag.name(); </s> Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } } </s> java",
      "output": [
        {
          "patch": "String elName = HtmlEntityEncoder.encodeXSS(endTag.name());",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = HtmlUtils.htmlDecode(endTag.name());",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = ElementUtil.getNodeName(endTag);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = HtmlEntityEncoder.encode(endTag.name());",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = ElementUtil.getElName(endTag);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = ElementUtil.getElementName(endTag);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = ElementUtil.getName(endTag);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = TagUtil.getTagName(endTag);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = TagUtil.getName(endTag);",
          "correctness": "uncompilable"
        },
        {
          "patch": "String elName = HtmlEscapers.htmlEscaper().escape(endTag);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "<s> public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; </s> if (doc.childNodeSize() > 0) { </s> Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; } </s> java",
      "output": [
        {
          "patch": "if (doc!= null && doc.childNodeSize() > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (doc.getChildCount() > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "int size = doc.childNodeSize(); if (size > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (doc.hasChildCount()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (doc.getChildNodeSize() > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (doc.hasChildNodeSize()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (doc.childNodeSize() > 0)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!doc.isEmpty()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (doc.hasChild()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (doc.hasChildCount() > 0) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "<s> public String getValue() { </s> return val; </s> } </s> java",
      "output": [
        {
          "patch": "return StringUtils.notNullStr(val);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringUtils.isBlank(val)? null : val;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (val!= null) return val; else return null;",
          "correctness": "wrong"
        },
        {
          "patch": "if (val == null) return null; else return val;",
          "correctness": "wrong"
        },
        {
          "patch": "return val.toString();",
          "correctness": "wrong"
        },
        {
          "patch": "return String.valueOf(val);",
          "correctness": "wrong"
        },
        {
          "patch": "return val.trim();",
          "correctness": "wrong"
        },
        {
          "patch": "return value;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return val.toUpperCase();",
          "correctness": "wrong"
        },
        {
          "patch": "return v;",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "<s> private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0 ? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0 ? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1 != null && p1.equals(p2)) { return 0; } if (depth1 == 1) { </s> throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); </s> } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); } </s> java",
      "output": [
        {
          "patch": "throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: '\" + p1.parent + \"' and '\" + p2.parent + \"'\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new JXPathException(String.format(\"String_Node_Str\", p1, p2));",
          "correctness": "wrong"
        },
        {
          "patch": "throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: '\" + p1.name + \"' and '\" + p2.name + \"'\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JXPathException(buildString(\"String_Node_Str\", new Object[] { p1, p2 }));",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JXPathException(String.format(\"String_Node_Str\", p1, p2), \"String_Node_Str\");",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new JXPathException(String.format(\"String_Node_Str\", p1, p2, p1.parent));",
          "correctness": "wrong"
        },
        {
          "patch": "throw new JXPathException(String.format(\"String_Node_Str\", p1, p2.parent));",
          "correctness": "wrong"
        },
        {
          "patch": "return -1;",
          "correctness": "plausible"
        },
        {
          "patch": "xPathCompare = false;",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "<s> public final Object computeValue(EvalContext context) { </s> return compute(args[0].computeValue(context), args[1].computeValue(context)) </s> ? Boolean.TRUE : Boolean.FALSE; } </s> java",
      "output": [
        {
          "patch": "return compute(args[0], args[1]);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(context, args[0].computeValue(context), args[1].computeValue(context));",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object result = compute(args[0].computeValue(context), args[1].computeValue(context)); return result == null? null : result;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(getScriptObject(context), args[0].computeValue(context), args[1].computeValue(context));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(new ScriptExpression(args[0]), new ScriptExpression(args[1]), context);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(getScriptContext().createValue(args[0]), args[1].computeValue(context));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(new ScriptExpression(args[0]), args[1].computeValue(context));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(context, args[0], args[1]);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(args[0], args[1], args[2]);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return compute(arguments[0], arguments[1]);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "<s> public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType() != Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); </s> return equalStrings(namespaceURI, nodeNS); </s> } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; } </s> java",
      "output": [
        {
          "patch": "return isEqualStrings(namespaceURI, nodeNS);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isEqualNode(namespaceURI, nodeNS);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return equalStrings(nodeNS, namespaceURI);",
          "correctness": "wrong"
        },
        {
          "patch": "return equalStrings(namespaceURI, nodeNS, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return equalStrings(namespaceURI, nodeNS, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isEqual(namespaceURI, nodeNS);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isEqualNS(namespaceURI, nodeNS);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return equalStrings(namespaceURI, nodeNS, isEqual);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return equalStrings(namespaceURI, nodeNS, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return isEqualNode(namespaceURI, nodeNS, true);",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "<s> public int getLength() { </s> return ValueUtils.getLength(getBaseValue()); </s> } </s> java",
      "output": [
        {
          "patch": "return ValueUtils.getLength(getValue());",
          "correctness": "wrong"
        },
        {
          "patch": "return ValueUtils.getLength(value);",
          "correctness": "wrong"
        },
        {
          "patch": "return getValueUtils().getLength(getBaseValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return ValueUtils.getLength(baseValue);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getLength();",
          "correctness": "wrong"
        },
        {
          "patch": "return ValueUtils.getLength(this.getValue());",
          "correctness": "wrong"
        },
        {
          "patch": "return ValueUtils.getLength(this);",
          "correctness": "wrong"
        },
        {
          "patch": "return ValueUtils.getLength(getData());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getLength(getBaseValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getValue().getLength();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "<s> public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { </s> pos += Character.charCount(Character.codePointAt(input, pos)); </s> } } } </s> java",
      "output": [
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pt));",
          "correctness": "plausible"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos),'');",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos), out);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos + 1));",
          "correctness": "wrong"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(c, pos));",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos), false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos) - 1);",
          "correctness": "wrong"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos), 0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(pt, pos));",
          "correctness": "uncompilable"
        },
        {
          "patch": "pos += Character.charCount(Character.codePointAt(input, pos));",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "<s> public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && </s> cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && </s> cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); } </s> java",
      "output": [
        {
          "patch": "cal1.set(Calendar.HOUR_OF_DAY, cal2.get(Calendar.HOUR_OF_DAY));",
          "correctness": "uncompilable"
        },
        {
          "patch": "cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&",
          "correctness": "plausible"
        },
        {
          "patch": "cal2.get(Calendar.HOUR_OF_DAY) == cal1.get(Calendar.HOUR_OF_DAY) &&",
          "correctness": "plausible"
        },
        {
          "patch": "cal2.set(Calendar.HOUR_OF_DAY, cal1.get(Calendar.HOUR_OF_DAY));",
          "correctness": "uncompilable"
        },
        {
          "patch": "cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cal2.get(Calendar.HOUR_OF_DAY) == cal1.get(Calendar.HOUR_OF_DAY);",
          "correctness": "uncompilable"
        },
        {
          "patch": "cal1.put(Calendar.HOUR_OF_DAY, cal2.get(Calendar.HOUR_OF_DAY));",
          "correctness": "uncompilable"
        },
        {
          "patch": "cal1.set(Calendar.HOUR_OF_DAY, cal2.get(Calendar.HOUR_OF_DAY) - 1);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)) &&",
          "correctness": "plausible"
        },
        {
          "patch": "cal2.get(Calendar.HOUR_OF_DAY);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "<s> public String format(Date date) { </s> Calendar c = new GregorianCalendar(mTimeZone); </s> c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); } </s> java",
      "output": [
        {
          "patch": "Calendar c = new GregorianCalendar(getTimeZone());",
          "correctness": "wrong"
        },
        {
          "patch": "Calendar c = new GregorianCalendar(TimeZone.getDefault());",
          "correctness": "wrong"
        },
        {
          "patch": "Calendar c = new GregorianCalendar();",
          "correctness": "wrong"
        },
        {
          "patch": "Calendar c = new GregorianCalendar(mTimeZone.getTimeZone());",
          "correctness": "uncompilable"
        },
        {
          "patch": "Calendar c = new GregorianCalendar(TIME_ZONE_UTC);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Calendar c = new GregorianCalendar(mTimeZone.getDefault());",
          "correctness": "wrong"
        },
        {
          "patch": "Calendar c = Calendar.getInstance(mTimeZone);",
          "correctness": "wrong"
        },
        {
          "patch": "Calendar c = new GregorianCalendar(sTimeZone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Calendar c = new GregorianCalendar(mTimeZone);",
          "correctness": "wrong"
        },
        {
          "patch": "x.Calendar c = new GregorianCalendar(mTimeZone);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_29_/src/main/java/org/apache/commons/lang3/SystemUtils.java_1672-1673": {
      "loc": "1672-1673",
      "input": "<s>  </s> static float toJavaVersionInt(String version) { </s> return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } </s> java",
      "output": [
        {
          "patch": "toJavaVersionInt(version, JAVA_VERSION_TRIM_SIZE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "System.out.println(\"String_Node_Str\" + version); return toJavaVersionInt(version.split(\"String_Node_Str\"));",
          "correctness": "uncompilable"
        },
        {
          "patch": "float versionInt = toJavaVersionInt(version); if (versionInt >= JAVA_VERSION_TRIM_SIZE) { return versionInt; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "float versionInt = toJavaVersionInt(version);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return toJavaVersionInt(version, JAVA_VERSION_TRIM_SIZE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return toJavaVersionInt(version.split(\"String_Node_Str\"));",
          "correctness": "uncompilable"
        },
        {
          "patch": "float versionInt = toJavaVersionInt(version); if (versionInt >= JAVA_VERSION_TRIM_SIZE) return versionInt;",
          "correctness": "uncompilable"
        },
        {
          "patch": "float versionToJavaVersionInt = toJavaVersionInt(version);",
          "correctness": "uncompilable"
        },
        {
          "patch": "System.out.println(\"String_Node_Str\" + version);",
          "correctness": "uncompilable"
        },
        {
          "patch": "float v = toJavaVersionInt(version);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "<s> public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { </s> classes[i] = array[i].getClass(); </s> } return classes; } </s> java",
      "output": [
        {
          "patch": "classes[i] = array[i] == null? null : array[i].getClass();",
          "correctness": "plausible"
        },
        {
          "patch": "classes[i] = array[i]!= null? array[i].getClass() : null;",
          "correctness": "plausible"
        },
        {
          "patch": "classes[i] = array[i]!= null? array[i] : Object.class;",
          "correctness": "uncompilable"
        },
        {
          "patch": "classes[i] = array[i].getClass().getSimpleName();",
          "correctness": "uncompilable"
        },
        {
          "patch": "classes[i] = array[i].getClass().getComponentType();",
          "correctness": "wrong"
        },
        {
          "patch": "classes[i] = array[i]!= null? array[i] : null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "classes[i] = toClass(array[i]);",
          "correctness": "uncompilable"
        },
        {
          "patch": "classes[i] = array[i].getClass().getConcreteType(concrete);",
          "correctness": "uncompilable"
        },
        {
          "patch": "classes[i] = array[i];",
          "correctness": "uncompilable"
        },
        {
          "patch": "classes[i] = array[i].getClass().getInterfaces();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "<s> public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } </s> return contains(str.toUpperCase(), searchStr.toUpperCase()); </s> } </s> java",
      "output": [
        {
          "patch": "return containsIgnoreCase(str, searchStr);",
          "correctness": "wrong"
        },
        {
          "patch": "return containsIgnoreCase(str.toUpperCase(), searchStr.toUpperCase());",
          "correctness": "wrong"
        },
        {
          "patch": "return contains(str.toUpperCase(Locale.US), searchStr.toUpperCase(Locale.getDefault()));",
          "correctness": "wrong"
        },
        {
          "patch": "return contains(str.toUpperCase(Locale.US), searchStr.toUpperCase(Locale.US));",
          "correctness": "wrong"
        },
        {
          "patch": "return containsIgnoreCase(str, searchStr.toUpperCase());",
          "correctness": "wrong"
        },
        {
          "patch": "return containsAnyIgnoreCase(str, searchStr);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return containsIgnoreCase(str.toUpperCase(), searchStr);",
          "correctness": "wrong"
        },
        {
          "patch": "return contains(str.toUpperCase(), searchStr.toUpperCase(Locale.ENGLISH));",
          "correctness": "wrong"
        },
        {
          "patch": "return contains(str, searchStr);",
          "correctness": "wrong"
        },
        {
          "patch": "return contains(str.toUpperCase(), searchStr);",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "<s> private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { </s> return appendTo == null ? null : appendTo.append(QUOTE); </s> } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); } </s> java",
      "output": [
        {
          "patch": "return appendTo == null? c : appendTo.append(QUOTE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(QUOTE + quote);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(quote);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? append(QUOTE) : appendTo.append(QUOTE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(QUOTE).append(quote);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(QUOTE.toQuotedString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(QUOTE.toUpperCase());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(QUOTE);",
          "correctness": "wrong"
        },
        {
          "patch": "return appendTo == null? QUOTE : appendTo.append(QUOTE);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return appendTo == null? null : appendTo.append(QUOTE) + quote;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "<s> public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } </s> } </s> case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; } </s> java",
      "output": [
        {
          "patch": "} else if (str.length() == 3) { return true; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (str.length() == 4) { return true; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (str.length() <= 4) { return false; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (str.length() == 3) { return false; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (str.length() == 4) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else { return false; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (str.length() >= 4) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else { return true; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else return false;",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "<s> public static boolean isAvailableLocale(Locale locale) { </s> return cAvailableLocaleSet.contains(locale); </s> } </s> java",
      "output": [
        {
          "patch": "return availableLocaleSet.contains(locale);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return cAvailableLocaleSet.contains(locale.toString());",
          "correctness": "wrong"
        },
        {
          "patch": "return cAvailableLocaleSet.contains(locale.toLanguageTag());",
          "correctness": "wrong"
        },
        {
          "patch": "return cAvailableLocaleSet.contains(locale.getLanguage());",
          "correctness": "wrong"
        },
        {
          "patch": "return cAvailableLocaleSet.contains(new Locale(locale));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return available locales.contains(locale);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return cAvailableLocaleSet.contains(locale.toLowerCase());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return!cAvailableLocaleSet.contains(locale);",
          "correctness": "wrong"
        },
        {
          "patch": "return cAvailableLocaleSet.contains(locale.getLanguageTag());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return cAvailableLocaleList.contains(locale);",
          "correctness": "plausible"
        }
      ]
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "<s> public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { </s> str.getChars(0, strLen, buffer, size); </s> } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; } </s> java",
      "output": [
        {
          "patch": "str.getChars(strLen, buffer, size);",
          "correctness": "uncompilable"
        },
        {
          "patch": "str.getChars(0, strLen, buffer, size + strLen);",
          "correctness": "wrong"
        },
        {
          "patch": "str.getChars(0, strLen, buffer, size - strLen);",
          "correctness": "wrong"
        },
        {
          "patch": "str.getChars(0, strLen, buffer, size - offset);",
          "correctness": "uncompilable"
        },
        {
          "patch": "str.getChars(0, strLen, buffer, offset);",
          "correctness": "uncompilable"
        },
        {
          "patch": "str.getChars(0, strLen, buffer, start);",
          "correctness": "uncompilable"
        },
        {
          "patch": "str.getChars(start, end, buffer, size);",
          "correctness": "uncompilable"
        },
        {
          "patch": "str.getChars(0, strLen, buffer, size - 1);",
          "correctness": "wrong"
        },
        {
          "patch": "str.getChars(offset, strLen, buffer, size);",
          "correctness": "uncompilable"
        },
        {
          "patch": "str.getChars(padChar, strLen, buffer, size);",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "<s> public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; </s> int len = thisBuf.length - strLen; </s> outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; } } return i; } return -1; } </s> java",
      "output": [
        {
          "patch": "int len = thisBuf.length - strLen + 1;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length - strLen - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length - startIndex + strLen;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length + strLen;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length - strLen + startIndex;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length - startIndex - strLen;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length - startIndex;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = thisBuf.length - strLen + offset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int len = thisBuf.length;",
          "correctness": "wrong"
        },
        {
          "patch": "int len = buffer.length - strLen;",
          "correctness": "wrong"
        }
      ]
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "<s> public double getNumericalMean() { </s> return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); </s> } </s> java",
      "output": [
        {
          "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / getPopulationSize();",
          "correctness": "wrong"
        },
        {
          "patch": "return (double) ((double) getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
          "correctness": "plausible"
        },
        {
          "patch": "return (double) ((getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize());",
          "correctness": "wrong"
        },
        {
          "patch": "return (double) ((getSampleSize() - 1) * getNumberOfSuccesses()) / (double) getPopulationSize();",
          "correctness": "wrong"
        },
        {
          "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
          "correctness": "wrong"
        },
        {
          "patch": "return (double) getSampleSize() * getNumberOfSuccesses() / (double) getPopulationSize();",
          "correctness": "plausible"
        },
        {
          "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getSampleSize();",
          "correctness": "wrong"
        },
        {
          "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize() - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "return (double) ((double) getSampleSize()) / (double) getPopulationSize();",
          "correctness": "wrong"
        },
        {
          "patch": "return (getSampleSize() * getNumberOfSuccesses()) / getPopulationSize();",
          "correctness": "wrong"
        }
      ]
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "<s> public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { </s> return NaN; </s> } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } } </s> java",
      "output": [
        {
          "patch": "returnNaN(imaginary);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return ZERO;",
          "correctness": "wrong"
        },
        {
          "patch": "returnNaN;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return Complex.NaN;",
          "correctness": "wrong"
        },
        {
          "patch": "returnNaN.add(this);",
          "correctness": "uncompilable"
        },
        {
          "patch": "returnNaN.fill(this);",
          "correctness": "uncompilable"
        },
        {
          "patch": "returnNaNForNaN;",
          "correctness": "uncompilable"
        },
        {
          "patch": "returnNaN.set(this);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createNaN();",
          "correctness": "uncompilable"
        },
        {
          "patch": "throw new ComplexWithNaNException();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "<s> public Line revert() { </s> final Line reverted = new Line(zero, zero.subtract(direction)); </s> return reverted; } </s> java",
      "output": [
        {
          "patch": "final Line reverted = new Line(zero, ZERO.subtract(direction));",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(ZERO, ZERO.subtract(direction));",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(zero, one.subtract(direction));",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(zero, zero.subtract(direction));",
          "correctness": "wrong"
        },
        {
          "patch": "final Line reverted = new Line(zero, zero.add(direction));",
          "correctness": "wrong"
        },
        {
          "patch": "final Line reverted = new Line(zero, subtract(direction, ZERO));",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(zero, negative.subtract(direction));",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(ZERO.subtract(direction), ZERO);",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(0, ZERO.subtract(direction));",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Line reverted = new Line(zero, subtract(direction, 0));",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "<s> public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } </s> return FastMath.pow(2 * FastMath.PI, -dim / 2) * </s> FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); } </s> java",
      "output": [
        {
          "patch": "return FastMath.pow(covMatrixDeterminant, -0.5) * getExponentTerm(vals);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.PI;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return FastMath.pow(2 * FastMath.PI, -dim) *",
          "correctness": "wrong"
        },
        {
          "patch": "return FastMath.pow(2 * FastMath.PI, -dim / 2) * Math.PI;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return FastMath.pow(3 * FastMath.PI, -dim / 2) *",
          "correctness": "wrong"
        },
        {
          "patch": "return FastMath.pow(1 / FastMath.PI, -dim / 2) *",
          "correctness": "wrong"
        },
        {
          "patch": "return FastMath.pow(2 * FastMath.PI, -dim / 2.0) *",
          "correctness": "plausible"
        },
        {
          "patch": "return FastMath.pow(1 - FastMath.PI, -dim / 2) *",
          "correctness": "wrong"
        },
        {
          "patch": "return FastMath.pow(1e-5, -dim / 2) *",
          "correctness": "wrong"
        },
        {
          "patch": "return FastMath.pow( FastMath.PI, -dim / 2) *",
          "correctness": "wrong"
        }
      ]
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "<s> public double[] repairAndDecode(final double[] x) { </s> return </s> decode(x); } </s> java",
      "output": [
        {
          "patch": "return decode(x);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return repairAndDecode(x);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return x;",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (x == null) return null;",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = x.toArray(new double[0]));",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = x.toArray(); return x;",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = x.toArray(new double[0]);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = x.clone();",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = x.clone(); x.setLength(0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = x.toArray();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "<s> public double percentageValue() { </s> return multiply(100).doubleValue(); </s> } </s> java",
      "output": [
        {
          "patch": "return (multiply(50).doubleValue());",
          "correctness": "wrong"
        },
        {
          "patch": "return this.multiply(100).doubleValue();",
          "correctness": "wrong"
        },
        {
          "patch": "return add(multiply(100)).doubleValue();",
          "correctness": "wrong"
        },
        {
          "patch": "return (multiply(1.0).doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return add(1).doubleValue();",
          "correctness": "wrong"
        },
        {
          "patch": "return multiply(50).doubleValue();",
          "correctness": "wrong"
        },
        {
          "patch": "return (multiply(50).doubleValue();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (multiply(100).doubleValue();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (multiply(1.0).doubleValue();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return (multiply(100).doubleValue());",
          "correctness": "wrong"
        }
      ]
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "<s> private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { </s> final int n1n2prod = n1 * n2; </s> final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); } </s> java",
      "output": [
        {
          "patch": "final int n1n2prod = n1 + n2;",
          "correctness": "wrong"
        },
        {
          "patch": "final int n1n2prod = n1 * n2;",
          "correctness": "wrong"
        },
        {
          "patch": "final int n1n2prod = n1 - n2;",
          "correctness": "wrong"
        },
        {
          "patch": "final double n1n2prod = n1 * n2;",
          "correctness": "plausible"
        },
        {
          "patch": "final int n1n2prod = n2 * n1;",
          "correctness": "wrong"
        },
        {
          "patch": "int n1n2prod = n1 * n2;",
          "correctness": "wrong"
        },
        {
          "patch": "final int n1n2prod = n1 + n2 - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "final int n1n2prod = n1 ^ n2;",
          "correctness": "wrong"
        },
        {
          "patch": "final int n1n2prod = n2;",
          "correctness": "wrong"
        },
        {
          "patch": "final int n1n2prod = n1 * n2 + 1;",
          "correctness": "wrong"
        }
      ]
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "<s> @Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); </s> if ((Boolean) tree.getAttribute()) { </s> setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } } </s> java",
      "output": [
        {
          "patch": "if (tree.getAttribute()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (tree!= null && ((Boolean) tree.getAttribute()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (!tree.getAttribute()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (tree == null || ((Boolean) tree.getAttribute()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (tree.getAttribute() == Boolean.TRUE) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (tree.getAttribute()!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (tree.getAttribute() == null) {",
          "correctness": "plausible"
        },
        {
          "patch": "if ((Boolean) tree.getAttribute() && tree.isRoot()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((Boolean) tree.getAttribute() || tree.isRoot()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((Boolean) tree.getAttribute())",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "<s> protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); </s> if (Precision.compareTo(entry, 0d, maxUlps) > 0) { </s> columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; } </s> java",
      "output": [
        {
          "patch": "if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, maxUlps) <= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, Integer.MAX_VALUE) > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, getMaxUlps()) > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, tableau.getMaxIterations()) > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, 1.0 / maxUlps) > 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, maxUlps, precision) > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d, precision) > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d) > 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (Precision.compareTo(entry, 0d) >= 0) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "<s> public Iterator<Chromosome> iterator() { </s> return chromosomes.iterator(); </s> } </s> java",
      "output": [
        {
          "patch": "return new ChromosomeIterator(chromosomes.iterator());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new Iterator<Chromosome>(chromosomes.iterator());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new FilterIterator<Chromosome>(chromosomes.iterator());",
          "correctness": "uncompilable"
        },
        {
          "patch": "Iterator<Chromosome> iterator = chromosomes.iterator(); return iterator;",
          "correctness": "wrong"
        },
        {
          "patch": "return Collections.unmodifiableCollection(chromosomes).iterator();",
          "correctness": "plausible"
        },
        {
          "patch": "return new FilterIterator<Chromosome>(chromosomes.iterator(), false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new ChromosomeIterator(chromosomes).iterator();",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new Iterator<Chromosome>(chromosomes.iterator(), Chromosome.class);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new FilterIterator<Chromosome>(chromosomes.iterator(), filter);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return new ChromosomeIterator(chromosomes.iterator(), false);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "<s> public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; </s> for (int i = 0; i < weights.length; i++) { </s> sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; } </s> java",
      "output": [
        {
          "patch": "for (int i = begin; i < begin + length; i++) {",
          "correctness": "plausible"
        },
        {
          "patch": "for (int i = begin; i < begin + weights.length; i++) {",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = begin; i <= begin + length; i++) {",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = 0; i < begin + length; i++) {",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = begin; i < begin + length - 1; i++) {",
          "correctness": "wrong"
        },
        {
          "patch": "for (int i = begin + 1; i < begin + length; i++) {",
          "correctness": "wrong"
        },
        {
          "patch": "x = begin; for (int i = begin; i < begin + length; i++) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "data for (int i = begin; i < begin + length; i++) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "for (int i = 0; i < begin + weights.length; i++) {",
          "correctness": "wrong"
        },
        {
          "patch": "x = begin; for (int i = begin; i < begin + length - 1; i++) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "<s> protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: </s> break; </s> default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } } </s> java",
      "output": [
        {
          "patch": "return x1;",
          "correctness": "wrong"
        },
        {
          "patch": "return x;",
          "correctness": "wrong"
        },
        {
          "patch": "x1 = x; break;",
          "correctness": "wrong"
        },
        {
          "patch": "break;",
          "correctness": "wrong"
        },
        {
          "patch": "x1 = x;",
          "correctness": "wrong"
        },
        {
          "patch": "continue;",
          "correctness": "wrong"
        },
        {
          "patch": "x0 = x1; break;",
          "correctness": "wrong"
        },
        {
          "patch": "x0 = x0; break;",
          "correctness": "wrong"
        },
        {
          "patch": "return f1;",
          "correctness": "wrong"
        },
        {
          "patch": "return x0;",
          "correctness": "wrong"
        }
      ]
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "<s> public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); </s> return createComplex(real + rhs.getReal(), </s> imaginary + rhs.getImaginary()); } </s> java",
      "output": [
        {
          "patch": "return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createComplex(real + rhs.getReal() + rhs.getImaginary(),",
          "correctness": "wrong"
        },
        {
          "patch": "return createComplex(real + rhs.getReal(), imaginary);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createComplex(real + rhs.getReal(), rhs.getImaginary());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createComplex(real + rhs.getReal(), imaginary - rhs.getImaginary());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createComplex(real + rhs.getReal() / rhs.getReal(),",
          "correctness": "wrong"
        },
        {
          "patch": "return createComplex(real + rhs.getReal() / rhs.getImaginary(),",
          "correctness": "wrong"
        },
        {
          "patch": "return createComplex(real + rhs.getReal() / rhs.getScale(),",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createComplex(real + rhs.getReal() + rhs.getNaNReal(),",
          "correctness": "uncompilable"
        },
        {
          "patch": "return createComplex(real + rhs.getReal() + rhs.getTanaka(),",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "<s> public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } </s> int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; </s> return indices; } </s> java",
      "output": [
        {
          "patch": "indices[last] = count;",
          "correctness": "wrong"
        },
        {
          "patch": "count += offset; indices[last] = offset;",
          "correctness": "uncompilable"
        },
        {
          "patch": "indices[last] += count;",
          "correctness": "wrong"
        },
        {
          "patch": "count += offset; indices[last] = count;",
          "correctness": "uncompilable"
        },
        {
          "patch": "count += 1; indices[last] = count;",
          "correctness": "wrong"
        },
        {
          "patch": "indices[last] = count; count++;",
          "correctness": "wrong"
        },
        {
          "patch": "indices[index] = count;",
          "correctness": "wrong"
        },
        {
          "patch": "indices[last] = index;",
          "correctness": "wrong"
        },
        {
          "patch": "indices[last - 1] = count;",
          "correctness": "wrong"
        },
        {
          "patch": "count += offset; indices[last] += offset;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "<s> private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { </s> int sum = 0; </s> for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; } </s> java",
      "output": [
        {
          "patch": "double sum = 0;",
          "correctness": "plausible"
        },
        {
          "patch": "int sum = 1;",
          "correctness": "wrong"
        },
        {
          "patch": "double sum = 0d;",
          "correctness": "plausible"
        },
        {
          "patch": "int sum = 0;",
          "correctness": "wrong"
        },
        {
          "patch": "float sum = 0;",
          "correctness": "plausible"
        },
        {
          "patch": "int bestSolution = 0;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int sum = 1L;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int max = 0;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int sum = -1;",
          "correctness": "plausible"
        },
        {
          "patch": "int sum;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "<s> public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); </s> return fit(new Gaussian.Parametric(), guess); </s> } </s> java",
      "output": [
        {
          "patch": "return fit(new Gaussian.Parametric(), guess, true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new Gaussian.Parametric(), guess, new StopSign());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new Gaussian.Parametric(), guess, getObservations());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new Gaussian.Parametric(), guess, new double[0]);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new Gaussian.Parametric(), guess, false);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fitPoly(new Gaussian.Parametric(), guess);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new Gaussian.Parametric(getObservations())), guess);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new ParametricGaussian(), guess);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new Gaussian.Parametric(), guess, new MeanSquared());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return fit(new ParameterGuesser(getObservations())).guess();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "<s> public static float max(final float a, final float b) { </s> return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); </s> } </s> java",
      "output": [
        {
          "patch": "return (a < b)? b : (Float.isNaN(a + b)? Float.NaN : a);",
          "correctness": "plausible"
        },
        {
          "patch": "return (a < b)? a : (Float.isNaN(a + b)? Float.NaN : b);",
          "correctness": "wrong"
        },
        {
          "patch": "return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : a);",
          "correctness": "plausible"
        },
        {
          "patch": "return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);",
          "correctness": "wrong"
        },
        {
          "patch": "return (a > b)? b : (Float.isNaN(a + b)? Float.NaN : a);",
          "correctness": "wrong"
        },
        {
          "patch": "return ((a < b)? b : (Float.isNaN(a + b)? Float.NaN : a));",
          "correctness": "plausible"
        },
        {
          "patch": "return a < b? b : (Float.isNaN(a + b)? Float.NaN : a);",
          "correctness": "plausible"
        },
        {
          "patch": "return (a < b)? b : (Float.isNaN(a + b)? Float.NaN : b);",
          "correctness": "wrong"
        },
        {
          "patch": "return (a < b)? Float.NaN : a;",
          "correctness": "wrong"
        },
        {
          "patch": "return (a < b)? a : b;",
          "correctness": "wrong"
        }
      ]
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "<s> public static boolean equals(double x, double y) { </s> return (Double.isNaN(x) && Double.isNaN(y)) || x == y; </s> } </s> java",
      "output": [
        {
          "patch": "return (Double.isNaN(x) || Double.isNaN(y)) || x == y;",
          "correctness": "wrong"
        },
        {
          "patch": "return Double.isNaN(x) || Double.isNaN(y) || x == y;",
          "correctness": "wrong"
        },
        {
          "patch": "return (Double.isNaN(x) || Double.isNaN(y)) && x == y;",
          "correctness": "wrong"
        },
        {
          "patch": "return (Double.isNaN(x) && Double.isNaN(y)) || Double.isNaN(x) || Double.isNaN(y);",
          "correctness": "wrong"
        },
        {
          "patch": "return (Double.isNaN(x) && Double.isNaN(y) && x == y) || x == y;",
          "correctness": "plausible"
        },
        {
          "patch": "return (Double.isNaN(x) && Double.isNaN(y)) || Double.isInfinite(x) && Double.isInfinite(y);",
          "correctness": "wrong"
        },
        {
          "patch": "return Double.isNaN(x) && Double.isNaN(y) || x == y;",
          "correctness": "wrong"
        },
        {
          "patch": "return (Double.isNaN(x) || Double.isNaN(y)) && (x == y);",
          "correctness": "wrong"
        },
        {
          "patch": "return Double.isNaN(x) || x == y;",
          "correctness": "wrong"
        },
        {
          "patch": "return Double.isNaN(x) || Double.isNaN(y);",
          "correctness": "wrong"
        }
      ]
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "<s> public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); </s> out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); </s> } } } return new BlockRealMatrix(out); } </s> java",
      "output": [
        {
          "patch": "out[i][j] = 2 * tDistribution.cumulativeProbability(t);",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = tDistribution.cumulativeProbability(t);",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = 2 * tDistribution.probability(t);",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = 1d * tDistribution.cumulativeProbability(t);",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = 2 * tDistribution.cumulativeProbability(-t);",
          "correctness": "plausible"
        },
        {
          "patch": "out[i][j] = 1 - tDistribution.cumulativeProbability(t);",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = 2 * tDistribution.probabilityP(t);",
          "correctness": "uncompilable"
        },
        {
          "patch": "out[i][j] = 2d * tDistribution.cumulativeProbability(t);",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = 2 * (tDistribution.cumulativeProbability(t));",
          "correctness": "wrong"
        },
        {
          "patch": "out[i][j] = 2 * tDistribution.cumulativeProbability(t - 1);",
          "correctness": "wrong"
        }
      ]
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "<s> public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { </s> return solve(min, max); </s> } </s> java",
      "output": [
        {
          "patch": "return solve(min, max, initial);",
          "correctness": "wrong"
        },
        {
          "patch": "return solve(initial, min, max);",
          "correctness": "wrong"
        },
        {
          "patch": "double solution = solve(min, max); return FastMath.max(solution, initial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x return solve(min, max, initial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "double solution = solve(min, max); return FastMath.max(solution, 0, initial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "double solution = solve(min, max); return FastMath.min(solution, initial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(univariateRealFunction) { return solve(min, max); } return 0;",
          "correctness": "uncompilable"
        },
        {
          "patch": "double solution = solve(min, max); return FastMath.max(solution, 0);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(min - initial, max - initial);",
          "correctness": "wrong"
        },
        {
          "patch": "return solve(initial, max);",
          "correctness": "wrong"
        }
      ]
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "<s> public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } </s>  </s> return solve(f, min, yMin, max, yMax, initial, yInitial); } </s> java",
      "output": [
        {
          "patch": "result = solve(f, min, yMin, max, yMax, initial, yInitial);",
          "correctness": "wrong"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial, min, yMin);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x = solve(f, min, yMin, max, yMax, initial, yInitial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "xInitial = solve(f, min, yMin, max, yMax, initial, yInitial);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial, yMin);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial, max, yMin);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial, max);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial, min, yMax);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return solve(f, min, yMin, max, yMax, initial, yInitial, yInitial);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "<s> @Deprecated public double getPct(Object v) { </s> return getCumPct((Comparable<?>) v); </s> } </s> java",
      "output": [
        {
          "patch": "return getCumPct((Comparable<?>) v, precision);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getCumPct(v);",
          "correctness": "wrong"
        },
        {
          "patch": "return (Double) getCumPct((Comparable<?>) v);",
          "correctness": "wrong"
        },
        {
          "patch": "return getCumPct((Comparable<?>) v, precision, recall);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getCumPct((Comparable<? extends Comparable>) v);",
          "correctness": "wrong"
        },
        {
          "patch": "return getCumPct((Comparable<?>) v, locale);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getCumPct((Comparable<?>) v, context);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getCumPct((Comparable<?>) v, useCache);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return getCumPct((Object) v);",
          "correctness": "wrong"
        },
        {
          "patch": "return getCumPct((Comparable<?>) v, precision, scale);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "<s> private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { </s> int j = 4 * n - 1; </s> for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } </s> java",
      "output": [
        {
          "patch": "int j = 4 * (n - 1);",
          "correctness": "plausible"
        },
        {
          "patch": "final int j = 4 * n - 1;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int j = 4 * n - 2;",
          "correctness": "wrong"
        },
        {
          "patch": "int j = 4 * n;",
          "correctness": "wrong"
        },
        {
          "patch": "int j = 4 * (n - 2);",
          "correctness": "wrong"
        },
        {
          "patch": "int j = 2 * n - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "int j = 4 * step - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "int j = 5 * n - 1;",
          "correctness": "wrong"
        },
        {
          "patch": "x = 4 * n - 1;",
          "correctness": "uncompilable"
        },
        {
          "patch": "int j = n - 1;",
          "correctness": "wrong"
        }
      ]
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "<s> private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); </s> if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { </s> final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; } </s> java",
      "output": [
        {
          "patch": "if (MathUtils.compareTo(entry, 0, epsilon) <= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (MathUtils.compare(entry, 0, epsilon) >= 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (entry!= null && MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (MathUtils.signum(entry) >= 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0 && entry!= Double.NaN) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (MathUtils.compareTo(entry, 0, EPSILON) >= 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (MathUtils.compareTo(entry, 0, Math.max(epsilon, 0.0)) >= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (MathUtils.sign(entry) >= 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0 && rhs!= Double.NaN) {",
          "correctness": "wrong"
        }
      ]
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "<s> public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); </s> if (fa * fb >= 0.0 ) { </s> throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; } </s> java",
      "output": [
        {
          "patch": "if (fa * fb > 0.0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (fa * fb < 0.0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fa * fb >= 0.0 && numIterations < maximumIterations) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fa * fb <= 0.0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fa * fb >= 1.0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (!isConverged(fa, fb)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((fa * fb > 0.0) && (numIterations > 1)) {",
          "correctness": "plausible"
        },
        {
          "patch": "if ((fa * fb >= 0.0) && (numIterations > 1)) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (fa * fb!= 0.0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (fa * fb >= 0.0 && numIterations > 0) {",
          "correctness": "wrong"
        }
      ]
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "<s> public int compareTo(Fraction object) { </s> double nOd = doubleValue(); double dOn = object.doubleValue(); </s> return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); } </s> java",
      "output": [
        {
          "patch": "double nOd = doubleToDouble(object.doubleValue()); double dOn = doubleToDouble(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToRadians(object.doubleValue()); double dOn = doubleToRadians(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToMicros(object.doubleValue()); double dOn = doubleToMicros(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToSign(object.doubleValue()); double dOn = doubleToSign(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToMeters(object.doubleValue()); double dOn = doubleToMeters(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToRaw(object.doubleValue()); double dOn = doubleToRaw(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToNanos(object.doubleValue()); double dOn = doubleToNanos(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToOM(object.doubleValue()); double dOn = doubleToOM(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToLongBits(object.doubleValue()); double dOn = doubleToLongBits(object.doubleValue());",
          "correctness": "uncompilable"
        },
        {
          "patch": "double nOd = doubleToMicros(object.doubleValue()); double dOn = doubleToMicros(object);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "<s> public static int gcd(int u, int v) { </s> if (u * v == 0) { </s> return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1) ? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t != 0); return -u * (1 << k); } </s> java",
      "output": [
        {
          "patch": "if (u * v < 0) {",
          "correctness": "timeout"
        },
        {
          "patch": "if (u * v == 0 || v * u == 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if ((u * v) == 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (u == 0 || v == 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "if (Math.abs(u) * v == 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (u < 0 || v < 0) {",
          "correctness": "timeout"
        },
        {
          "patch": "if ((u & 1) == 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (u * v == 0 || v * u < 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (u % v == 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (Math.abs(u) * v < 0) {",
          "correctness": "timeout"
        }
      ]
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "<s> public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { </s> ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); </s> } } catch (ClassCastException ex) { ret = false; } } return ret; } </s> java",
      "output": [
        {
          "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()) || Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
          "correctness": "wrong"
        },
        {
          "patch": "ret = (Double.compare(real, rhs.getReal()) == 0) && (Double.compare(imaginary, rhs.getImaginary()) == 0);",
          "correctness": "wrong"
        },
        {
          "patch": "ret = (Double.doubleToRawLongBits(real) == rhs.getReal()) && (Double.doubleToRawLongBits(imaginary) == rhs.getImaginary());",
          "correctness": "wrong"
        },
        {
          "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()) && Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
          "correctness": "wrong"
        },
        {
          "patch": "(Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
          "correctness": "uncompilable"
        },
        {
          "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()));",
          "correctness": "wrong"
        },
        {
          "patch": "ret = Double.doubleToRawLongBits(real) == rhs.getReal();",
          "correctness": "wrong"
        },
        {
          "patch": "ret = Double.compare(real, rhs.getReal());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "<s> public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; </s> if ( </s> source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } </s> java",
      "output": [
        {
          "patch": "if (source.charAt(startIndex) == '-' && source.charAt(endIndex) == '+') {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (endIndex > startIndex && source.charAt(endIndex - startIndex) == getImaginaryCharacter()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (startIndex < endIndex && source.charAt(startIndex) == getImaginaryCharacter()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (startIndex < endIndex)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (startIndex < endIndex) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (startIndex < endIndex && source.charAt(startIndex) == '+') {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (source.length() > startIndex + endIndex)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (source.length() > startIndex + endIndex) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (startIndex >= 0 && endIndex >= 0) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (pos.getErrorIndex() == startIndex) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "<s> public double getSumSquaredErrors() { </s> return sumYY - sumXY * sumXY / sumXX; </s> } </s> java",
      "output": [
        {
          "patch": "return sumYY - sumXY * sumXY / sumXX;",
          "correctness": "wrong"
        },
        {
          "patch": "return Math.sqrt(sumYY - sumXY * sumXY / sumXX);",
          "correctness": "wrong"
        },
        {
          "patch": "return sumYY - sumXY * sumXY / sumXX + sumYY;",
          "correctness": "wrong"
        },
        {
          "patch": "return sumYY - sumXY * sumXY / (sumXX - sumYY);",
          "correctness": "wrong"
        },
        {
          "patch": "return sumXX - sumYY * sumXY * sumXY / sumXX;",
          "correctness": "wrong"
        },
        {
          "patch": "return Math.pow(sumYY - sumXY * sumXY / sumXX, 2);",
          "correctness": "wrong"
        },
        {
          "patch": "return Math.abs(sumYY - sumXY * sumXY / sumXX);",
          "correctness": "plausible"
        },
        {
          "patch": "return Math.pow(sumYY - sumXY * sumXY / sumXX, 2.0);",
          "correctness": "wrong"
        },
        {
          "patch": "return sumYY - sumXY * sumXY / sumXX - sumYY;",
          "correctness": "wrong"
        },
        {
          "patch": "return sumYY - sumXY * sumXY / sumXX + sumYY * sumYY;",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "<s> public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; </s> throw new UnsupportedOperationException(); </s> } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } } </s> java",
      "output": [
        {
          "patch": "throw new UnsupportedOperationException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new UnsupportedOperationException(invocation.getMethod().getName());",
          "correctness": "wrong"
        },
        {
          "patch": "throw new UnsupportedOperationException(invocation.getMethod().toString());",
          "correctness": "wrong"
        },
        {
          "patch": "throw new UnsupportedOperationException(invocation.getClass().getName());",
          "correctness": "wrong"
        },
        {
          "patch": "throw new RuntimeException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "throw new UnsupportedOperationException(invocation.toString());",
          "correctness": "wrong"
        },
        {
          "patch": "return false;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return;",
          "correctness": "plausible"
        },
        {
          "patch": "return true;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return null;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "<s> public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } </s> catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { </s> error = handleVerifyException(e); } } if (error != null) { throw error; } } </s> java",
      "output": [
        {
          "patch": "catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {",
          "correctness": "wrong"
        },
        {
          "patch": "catch (org.mockito.exceptions.verification.junit.ArgumentsAreSame e) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "catch (org.mockito.exceptions.verification.junit.ArgumentsNotSame e) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "(org.mockito.exceptions.verification.junit.ArgumentsAreDifferent) -> {",
          "correctness": "uncompilable"
        },
        {
          "patch": "catch (IllegalArgumentException e) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "catch (InvocationTargetException e) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "catch (AssertionError e) {",
          "correctness": "plausible"
        },
        {
          "patch": "} catch (InvocationTargetException e) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "catch (ComparisonException e) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "catch (Exception e) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "<s> private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } </s> registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); </s> } </s> java",
      "output": [
        {
          "patch": "registerTypeVariablesOn(actualTypeArgumentFor(typeVariable));",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerTypeVariablesOn(actualTypeArgument);",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerTypeVariablesOn(ActualTypeArgumentFor(typeVariable));",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerTypeVariablesOn( getActualTypeArgumentFor(typeVariable, false));",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerTypeVariablesOn( getActualTypeArgumentFor(typeVariable));",
          "correctness": "wrong"
        },
        {
          "patch": "data registerTypeVariablesOn(actualTypeArgumentFor(typeVariable));",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerTypeVariablesOn(actualTypeVariable);",
          "correctness": "uncompilable"
        },
        {
          "patch": "(ActualTypeVariable) -> registerTypeVariablesOn(actualTypeArgument));",
          "correctness": "uncompilable"
        },
        {
          "patch": "registerTypeVariablesOn(ActualTypeArgumentFor(typeVariable, false));",
          "correctness": "uncompilable"
        },
        {
          "patch": "(ActualTypeVariable) -> registerTypeVariablesOn(actualTypeVariable));",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "<s> protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); </s> } else { </s> contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } } </s> java",
      "output": [
        {
          "patch": "} else if (actualTypeArgument!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (actualTypeArgument!= Types.ANY) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (!(actualTypeArgument instanceof WildcardType)) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (actualTypeArgument instanceof WildcardType) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (actualTypeArgument.isSuperTypeOf(classType)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (actualTypeArgument!= WildcardType.EXTENDS) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (actualTypeArgument!= Types.UNKNOWN) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (actualTypeArgument.isSuperClass()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (actualTypeArgument.isWildcardType()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "} else if (actualTypeArgument.isSuperClassOf(classType)) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "<s> public static boolean areEqual(Object o1, Object o2) { </s> if (o1 == null || o2 == null) { </s> return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } } </s> java",
      "output": [
        {
          "patch": "if (o1 == null && o2 == null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (o1 == null || o2 == null || o1.equals(o2)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (o1 == null || o2 == null || o1.length!= o2.length) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (o1 == null || o2 == null || isPrimitive(o1) || isPrimitive(o2)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((o1 == null) || (o2 == null)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (o1 == null || o2 == null || o1 == o2) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (o1 == null || o2 == null || o1 == Object.NULL) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if ((o1 == null) && (o2 == null)) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (o1 == null || o2 == null)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (o1 == null) {",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "<s> public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { </s> return 1; </s> } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); } </s> java",
      "output": [
        {
          "patch": "return \"String_Node_Str\";",
          "correctness": "wrong"
        },
        {
          "patch": "throw new RuntimeException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return 0;",
          "correctness": "wrong"
        },
        {
          "patch": "throw new IllegalArgumentException(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "return returnValueFor(invocation.getMethod());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return invocation.getMethod().getReturnType();",
          "correctness": "wrong"
        },
        {
          "patch": "return invocation.getMethod().getName();",
          "correctness": "wrong"
        },
        {
          "patch": "return null;",
          "correctness": "wrong"
        },
        {
          "patch": "return new Integer(1);",
          "correctness": "wrong"
        },
        {
          "patch": "return false;",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "<s> public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); </s> MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); </s> ((Factory) mock).setCallback(0, newFilter); } </s> java",
      "output": [
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNURNS_DEFAULTS));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.NO_RESPONSES));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandlerImpl<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilterImpl(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandlerImpl<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.NO_RESPONSES));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, mock); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.NO_RESPONSES));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MethodInterceptorFilter newFilter = new MethodInterceptorFilter(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MethodInterceptorFilter newFilter = new MethodInterceptorFilter(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNURNS_DEFAULTS));",
          "correctness": "uncompilable"
        },
        {
          "patch": "MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS), oldMockHandler);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "<s> private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { </s> mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); </s> } } </s> java",
      "output": [
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance, true).thenInject();",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance, false).thenInject();",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(true);",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(field);",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(mocks);",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(fieldInstance);",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(mockCandidate);",
          "correctness": "uncompilable"
        },
        {
          "patch": "filterCandidate(mocks, field, fieldInstance).thenInject();",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();",
          "correctness": "uncompilable"
        },
        {
          "patch": "mockCandidateFilter.filterCandidate(mocks, field).thenInject();",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "<s> public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); </s> description.appendText(wanted.toString()); </s> appendQuoting(description); description.appendText(\")\"); } </s> java",
      "output": [
        {
          "patch": "description.appendText(\"String_Node_Str\");",
          "correctness": "wrong"
        },
        {
          "patch": "description.appendText(getWanted().toString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "description.appendText(wanted == null? \"null\" : wanted.toString());",
          "correctness": "plausible"
        },
        {
          "patch": "description.appendText(\"String_Node_Str\" + wanted.toString());",
          "correctness": "wrong"
        },
        {
          "patch": "description.appendText(wanted);",
          "correctness": "uncompilable"
        },
        {
          "patch": "description.appendText(wanted == null? \"NULL\" : wanted.toString());",
          "correctness": "plausible"
        },
        {
          "patch": "if (wanted!= null) { description.appendText(wanted.toString()); }",
          "correctness": "plausible"
        },
        {
          "patch": "description.appendText(\"String_Node_Str\").append(wanted.toString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "description.appendText(\"String_Node_Str\" + wanted);",
          "correctness": "wrong"
        },
        {
          "patch": "description.appendText(getFirstWanted().toString());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "<s> public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { </s> if (m instanceof CapturesArguments) { </s> ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } } </s> java",
      "output": [
        {
          "patch": "if (m instanceof CapturesArguments && i.getArguments()!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (m instanceof CapturesArguments)",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (m instanceof CapturesArguments && i!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (m instanceof CapturesArguments && m!= NULL_MATCHER) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (m instanceof CapturesArguments && m!= null) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (m instanceof CapturedArguments) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (m instanceof CapturesArguments && m!= Object.class) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (m instanceof CapturesArguments && m.is captureable()) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (m instanceof CapturesArguments) {",
          "correctness": "wrong"
        },
        {
          "patch": "if (m instanceof CapturesArguments && m!= NULL_MATCH) {",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "<s> private boolean toStringEquals(Matcher m, Object arg) { </s> return StringDescription.toString(m).equals(arg.toString()); </s> } </s> java",
      "output": [
        {
          "patch": "return StringDescription.toString(m).equals(arg);",
          "correctness": "wrong"
        },
        {
          "patch": "return StringDescription.toString(m).equals(StringDescription.toString(arg));",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringDescription.toString(m).toString().equals(arg.toString());",
          "correctness": "wrong"
        },
        {
          "patch": "return StringDescription.toString(m).equalsIgnoreCase(arg.toString());",
          "correctness": "wrong"
        },
        {
          "patch": "return StringDescription.toString(m).equals(((Description) arg).toString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringDescription.toString(m).equalsIgnoreCase(arg.toString());",
          "correctness": "wrong"
        },
        {
          "patch": "return Description.toString(m).equals(arg);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return description.toString().equals(arg.toString());",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringDescription.toDescription(m).equals(arg);",
          "correctness": "uncompilable"
        },
        {
          "patch": "return StringDescription.toDescription(m).equals(arg.toString());",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "<s> public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); </s> Partial newPartial = new Partial(iChronology, newTypes, newValues); </s> iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); } </s> java",
      "output": [
        {
          "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues, fieldType);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Partial newPartial = new Partial(this, newTypes, newValues);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Partial newPartial = new Partial(this, iChronology, newTypes, newValues);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
          "correctness": "wrong"
        },
        {
          "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues, locale);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues, index);",
          "correctness": "uncompilable"
        },
        {
          "patch": "x.Partial newPartial = new Partial(iChronology, newTypes, newValues);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Partial newPartial = new Partial(iChronology, newValues);",
          "correctness": "uncompilable"
        },
        {
          "patch": "Partial newPartial = new Partial(newTypes, newValues);",
          "correctness": "plausible"
        },
        {
          "patch": "(Partial) newPartial;",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "<s> public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: </s> return -val1; </s> case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; } </s> java",
      "output": [
        {
          "patch": "return Long.signum(-val1);",
          "correctness": "wrong"
        },
        {
          "patch": "return -(val1);",
          "correctness": "wrong"
        },
        {
          "patch": "return -(val1 - val2);",
          "correctness": "wrong"
        },
        {
          "patch": "return Long.signum(val1);",
          "correctness": "wrong"
        },
        {
          "patch": "return -longMinusOne;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return -(long) -val1;",
          "correctness": "wrong"
        },
        {
          "patch": "return -(val1 * val2);",
          "correctness": "wrong"
        },
        {
          "patch": "return -val2;",
          "correctness": "wrong"
        },
        {
          "patch": "return -longMinus1;",
          "correctness": "uncompilable"
        },
        {
          "patch": "return -((long) val1);",
          "correctness": "wrong"
        }
      ]
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "<s> public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( </s> instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); </s> int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; } </s> java",
      "output": [
        {
          "patch": "if (iLocale!= null) { instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); } else { instantLocal = instantMillis; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "if (iLocale!= null) { instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); } chrono = selectChronology(chrono);",
          "correctness": "uncompilable"
        },
        {
          "patch": "setDateTime(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
          "correctness": "uncompilable"
        },
        {
          "patch": "instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long parsedOffset = bucket.getOffsetInteger(); chrono = chrono.withOffset(parsedOffset);",
          "correctness": "uncompilable"
        },
        {
          "patch": "long parsedOffset = bucket.getOffsetInteger(); chrono = chrono.withZone(iZone);",
          "correctness": "uncompilable"
        },
        {
          "patch": "setDateTime(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, instantMillis);",
          "correctness": "uncompilable"
        },
        {
          "patch": "setDateTime(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, instantMillisOffset);",
          "correctness": "uncompilable"
        },
        {
          "patch": "setDateTime(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, instant.getChronology());",
          "correctness": "uncompilable"
        },
        {
          "patch": "chrono = selectChronology(chrono);",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "<s> public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } </s> } else if (offsetLocal > 0) { </s> long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; } </s> java",
      "output": [
        {
          "patch": "} else if (offsetLocal >= 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if (offsetLocal > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (instantAdjusted > 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if (offsetLocal > 0)",
          "correctness": "uncompilable"
        },
        {
          "patch": "} if (offsetLocal > 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (instantAdjusted > offsetLocal) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if (offsetLocal > 1) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else if (instantAdjusted >= 0) {",
          "correctness": "plausible"
        },
        {
          "patch": "} else if (offsetLocal <= 0) {",
          "correctness": "wrong"
        },
        {
          "patch": "} else {",
          "correctness": "plausible"
        }
      ]
    }
  }
}