{
  "config": "finetune",
  "data": {
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n</s>    boolean removed = markers.remove(marker);\n</s>    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n}\n",
      "output": [
        {
          "patch": "    boolean removed = markers.remove(marker.getLayer());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker.layer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker.getName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker!= null? marker : layer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker && layer == Layer.FOREGROUND);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker.getId());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker.id);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(new Marker(marker, layer));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(new Marker(marker));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    boolean removed = markers.remove(marker, layer);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n</s>      JsName name = getName(ns.name, false);\n</s>      if (name != null) {\n      refNodes.add(new ClassDefiningFunctionNode(\n          name, n, parent, parent.getParent()));\n      }\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    } else {\n        JsName name = getName(ns.name, false);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (NodeUtil.isObjectLitKey(n)) {\n        JsName name = getName(ns.name, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    }\n    JsName name = getName(ns.name, false);\n    if (name!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        JsName name = getName(ns.name, true);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    }\n    if (ns.name!= null) {\n        JsName name = getName(ns.name, false);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (NodeUtil.isFunctionDeclaration(n)) {\n        JsName name = getName(ns.name, false);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (NodeUtil.isVarDeclaration(n)) {\n        JsName name = getName(ns.name, false);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else {\n        JsName name = getName(ns.name, false);\n    }\n    if (name!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                JsName name = getName(ns.name, false);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        JsName name = getName(ns.name, false);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "@Override\npublic JSType getLeastSupertype(JSType that) {\n</s>  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n</s>  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String property : properties.keySet()) {\n    if (that.toMaybeRecordType().hasProperty(property) &&\n        that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n            getPropertyType(property))) {\n      builder.addProperty(property, getPropertyType(property),\n          getPropertyNode(property));\n    }\n  }\n  return builder.build();\n}\n",
      "output": [
        {
          "patch": "    return super.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "      return super.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "       return super.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return that.toMaybeRecordType().getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return that.toMaybeRecordType().getLeastSupertype(this);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "     return super.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return that.toMaybeRecordType().getLeastSupertype(registry);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "       = super.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return super.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return this.getLeastSupertype(that);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n</s>        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n</s>        wasWhite= false;\n        switch(c) {\n        case '\\'':\n            if(unquote) {\n                if(++i==value.length()) {\n                    return regex;\n                }\n                c= value.charAt(i);\n            }\n            break;\n        case '?':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n        case '\\\\':\n        case '|':\n        case '*':\n        case '+':\n        case '^':\n        case '$':\n        case '.':\n            regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}\n",
      "output": [
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s*.+\");\n        }\n",
          "correctness": "timeout"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s*+\");\n        }\n",
          "correctness": "timeout"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\ssulu+\");\n        }\n",
          "correctness": "timeout"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s*\\+\");\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s*(+\");\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s*\"+\");\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (c!= '\\0') {\n            regex.append(\"String_Node_Str\");\n        }\n",
          "correctness": "timeout"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s '*+\");\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!wasWhite) {\n            wasWhite = true;\n            regex.append(\"\\\\s**+\");\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!wasWhite)\n            continue;\n",
          "correctness": "timeout"
        }
      ]
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n</s>        calendar = (Calendar) calendar.clone();\n</s>        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}\n",
      "output": [
        {
          "patch": "        calendar = (Calendar) calendar.clone(false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.cloneNode();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.cloneInstance();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.clone(true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.cloneRef();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.cloneClone(false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.clone(mLocale);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.clone(getTimeZone());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        Calendar calendar = (Calendar) calendar.clone();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        calendar = (Calendar) calendar.clone(buf);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n</s>        chiSquare += residual * residual / residualsWeights[i];\n</s>    }\n    return chiSquare;\n}\n",
      "output": [
        {
          "patch": "        chiSquare += residual * residual / residualsWeights[i + 1];\n",
          "correctness": "wrong"
        },
        {
          "patch": "        chiSquare += residual * residual / residualsWeights[i - 1];\n",
          "correctness": "wrong"
        },
        {
          "patch": "        chiSquare += residual * residual / residualWeights[i + 1];\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        chiSquare += residual * residual / residualWeights[i - 1];\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        chiSquare += residual * residual.getWeightsWeights[i];\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        chiSquare += (residual * residual / residualsWeights[i]);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        chiSquare += residual * residual.getWeight(i);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        chiSquare += residual * residual / residualsWeights[i].doubleValue();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        chiSquare += residual * residual / residualWeights[i].doubleValue();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        chiSquare += ( residual * residual / residualsWeights[i]);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "public static double distance(int[] p1, int[] p2) {\n</s>  int sum = 0;\n</s>  for (int i = 0; i < p1.length; i++) {\n      final int dp = p1[i] - p2[i];\n      sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n}\n",
      "output": [
        {
          "patch": "    double sum = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int sum = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double sum = 0.0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double sum = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int sum = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    double sum = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "            double sum = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double sum = 1.0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int sum = p1.length;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        double sum = 0;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n</s>    final BigDecimal[] out = new BigDecimal[v.length];\n</s>    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = ZERO;\n        for (int i = 0; i < nCols; i++) {\n            sum = sum.add(data[row][i].multiply(v[i]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}\n",
      "output": [
        {
          "patch": "    final BigDecimal[] out = new BigDecimal[nRows];\n",
          "correctness": "plausible"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(v.length / nRows);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(v.length * nRows);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(nRows + 1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(v.length + nRows);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(v.length + 1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(nRows);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(v.length - nRows);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(v.length);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final BigDecimal[] out = new BigDecimal(nRows + nCols);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n</s>    if (dataset != null) {\n</s>        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}\n",
      "output": [
        {
          "patch": "    if (dataset == null) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (dataset == null || dataset.getRowCount() == 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (dataset!= null && dataset.getRowCount() > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (dataset == null || dataset.getRowCount() <= 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (dataset!= null && dataset.getRowCount() == 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (dataset!= null && dataset.getRowCount()!= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (dataset == null)\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (dataset == null || dataset.getRowCount() < 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (dataset!= null && dataset.getRowCount() <= 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (dataset!= null || dataset.getRowCount() == 0) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n</s>    copy.data = new java.util.ArrayList();\n</s>    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n            try {\n                copy.add(clone);\n            }\n            catch (SeriesException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return copy;\n}\n",
      "output": [
        {
          "patch": "    copy.data = new java.util.LinkedList();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    copy.data = new ArrayList<TimeSeriesDataItem>();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    copy.data = new java.util.ArrayList(end);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    copy.data = new java.util.List();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    copy.data = new java.util.ArrayList<>();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    copy.data = new java.util.List(end);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    copy.data = new ArrayList<>();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    copy.data = new java.util.ArrayList();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    copy.data = new java.util.LinkedArrayList();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    copy.setData(new java.util.ArrayList());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n</s>    return super.equals(obj);\n</s>\n}\n",
      "output": [
        {
          "patch": "    return super.equals(obj) || super.equals(obj);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return super.equals(obj) && super.equals(obj);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return super == obj && super.equals(obj);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return super.equalsIgnoreCase(obj) && super.equalsIgnoreCase(obj);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return super == obj || super.equals(obj);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return super.toString().equals(obj.toString());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return super.equalsIgnoreCase(obj) || super.equalsIgnoreCase(obj);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return super.equals(obj) && this.equals(obj);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return super.equalsIgnoreCase(obj);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return super.getName().equals(obj.getName());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "public Week(Date time, TimeZone zone) {\n</s>    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n</s>}\n",
      "output": [
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, Locale.getDefault());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Zone.getDefault());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone.getDefault());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, null, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, new Locale(TimeZone.getDefault()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, null);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, new Locale(Zone.getDefault()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, null, Locale.getDefault());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n</s>    if (endIndex < 0) {\n</s>        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n}\n",
      "output": [
        {
          "patch": "    if (endIndex < 0 || startIndex < 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 || startIndex == this.data.size()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex <= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 || startIndex == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 || startIndex >= this.data.size()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 || startIndex > this.data.size()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 || endIndex == this.data.size()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 && startIndex < 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 && this.data.size() == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (endIndex < 0 && startIndex == this.data.size()) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "public String generateToolTipFragment(String toolTipText) {\n</s>    return \" title=\\\"\" + toolTipText\n</s>        + \"\\\" alt=\\\"\\\"\";\n}\n",
      "output": [
        {
          "patch": "    return \"String_Node_Str\" + toolTipText;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + toolTipText + \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + escapeHtml(toolTipText) + \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + escapeHtml4(toolTipText) + \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + escapeHTML(toolTipText) + \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + \"String_Node_Str\" + toolTipText;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + StringUtils.escapeHtml(toolTipText) + \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + toolTipText + \"String_Node_Str\" + id;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + toolTipText + \"String_Node_Str\" + alt=\\\"\\\"\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\" + StringUtils.join(toolTipText, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n</s>    PathIterator iterator2 = p1.getPathIterator(null);\n</s>    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}\n",
      "output": [
        {
          "patch": "    PathIterator iterator2 = p2.getPathIterator(null);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    PathIterator iterator2 = p1.getPathIterator(p2);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    PathIterator iterator2 = p1.getPathIterator(null, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    GeneralPath iterator2 = p2.getGeneralPathIterator(null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    PathIterator iterator2 = p1.getPathIterator(p2.getPathIterator(null));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    PathIterator iterator2 = p1.getPathIterator(p2.getPathIterator());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    List<GeneralPath> paths = p2.getPathIterator(null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    PathIterator iterator2 = p1.getPathIterator(p2.getWindingRule());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    List<GeneralPath> paths2 = p2.getPathIterator(null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final PathIterator iterator2 = p2.getPathIterator(null);\n",
          "correctness": "plausible"
        }
      ]
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n</s>    this.dataset = dataset;\n</s>    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}\n",
      "output": [
        {
          "patch": "    this.dataset = dataset.getCategoryDataset();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset = dataset == null? null : dataset;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    this.dataset = new CategoryDataset(dataset);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset = dataset.getParent();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset = dataset!= null? dataset : null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    this.dataDataset = dataset;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset = dataset.getCategory();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset = dataset.clone();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset.setCategoryDataset(dataset);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.dataset2 = dataset;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "public Object clone() throws CloneNotSupportedException {\n</s>    Object clone = createCopy(0, getItemCount() - 1);\n</s>    return clone;\n}\n",
      "output": [
        {
          "patch": "    Object clone = createCopy(0, getItemCount());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Object clone = createCopy();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final Object clone = createCopy(0, getItemCount() - 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Object clone = createCopy(0, getItemCount() - 2);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Object clone = createCopyInternal(0, getItemCount() - 1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object clone = createCopy(0, getItemCount() - 1, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object clone = createCopy(0, getItemCount() - 1, null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object clone = createCopy(0, getItemCount() - 1, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object clone = null;\n    clone = createCopy(0, getItemCount());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Object clone = createCopy(getItemCount() - 1);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n</s>    super(paint, stroke, paint, stroke, alpha);\n</s>    this.value = value;\n}\n",
      "output": [
        {
          "patch": "    super(paint, stroke, paint, alpha, outlinePaint);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke, paint, margin, alpha);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke.clone(), paint, stroke, alpha);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, outlinePaint, stroke, alpha);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke, paint, lineWidth, stroke, alpha);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke, paint, stroke, alpha, outlinePaint);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke, paint, alpha, paintPaint);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, lineWidth, paint, lineWidth, alpha);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke, paint, stroke, alpha, scale);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    super(paint, stroke, paint, alpha, true);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n</s>    int g = (int) ((value - this.lowerBound) / (this.upperBound \n</s>            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}\n",
      "output": [
        {
          "patch": "    int g = (int) ((v - this.lowerBound) / (this.upperBound \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) ((value - this.lowerBound) / (this.upperBound \n + 1)));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) (v - this.lowerBound) / (this.upperBound \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) ((value - this.lowerBound) / (this.upperBound \n - 1)));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) (v - this.lowerBound) / (this.upperBound \n);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) ((v - this.lowerBound) / (this.upperBound \n)) * 255.0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) ((value - this.lowerBound) / (this.upperBound \n - this.lowerBound));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) ((value - this.lowerBound) / v);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) ((value - this.lowerBound) / (this.upperBound \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int g = (int) Math.ceil((value - this.lowerBound) / (this.upperBound \n \n));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n</s>        StringBuffer buff = new StringBuffer();\n</s>\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}\n",
      "output": [
        {
          "patch": "        StringBuilder buff = new StringBuilder();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        final StringBuilder buff = new StringBuilder();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        buff.setLength(requiredOptions.size());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        String buff = \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        buff.setLength(0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        buff.append(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        final StringBuffer buff = new StringBuffer();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        sb.append(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        List<String> buff = new ArrayList<>();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (iter.hasNext())\n            return;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n</s>        pos = findWrapPos(text, width, nextLineTabStop);\n</s>\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n",
      "output": [
        {
          "patch": "        pos = findWrapPos(text, pos, nextLineTabStop);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        pos = findWrapPos(text, pos + 1, nextLineTabStop);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        pos = findWrapPos(text, offset, nextLineTabStop);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        pos = findWrapPos(text, width - 1, nextLineTabStop);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        pos = findWrapPos(text, width + 1, nextLineTabStop);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        pos = findWrapPos(text, 0, nextLineTabStop);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        pos = findWrapPos(text, width, nextLineTabStop, pos);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        pos = findWrapPos(text, pos);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        pos = findWrapPos(text, width, nextLineTabStop + 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        pos = findWrapPos(text, pos - 1, nextLineTabStop);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n</s>    if (option.hasArg() && (option.getArgName() != null))\n</s>    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n",
      "output": [
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null || option.getArgName()!= null))\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null || option.getArgName() == null))\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (option.hasArg() && option.getArgName()!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName() == null || option.getArgName()!= null))\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName() == null || option.getArgName() == null))\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null) &&!buff.isEmpty())\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null) && buff.length() > 0)\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null &&!buff.isEmpty()))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (option.hasArg() && (option.getArgName()!= null && option.getArgOpt()!= null))\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n</s>        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n                                        \"- no room for the description\");\n</s>    }\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n",
      "output": [
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + width + \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new IllegalArgumentException(\"String_Node_Str\" + width + \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + width);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + width, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + \"String_Node_Str\" + width);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new RuntimeException(\"String_Node_Str\" + width + \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + width + \"String_Node_Str\" + urlString);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new IllegalStateException(\"String_Node_Str\" + length + \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n</s>        nextLineTabStop = width - 1;\n</s>    }\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n",
      "output": [
        {
          "patch": "        nextLineTabStop = width;\n",
          "correctness": "timeout"
        },
        {
          "patch": "        nextLineTabStop = width - 2;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        nextLineTabStop = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        nextLineTabStop = width - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        nextLineTabStop = -1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        nextLineTabStop = pos;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        nextLineTabStop = width + 1;\n",
          "correctness": "timeout"
        },
        {
          "patch": "        nextLineTabStop = lineWidth - 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        nextLineTabStop = pos - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        nextLineTabStop = maxWidth - 1;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n</s>                break;\n</s>            }\n            cmd.addOption(opt);\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "                return false;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                cmd.addOption(opt);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                continue;\n",
          "correctness": "plausible"
        },
        {
          "patch": "                throw new RuntimeException(\"String_Node_Str\" + option);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                throw new RuntimeException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                return;\n",
          "correctness": "wrong"
        },
        {
          "patch": "                throw new IllegalStateException(\"String_Node_Str\" + option);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                throw new IllegalStateException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                System.out.println(\"String_Node_Str\" + option);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                if (opt!= null)\n                    opt.addValueForProcessing(value);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n</s>    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n           && (c != '\\n') && (c != '\\r'))\n    {\n        ++pos;\n    }        \n</s>    return pos == text.length() ? -1 : pos;\n}\n",
      "output": [
        {
          "patch": "    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos <= startPos) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')) ;        ++;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r'));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r'))');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos <= text.length()) && ((c = text.charAt(pos)))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    while ((pos <= text.length()) && (((c = text.charAt(pos))!='')\n           && (c!= '\\n') && (c!= '\\r')));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n</s>        return null;\n</s>    }\n}\n",
      "output": [
        {
          "patch": "        throw new ParseException(\"String_Node_Str\");\n",
          "correctness": "plausible"
        },
        {
          "patch": "        return (T) createString(str);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new IllegalArgumentException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return (T) createObject(str);\n",
          "correctness": "plausible"
        },
        {
          "patch": "        return (T) createURI(str);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new RuntimeException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return (T) createText(str);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return (T) createURL(str);\n",
          "correctness": "plausible"
        },
        {
          "patch": "        return (T) createObject(str);\n",
          "correctness": "plausible"
        },
        {
          "patch": "        return (T) createResource(str);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n</s>\n</s>  Node function = fnScope.getRootNode();\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    return;\n  }\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      Var var = fnScope.getVar(lastArg.getString());\n      if (!referenced.contains(var)) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n      } else {\n        break;\n      }\n    }\n  } else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}\n",
      "output": [
        {
          "patch": "        removeUnreferencedFunctionArgs(fnScope, referenced);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        removeUnreferencedFunctionArgs(fnScope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        removeUnreferencedFunctionArgs(fnScope, referenced);\n    compiler.reportCodeChange();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    removeUnreferencedFunctionArgs(fnScope, referenced);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    removeUnreferencedFunctionArgs(fnScope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        removeUnreferencedFunctionArgs(fnScope);\n    compiler.reportCodeChange();\n",
          "correctness": "wrong"
        },
        {
          "patch": "            removeUnreferencedFunctionArgs(fnScope, referenced);\n        compiler.reportCodeChange();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                removeUnreferencedFunctionArgs(fnScope, referenced);\n            compiler.reportCodeChange();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                removeUnreferencedFunctionArgs(fnScope);\n                compiler.reportCodeChange();\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                removeUnreferencedFunctionArgs(fnScope, referenced);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n</s>\n</s>      \n      String propName = parent.getLastChild().getString();\n      if (!validProperties.contains(propName)) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n          validProperties.add(propName);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      continue;\n    }\n    if (!val.isObjectLit()) {\n      return false;\n    }\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        return false;\n      }\n      validProperties.add(child.getString());\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    ret = true;\n  }\n  return ret;\n}\n",
      "output": [
        {
          "patch": "    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent,",
          "correctness": "uncompilable"
        },
        {
          "patch": "    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent,",
          "correctness": "uncompilable"
        },
        {
          "patch": "        validProperties.add(parent.getString());\n    }\n    for (Node child : refs) {\n        Node child = child.getNext();\n        if (child.isGetterDef() || child.isSetterDef()) {\n            validProperties.add(child.getString());\n        } else {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.",
          "correctness": "uncompilable"
        },
        {
          "patch": "    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        } else {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    if (parent.isGetProp())",
          "correctness": "uncompilable"
        },
        {
          "patch": "        validProperties.add(parent.getString());\n    }\n    for (Node child : refs) {\n        Node child = child.getNext();\n        if (child.isGetterDef() || child.isSetterDef()) {\n            validProperties.add(propName);\n        } else {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString",
          "correctness": "uncompilable"
        },
        {
          "patch": "    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent,",
          "correctness": "uncompilable"
        },
        {
          "patch": "    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent,",
          "correctness": "uncompilable"
        },
        {
          "patch": "        validProperties.add(parent.getString());\n    }\n    for (Node child : refs) {\n        if (child.isGetterDef() || child.isSetterDef()) {\n            validProperties.add(child.getString());\n        } else {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (!NodeUtil.isVarOrSimpleAssignLhs(parent,",
          "correctness": "uncompilable"
        },
        {
          "patch": "        validProperties.add(ref.getString());\n    }\n    for (Node child : refs) {\n        Node child = child.getNext();\n        if (child.isGetterDef() || child.isSetterDef()) {\n            validProperties.add(child.getString());\n        } else {\n            validProperties.add(child.getString());\n        }\n    }\n    for (Node child : refs) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(child.",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n</s>    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n</s>  } else {\n    return mayBeStringHelper(n);\n  }\n}\n",
      "output": [
        {
          "patch": "    return allResultsMatch(n, MAY_BE_STRING_PREDICATE, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch(n, MAY_BE_STRING_PREDICATE, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch(n, MAY_BE_STRING_PREDICATE, null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch(n, SAME_BE_STRING_PREDICATE);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatchIgnoreCase(n, MAY_BE_STRING_PREDICATE);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch(node, MAY_BE_STRING_PREDICATE);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch(n, MAY_BE_STRING_PREDICATE, 0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch(n, MAY_LE_STRING_PREDICATE);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return allResultsMatch((Node) n, MAY_BE_STRING_PREDICATE);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n</s>  } else if (n.getJSType() != null && parent.isAssign()) {\n    return;\n</s>  } else if (validator.expectNotNullOrUndefined(t, n, childType,\n      \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n    checkPropertyAccess(childType, property.getString(), t, n);\n  }\n  ensureTyped(t, n);\n}\n",
      "output": [
        {
          "patch": "    } else if (n.getJSType()!= null &&!parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (n.getJSType()!= null &&!parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.', \"dict\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (n.getJSType()!= null) {\n        if (parent.isAssign()) {\n            return;\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (n.getJSType()!= null &&!parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.', \"Dict\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (n.getJSType()!= null && parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (n.getJSType()!= null && parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.', \"dict\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (n.getJSType()!= null &&!parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.', \"String\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (n.getJSType()!= null) {\n        if (parent.isAssign()) {\n            return;\n        } else if (parent.isAssign()) {\n            return;\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (n.getJSType() == null && parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n",
          "correctness": "plausible"
        },
        {
          "patch": "    } else if (n.getJSType()!= null &&!parent.isAssign()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"Dict\");\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n</s>\n</s>  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n",
      "output": [
        {
          "patch": "    return applySideEffects(n);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return applySideEffects(n);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (n.isNew()) {\n        return true;\n    }\n",
          "correctness": "wrong"
        },
        {
          "patch": "                return NodeUtil.functionCallHasSideEffects(n);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return apply(n.getFirstChild());\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        Node c = n.getFirstChild();\n        c = c.getNext();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Node c = n.getFirstChild();\n    c = c.getNext();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return NodeUtil.isEnteringNewCfgNode(n);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return applyInsideSideEffects(n);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return NodeUtil.isEnteringNewCfgNode(n) && apply(n);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n</s>    if (value != null) {\n</s>      Node addition = IR.add(\n          IR.string(\"\").srcref(callTarget),\n          value.detachFromParent());\n      n.getParent().replaceChild(n, addition);\n      reportCodeChange();\n      return addition;\n    }\n  }\n  return n;\n}\n",
      "output": [
        {
          "patch": "    if (value!= null &&!callTarget.isName() && value.detachFromParent()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (value!= null && value.getParent()!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (value!= null &&!value.isNull()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (value!= null &&!value.isAnonymous()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (value!= null &&!callTarget.isName() &&!callTarget.isName()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (value!= null &&!callTarget.isName()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (value!= null && callTarget.getString().equals(\"String\")) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (value!= null &&!callTarget.isName() && value!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (value!= null &&!value.isConstant()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (value!= null && value.detachFromParent()!= null) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n</s>\n</s>  \n  if (constraintObj.isRecordType()) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!isPropertyTypeDeclared(prop)) {\n        JSType typeToInfer = propType;\n        if (!hasProperty(prop)) {\n          typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(propType);\n        }\n        defineInferredProperty(prop, typeToInfer, null);\n      }\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                               .getLeastSupertype(propType);\n                }\n                defineInferredProperty(prop, typeToInfer",
          "correctness": "uncompilable"
        },
        {
          "patch": "    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                               .getLeastSupertype(propType);\n                }\n                defineInferredProperty(prop, typeToInfer,",
          "correctness": "uncompilable"
        },
        {
          "patch": "    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                                   .getLeastSupertype(propType);\n                }\n                defineInferredProperty(prop, typeToInfer",
          "correctness": "uncompilable"
        },
        {
          "patch": "    JSType typeToInfer = null;\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                               .getLeastSupertype(propType);\n                }\n                defineIn",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (constraintObj == null) {\n        return;\n    }\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                                   .getLeastSupertype(propType",
          "correctness": "uncompilable"
        },
        {
          "patch": "    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n            }\n            defineInferredProperty(prop, typeToInfer, null);\n        }\n    }\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if",
          "correctness": "uncompilable"
        },
        {
          "patch": "    JSType typeToInfer = null;\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                               .getLeastSupertype(propType);\n            }\n            defineInferredProperty(prop, typeToInfer, null);\n        }\n    }\n   ",
          "correctness": "uncompilable"
        },
        {
          "patch": "    for (String prop : constraintObj.getOwnNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                               .getLeastSupertype(propType);\n                }\n                defineInferredProperty(prop, typeToInfer",
          "correctness": "uncompilable"
        },
        {
          "patch": "    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                               .getLeastSupertype(propType);\n                    defineInferredProperty(prop, typeToInfer, null);",
          "correctness": "uncompilable"
        },
        {
          "patch": "    JSType typeToInfer = null;\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n            typeToInfer = propType;\n            if (!hasProperty(prop)) {\n                typeToInfer = propType;\n                if (!hasProperty(prop)) {\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                                   .getLeastSupertype(propType);\n                }\n                defineIn",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n</s>  if (constraintObj != null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType != null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n</s>  }\n}\n",
      "output": [
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (constraintObj!= null) {\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n        if (objType!= null) {\n            for (String prop : constraintObj.getOwnPropertyNames()) {\n                JSType propType = constraintObj.getPropertyType(prop);\n                if (!objType.isPropertyTypeDeclared(prop)) {\n                    JSType typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (constraintObj!= null && constraintObj.isRecordType()) {\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n        if (objType!= null) {\n            for (String prop : constraintObj.getOwnPropertyNames()) {\n                JSType propType = constraintObj.getPropertyType(prop);\n                if (!objType.isPropertyTypeDeclared(prop)) {\n                    JSType typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null && constraintObj.isRecordType()) {\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n        if (objType!= null) {\n            for (String prop : constraintObj.getOwnPropertyNames()) {\n                JSType propType = constraintObj.getPropertyType(prop);\n                if (!objType.isPropertyTypeDeclared(prop)) {\n                    JSType typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n        if (objType!= null) {\n            for (String prop : constraintObj.getOwnPropertyNames()) {\n                JSType propType = constraintObj.getPropertyType(prop);\n                if (!objType.isPropertyTypeDeclared(prop)) {\n                    JSType typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            if (!objType.isPropertyTypeDeclared(prop)) {\n                JSType typeToInfer = propType;\n                if (!objType.hasProperty(prop)) {\n                    typeToInfer = objType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =\n                        getNativeType",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            if (!objType.isPropertyTypeDeclared(prop)) {\n                typeToInfer = propType;\n                if (!objType.hasProperty(prop)) {\n                    typeToInfer = objType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =\n                        getNativeType(",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            if (!objType.isPropertyTypeDeclared(prop)) {\n                typeToInfer = propType;\n                if (!objType.hasProperty(prop)) {\n                    typeToInfer =\n                    getNativeType(VOID_TYPE).getLeastSupertype(propType);\n                }\n                objType.defineInferred",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (constraintObj!= null) {\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n        if (objType!= null) {\n            for (String prop : constraintObj.getOwnPropertyNames()) {\n                JSType propType = constraintObj.getPropertyType(prop);\n                if (!objType.isPropertyTypeDeclared(prop)) {\n                    JSType typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =\n                        getNativeType(VOID_TYPE).getLeastSupertype(propType",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            if (!objType.isPropertyTypeDeclared(prop)) {\n                JSType typeToInfer = propType;\n                if (!objType.hasProperty(prop)) {\n                    typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =\n                        getNativeType",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            if (!objType.isPropertyTypeDeclared(prop)) {\n                typeToInfer = propType;\n                if (!objType.hasProperty(prop)) {\n                    typeToInfer = propType;\n                    if (!objType.hasProperty(prop)) {\n                        typeToInfer =\n                        getNativeType(",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n</s>    }\n</s>  }\n  return canMoveAggressively(value) ||\n      canMoveModerately(initialization, reference);\n}\n",
      "output": [
        {
          "patch": "    } else\n        return canMoveAggressively(value);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value) || canMoveModerately(reference, reference);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value) || canMoveModerately(value, reference);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value) || canMoveModerately(value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value, reference);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else {\n        return canMoveAggressively(value);\n    }\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value) || canMoveModerately(reference);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else\n        return canMoveAggressively(value) || canMoveModerately(reference, value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else\n        return false;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n</s>  if (x < 0 && prev == '-') {\n</s>    add(\" \");\n  }\n  if ((long) x == x && !negativeZero) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}\n",
      "output": [
        {
          "patch": "    if (x < 0 && prev == '-' &&!negativeZero) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (x < 0 || prev == '-') {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (x < 0 && (prev == '-' || prev == '-'))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (x < 0 && prev == '-' || prev == '-') {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (x < 0 || (prev == '-' || prev == '-'))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (x < 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (x < 0 &&!\"String_Node_Str\".equals(prev)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (x < 0 && prev == '-' &&! negativeZero) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (x < 0 && (prev == '-' || prev == '-')) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (x < 0 && (prev == '-' || prev == '_'))) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n</s>  return len > 0;\n</s>}\n",
      "output": [
        {
          "patch": "    return len >= 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len > 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len < 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len == 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len < 0 || len > 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len > -1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len <= 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len == 0 || len > 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len > 0 || len > 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return len!= 0 && len > 0;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "private static boolean isReduceableFunctionExpression(Node n) {\n</s>  return NodeUtil.isFunctionExpression(n);\n</s>}\n",
      "output": [
        {
          "patch": "    return NodeUtil.isFunctionExpression(n, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return NodeUtil.isFunctionExpression(n, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return NodeUtil.isFunctionExpression(n);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return NodeUtil.isFunctionExpression(n);\n            }\n        return false;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return NodeUtil.isFunctionExpression(n.getSourceName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return NodeUtil.isFunctionExpression(n);\n        }\n    return false;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return NodeUtil.isFunctionExpression(n.getParent());\n",
          "correctness": "wrong"
        },
        {
          "patch": "                return NodeUtil.isFunctionExpression(n, true);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                        return NodeUtil.isFunctionExpression(n);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return NodeUtil.isFunctionExpression(n.getType());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n</s>        if (target != null) {\n</s>          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n",
      "output": [
        {
          "patch": "        if (target!= null && callee.getType() == Token.GETPROP) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (target!= null && target.getType() == Token.GETPROP) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (target!= null &&!target.isDisposed()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (target!= null && target.getNodeName().equals(qualifiedName)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (target!= null &&!target.isAnonymous()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (target!= null && callee.getType()!= Token.GETPROP) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (target!= null && target.getType()!= Token.GETPROP) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (target!= null &&!target.isEmpty()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (target!= null &&!target.isNull()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (target!= null && target.getParent()!= null) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n</s>  if (options.checkGlobalThisLevel.isOn()) {\n</s>    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n  ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n  if (!options.checkSymbols &&\n      !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n    composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n  this.warningsGuard = composedGuards;\n}\n",
      "output": [
        {
          "patch": "    if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (!options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (options.checkGlobalThisLevel == null || options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "<s>    if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "         if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (options.getCheckGlobalThisLevel()!= null && options.checkGlobalThisLevel.isOn()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (options.checkGlobalThisLevel.isOn() && options.getWarningLevel()!= CheckLevel.OFF) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                 if (options.checkGlobalThisLevel!= null && options.checkGlobalThisLevel.isOn()) {\n                     }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n</s>        && 0 <= charno && charno < sourceExcerpt.length()) {\n</s>      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}\n",
      "output": [
        {
          "patch": "        if (charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (0 <= charno && charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (charno > 0 && charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (charno >= 0 && charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (sourceExcerpt!= null && 0 <= charno && charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (charno <= sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (sourceExcerpt.length() > 0 && charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        b.append(\"String_Node_Str\");\n        if (charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (charno!= 0 && charno < sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (charno >= sourceExcerpt.length()) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n</s>      ) {\n</s>    \n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
      "output": [
        {
          "patch": "                    if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getFirstChild().getType() == Token.GETPROP) {\n                        return true;\n                    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getFirstChild().getType() == Token.GETPROP) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getFirstChild().getType() == Token.GETPROP) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (n.getFirstChild()!= null) {\n        return NodeUtil.isVarOrSimpleAssignLhs(n, assign);\n    } else if (n.getFirstChild()!= null && n.getFirstChild().getType() == Token.GETPROP) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)) {\n                        return true;\n                    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                if (n.getFirstChild().getType() == Token.STRING) {\n                    return true;\n                }\n                return false;\n            } else if (n.getFirstChild().getType() == Token.GETPROP) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    if (n.getFirstChild().getType() == Token.STRING) {\n                        return true;\n                    } else {\n                        return NodeUtil.isVarOrSimpleAssignLhs(n, assign);\n                    }\n                }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getFirstChild().getType() == Token.GETPROP) {\n                    return true;\n                }\n            } else {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getFirstChild().getType() == Token.GETPROP) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return true;\n            } else if (n.getFirstChild()!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getFirstChild().getType() == Token.GETPROP) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n</s>              jsDocParameter.getJSType(), true);\n</s>          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDoc",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else {\n        throw",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null || jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else {\n        throw new RuntimeException(\"String_Node_Str\");\n    }\n    if (jsDocParameter.getJSType() == null) {\n       ",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    }\n    if (js",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null || jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else {\n        throw new RuntimeException(\"String_Node_Str\");\n    }\n    if (jsDocParameter",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter = jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter = jsDocParameter.getFirstChild();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter = jsDocParameter.getFirstChild();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter = jsDocParameter.getFirstChild();",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else if (jsDocParameter.getJSType() == null) {\n        jsDocParameter.getJSType();\n    } else {\n        jsDocParameter.getJSType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType() == null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDocParameter.getJSType()!= null) {\n        throw new RuntimeException(\"String_Node_Str\");\n    } else if (jsDoc",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "public final boolean isEmptyType() {\n</s>  return isNoType() || isNoObjectType() || isNoResolvedType();\n</s>}\n",
      "output": [
        {
          "patch": "    return isNoType() || isNoObjectType() || isResolvedType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return isNoType() || isNoObjectType();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return isNoType() || isNoObjectType() || isNoResolvedType();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return isNoType() || isNoObjectType() || isResolvedType() || isNoType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return isNoType() || isNoObjectType() || isResolvedType();\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return isNoType() || isNoObjectType() || isNoResolvedType() || isEmptyType();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return isNoType() || isNoObjectType() || isResolvedType() || isEmptyType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return isNoType() || isNoObjectType() || isNoResolvedType();\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return isNoType() || isNoObjectType() || isResolvedType() || isResolvedType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return isNoType() || isNoObjectType() || isNoResolvedType();\n            }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n</s>  String param = params.getParameter(0);\n</s>\n  if (param == null) {\n    setter.addValue(true);\n    return 0;\n  } else {\n    String lowerParam = param.toLowerCase();\n    if (TRUES.contains(lowerParam)) {\n      setter.addValue(true);\n    } else if (FALSES.contains(lowerParam)) {\n      setter.addValue(false);\n    } else {\n      setter.addValue(true);\n      return 0;\n    }\n    return 1;\n  }\n}\n",
      "output": [
        {
          "patch": "    String param = params.getParameter(1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    String param = params.getParameter(0).toLowerCase();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    String param = params.getParameter(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String param = params.getParameter(0);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            String param = params.getParameter(1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            String param = params.getParameter(0);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    String param = params.getParameter(0).trim();\n",
          "correctness": "wrong"
        },
        {
          "patch": "            String param = params.getParameter(0).toLowerCase();\n",
          "correctness": "wrong"
        },
        {
          "patch": "             String param = params.getParameter(1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            String param = params.getParameter(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n</s>      return true;\n</s>    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n",
      "output": [
        {
          "patch": "    case Token.NEW:\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        return locals.apply(value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        return newNode(value, locals);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        return false;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        return newNode(value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        returnevaluated.apply(value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return callHasLocalResult(value) || isToStringMethodCall(value);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    case Token.NEW:\n        return true;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        returnlocals.apply(value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    case Token.NEW:\n        return functionHasLocalResult(value);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n</s>      int indexOfDot = namespace.indexOf('.');\n</s>      if (indexOfDot == -1) {\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}\n",
      "output": [
        {
          "patch": "        int indexOfDot = namespace.indexOf('.');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int indexOfDot = namespace.indexOf('.');\n",
          "correctness": "wrong"
        },
        {
          "patch": "                int indexOfDot = namespace.indexOf('.');\n",
          "correctness": "wrong"
        },
        {
          "patch": "            int indexOfDot = namespace.indexOf('.');\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    int indexOfDot = namespace.indexOf('.', -1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            int indexOfDot = namespace.indexOf('.', -1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int indexOfDot = namespace.indexOf('.', -1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int indexOfDot = providedNames.get(namespace.substring(0, indexOfDot));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    int indexOfDot = namespace.indexOf('.');\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int indexOfDot = providedNames.get(namespace.substring(0, indexOfDot);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n</s>        result = lvalInt >>> rvalInt;\n</s>        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Node.tokenToName(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n",
      "output": [
        {
          "patch": "        result = (lvalInt >>> rvalInt);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (int) (lvalInt >>> rvalInt);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (long) lvalInt >>> rvalInt;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (long) (lvalInt >>> rvalInt);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (lvalInt >>> rvalInt) & 0xFF;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = lvalInt >>> rvalInt;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (int) lvalInt >>> rvalInt;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (double) (lvalInt >>> rvalInt);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (lvalInt >>> rvalInt) & 0xff;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        result = (lvalInt >>> rvalInt) >>> lval;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n</s>  if (result != null) {\n</s>    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}\n",
      "output": [
        {
          "patch": "    if (result!= null &&!this.isObject() && that.isObject()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null &&!this.isObject() &&!that.isObject()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null &&!(result instanceof JSType)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null &&!(result instanceof UnionType)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null && this.isObject() && that.isObject()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null &&!this.isObject()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null &&!this.isObject() ||!that.isObject()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "     if (result!= null &&!this.isObject() && that.isObject()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null && other!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "<s>    if (result!= null &&!this.isObject() && that.isObject()) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "private Node parseContextTypeExpression(JsDocToken token) {\n</s>        return parseTypeName(token);\n</s>}\n",
      "output": [
        {
          "patch": "        return parseContextTypeExpression(token);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return parseTypeName(token.getSourceName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return parseTypeExpression(token.getSourceName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return parseTypeName(token, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return parseTypeName(token, contextType);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return parseIdentifier(token);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return TokenUtil.parseTypeName(token);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        JSType type = parseTypeName(token);\n        return type;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return parseTypeName(token, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return parseTypeName(token.getSourceName(), token.getType());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "@Override\nprotected JSType caseTopType(JSType topType) {\n</s>  return topType;\n</s>}\n",
      "output": [
        {
          "patch": "    return topType.getJSType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return topType;\n            }\n        return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (JSType) topType;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return topType.asJSType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return topType.asType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return topType;\n        }\n    return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return topType.toJSType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return topType.makeJSType();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return topType;\n            }\n            return null;\n       ",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return topType.defaultType();\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n</s>    if (provided != null) {\n</s>      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    if (provided!= null && provided.explicitModule!= providedModule) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (provided!= null &&!provided.isExplicitlyProvided()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (provided.explicitModule!= providedModule) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (provided!= null && provided.explicitModule == providedModule) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (!provided.isExplicitlyProvided()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (provided.explicitModule!= providedModule && provided!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (provided == null ||!provided.isExplicitlyProvided()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (provided == null || provided.explicitModule!= providedModule) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (provided!= null &&provided.explicitModule!= providedModule) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (provided!= null &&! provided.isExplicitlyProvided()) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n</s>    } else {\n</s>      \n      recordDepScope(recordNode, ns);\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (!parent.isFor() &&!NodeUtil.isForIn(parent)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForIn(parent) && parent.getFirstChild().getNext()!= n) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForInIn(parent)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForIn(parent) || parent.getFirstChild().getNext()!= n) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (n.isFor() &&!NodeUtil.isForIn(parent)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForIn(parent) &&!NodeUtil.isForIn(parent)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForIn(parent) ||!NodeUtil.isForIn(parent)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (!parent.isFor() &&!NodeUtil.isForIn(parent) && parent.getFirstChild().getNext()!= n) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (parent.isFor() &&!NodeUtil.isForIn(parent) &&!NodeUtil.isForInIn(parent)) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {\n</s>\n</s>    \n    String name = child.getString();\n    T type = typeSystem.getType(getScope(), n, name);\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(child,\n                               processProperty(t, prop, type, null))) {\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(JSError.make(\n            t.getSourceName(), child, propertiesToErrorFor.get(name),\n            Warnings.INVALIDATION, name,\n            (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n      }\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "                String name = child.getString();\n                T type = typeSystem.getType(getScope(), n, name);\n                Property prop = getProperty(name);\n                if (!prop.scheduleRenaming(child,                               processProperty(t, prop, type, null))) {\n                    compiler.report(JSError.make(\n                    t.getSourceName(), child, prop, type, null));\n                }\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                String name = child.getString();\n                T type = typeSystem.getType(getScope(), n, name);\n                Property prop = getProperty(name);\n                if (prop!= null) {\n                    compiler.report(JSError.make(\n                    t.getSourceName(), child, prop, type, null));\n                }\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                String name = child.getString();\n                T type = typeSystem.getType(getScope(), n, name);\n                Property prop = getProperty(name);\n                if (prop!= null) {\n                    compiler.report(JSError.make(\n                    t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, null));\n                }\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    String name = child.getString();\n                    T type = typeSystem.getType(getScope(), n, name);\n                    Property prop = getProperty(name);\n                    if (!prop.scheduleRenaming(child,                               processProperty(t, prop, type, null))) {\n                        compiler.report(JSError.make(\n                            t.getSourceName(), child, prop, type, null));\n                    }\n                }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    String name = child.getString();\n                    T type = typeSystem.getType(getScope(), n, name);\n                    Property prop = getProperty(name);\n                    if (!prop.scheduleRenaming(child,                               processProperty(t, prop, type, null))) {\n                        compiler.report(JSError.make(\n                        t.getSourceName(), child, prop, type, null));\n                    }\n                }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,                               processProperty(t, prop, type, null))) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, prop, type, null));\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String name = child.getString();\n    T type = typeSystem.getType(getScope(), n, name);\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(child,                               processProperty(t, prop, type, null))) {\n        compiler.report(JSError.make(\n            t.getSourceName(), child, prop, type, null));\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    Property prop = getProperty(child);\n                    if (prop == null) {\n                        compiler.report(JSError.make(t.getSourceName(), child, prop.getType(), null));\n                    } else {\n                        compiler.report(JSError.make(t.getSourceName(), child, prop.getType(), null));\n                    }\n                }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    Property prop = getProperty(child);\n                    if (prop == null) {\n                        compiler.report(JSError.make(\n                            t.getSourceName(), child, prop.getType(), null));\n                    } else {\n                        compiler.report(JSError.make(\n                            t.getSourceName(), child, prop.getType(), null));\n                    }\n                }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,                               processProperty(t, prop, type, null))) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, prop, type, null));\n        }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n</s>      break;\n</s>    } else if (block.isLoop) {\n      return false;\n    }\n  }\n  return true;\n}\n",
      "output": [
        {
          "patch": "    } else if (block.isLoop) {\n        return false;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (block.isLoop) {\n        return true;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (!block.isLoop) {\n        return false;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (block.isLoop) {\n        break;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (block.isFunction) {\n        return true;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (block.isFunction) {\n        return false;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (block.isFunction) {\n        break;\n",
          "correctness": "wrong"
        },
        {
          "patch": "                return true;\n            } else {\n                break;\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    } else if (block.isLoop) {\n        continue;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (!block.isFunction) {\n        return false;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "private void handleBlockComment(Comment comment) {\n</s>  if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n</s>    errorReporter.warning(\n        SUSPICIOUS_COMMENT_WARNING,\n        sourceName,\n        comment.getLineno(), \"\", 0);\n  }\n}\n",
      "output": [
        {
          "patch": "    if (comment.getValue()!= null && (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null && (comment.getValue().indexOf(\"/*@\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue().indexOf(\"/*@\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null && comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null && comment.getValue().indexOf(\"/*@\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null && (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @))!= -1) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (comment.getValue()!= null || comment.getValue().indexOf(\"/*@\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null || comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null && (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n *@\")!= -1)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (comment.getValue()!= null && (comment.getValue().indexOf(\"/*@\")!= -1 || comment.getValue().indexOf(\"\\n * @))!= -1) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n</s>    if (fnType != null) {\n</s>      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n",
      "output": [
        {
          "patch": "    if (fnType!= null && fnType.getInstanceType()!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fnType!= Types.ANY) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (fnType.isConstructor() || fnType.isUnknownType()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fnType!= null && fnType.isConstructor()) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (fnType!= null && fnType.isParameterList()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (fnType!= null && fnType.getInstanceType() == null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fnType.getInstanceType()!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fnType!= null && fnType.isSynthetic()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (fnType!= null && fnType.isType()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (fnType!= null && fnType.isResolved()) {\n",
          "correctness": "plausible"
        }
      ]
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n</s>\n</s>  if (!NodeUtil.isGet(first)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}\n",
      "output": [
        {
          "patch": "    n.putBooleanProp(Node.FREE_CALL, true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (NodeUtil.isGet(first))\n        n.putBooleanProp(Node.FREE_CALL, true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    n.putBooleanProp(Node.FREE_CALL, true);\n     Node first = n.getFirstChild();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (NodeUtil.isGet(first))\n            n.putBooleanProp(Node.FREE_CALL, true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    n.putBooleanProp(Node.FREE_CALL, true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (NodeUtil.isGet(first))\n        first.putBooleanProp(Node.FREE_CALL, true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    n.putBooleanProp(Node.FREE_CALL, true);\n     Node last = n.getLastChild();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (!NodeUtil.isGet(first))\n        n.putBooleanProp(Node.FREE_CALL, true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    n.putBooleanProp(Node.FREE_CALL, true);\n     Node first = first.getChild();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    n.putBooleanProp(Node.FREE_CALL, true);\n     Node first = n.getLastChild();\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n</s>    if (name.globalSets == 1 && name.localSets == 0 &&\n</s>        name.aliasingGets > 0) {\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      workList.addAll(name.props);\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets == 0 && name.props!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets == 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 1 && name.aliasingGets == 0 && name.props!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets == 0 && name.props == null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0 &&!name.aliasingGets.isEmpty()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 1) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0 && name.props!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name.globalSets == 1 && name.localSets == 1 && name.aliasingGets == 0 && name.props == null) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n</s>  return result;\n</s>}\n",
      "output": [
        {
          "patch": "    if (result!= null) {\n        return result;\n    }\n    return null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return result.replaceAll(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return new String(result.replace(\"String_Node_Str\", \"String_Node_Str\"));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return StringUtils.isBlank(result)? \"String_Node_Str\" : result;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.isNullOrEmpty(result)? \"String_Node_Str\" : result;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return result.replace(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null)\n        return result;\n    else\n        return null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (result!= null) {\n         return result;\n    }\n    return null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return new String(result).replace(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return result == null? \"String_Node_Str\" : result;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n</s>      return new TypePair(null, null);\n</s>\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(this, that);\n  }\n  throw new IllegalStateException();\n}\n",
      "output": [
        {
          "patch": "                    return new TypePair(this, null);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                return new TypePair(null, null);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                return new TypePair(null, null, null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return new TypePair(this, null);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    return new TypePair(null, that.typeB);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return new TypePair(null, Types.ANY);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return new TypePair(null, null, null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return new TypePair(null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return new TypePair(this, null);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return new TypePair(this, null);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n</s>  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n</s>}\n",
      "output": [
        {
          "patch": "    defineDeclaredFunction(n, parent);\n    defineCatch(n, parent);\n    defineVar(n, parent);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    defineDeclaredFunction(n, parent);\n                    defineCatch(n, parent);\n                    defineVar(n, parent);\n                     }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    defineDeclaredFunction(n, parent);\n    defineCatch(n, parent);\n    defineVar(n, parent);\n    return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    defineDeclaredFunction(n, parent);\n    defineCatch(n, parent);\n    defineVar(n, parent);\n    return true;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                        defineDeclaredFunction(n, parent);\n                        defineCatch(n, parent);\n                        defineVar(n, parent);\n                         }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    defineDeclaredFunction(n, parent);\n    defineCatch(n, parent);\n    defineVar(n, parent);\n    return;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        defineDeclaredFunction(n, parent);\n        defineCatch(n, parent);\n        defineVar(n, parent);\n         return;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    defineDeclaredFunctionAndCatch(n, parent);\n    defineCatch(n, parent);\n    defineVarAndVar(n, parent);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    defineLiteralTypes(n, parent);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    defineDeclaredFunction(n, parent);\n    defineCatch(n, parent);\n    defineVar(n, parent);\n    return ;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n</s>  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n</s>\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n  return super.resolveInternal(t, scope);\n}\n",
      "output": [
        {
          "patch": "     typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "      typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "             typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "         typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                     typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "wrong"
        },
        {
          "patch": "     typeOfThis = (ObjectType) safeResolve(typeOfThis, scope);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ObjectType typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "     typeOfThis = (ObjectType) safeResolve(typeOfThis, t.getType(), scope);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n</s>  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n</s>    }\n  }\n  for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n",
      "output": [
        {
          "patch": "    if (node.getType() == Token.CALL) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node.getType()!= Token.CALL) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    switch(node.getType()) {\n        case Token.CALL:\n            Node child = node.getFirstChild();\n            if (child.getType() == Token.NAME) {\n                changed.add(child.getString());\n            }\n        default:\n            break;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node.getType() == Token.CALL) {\n        Token child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node!= null && node.getType() == Token.CALL) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node.getType() == Token.CALL && node.getFirstChild()!= null) {\n        if (node.getType() == Token.NAME) {\n            changed.add(node.getString());\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node.getType() == Token.CALL && node.getFirstChild()!= null) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node.getType() == Token.CALL || node.getType() == Token.NAME) {\n        changed.add(node.getString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (node!= null) {\n         if (node.getType() == Token.CALL) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (node.getType() == Token.FUNCTION) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n</s>  if (t.getScopeDepth() <= 2) {\n</s>    \n    return;\n  }\n  if (n.isName() && NodeUtil.isLValue(n) &&\n      !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n      }\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}\n",
      "output": [
        {
          "patch": "    if (t.getScopeDepth() <= 1) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (t.getScopeDepth() <= 2 &&!NodeUtil.isBleedingFunctionName(n)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (t.getScopeDepth() <= 2 ||!NodeUtil.isBleedingFunctionName(n)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int scopeDepth = t.getScopeDepth();\n  if (scopeDepth <= 2) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (t.getScopeDepth() <= 3) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (t.getScopeDepth() <= 2) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (t.getScopeDepth() < 2) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    } else if (t.getScopeDepth() <= 2) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (t.getScopeDepth() <= 1 || t.getScopeDepth() <= 2) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (t.getScopeDepth() <= 2 || t.inGlobalScope()) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "public Base64() {\n</s>    this(false);\n</s>}\n",
      "output": [
        {
          "patch": "    throw new UnsupportedOperationException();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    this.zero();\n    this.zero();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new RuntimeException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    throw new UnsupportedOperationException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    synchronized (this) {\n        this(false);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this(true);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    base64 = this.getBase64();\n    return base64;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.position = 0;\n    this.position = 0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.position(0);\n    this.position(0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    this.setLength(0);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "public static String encodeBase64String(byte[] binaryData) {\n</s>    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n</s>}\n",
      "output": [
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n",
          "correctness": "plausible"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, true, true));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, true, UTF_8));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, true, false));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, true, StandardCharsets.UTF_8));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, \"String_Node_Str\"));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, UTF_8));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, true), UTF_8);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, false), UTF_8);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n",
          "correctness": "wrong"
        }
      ]
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n</s>    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n</s>    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n",
      "output": [
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, BASE_64);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, maxResultSize);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, DEFAULT_ENCODING);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, CHARSET_CHUNK_SIZE, CHUNK_SEPARATOR);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, isChunked);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, BASE_CHUNK_SIZE, CHUNK_SEPARATOR);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR, CHUNK_TYPE);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "public static String newStringIso8859_1(final byte[] bytes) {\n</s>    return new String(bytes, Charsets.ISO_8859_1);\n</s>}\n",
      "output": [
        {
          "patch": "    return new String(bytes, Charsets.US_ASCII);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return new String(bytes, Charsets.ISO_8859_1, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String(bytes, Charsets.ISO_8859_2);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String(bytes, Charsets.US_ASCII, Charsets.ISO_8859_1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String(bytes, \"String_Node_Str\", Charsets.ISO_8859_1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String(bytes, Charsets.ISO_8859_1, StandardCharsets.US);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String(bytes, Charsets.ISO_8859_2, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String(bytes, Charsets.UTF_8);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return new String(bytes, Charsets.ISO_8859_1, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new String((byte[]) bytes, Charsets.ISO_8859_1);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n</s>    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n</s>}\n",
      "output": [
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 1, cs2, 0, Math.max(cs1.length(), cs2.length()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, cs2, 0, Math.max(cs1.length(), cs2.length()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatchesIgnoreCase(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, min(cs1.length(), cs2.length()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, 0, Math.max(cs1.length(), cs2.length()));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Collections_26_/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java_277-278": {
      "loc": "277-278",
      "input": "\n</s>private Object readResolve() {\n</s>    calculateHashCode(keys);\n    return this;\n}\n",
      "output": [
        {
          "patch": "    lock.lock();\n    try {\n        Object readResolve = readResolve();\n        lock.unlock();\n    } finally {\n        lock.unlock();\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = null;\n    lock.lock();\n    try {\n        resolve = readResolve();\n    } finally {\n        lock.unlock();\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = null;\n    try {\n        resolve = readResolve();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = null;\n    if (keys!= null) {\n        resolve = keys.iterator().next();\n    } else {\n        resolve = readResolve();\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = null;\n    try {\n        resolve = readResolve();\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = null;\n    try {\n        resolve = readResolve();\n    } finally {\n        resolve = null;\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = readResolve();\n    if (resolve!= null) {\n        calculateHashCode(resolve);\n        return resolve;\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = readResolve();\n    if (resolve == null) {\n        return null;\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = null;\n    try {\n        resolve = readResolve();\n    } catch (RuntimeException e) {\n        throw new RuntimeException(e);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Object resolve = readResolve();\n    if (resolve == null) {\n        return null;\n    } else {\n        calculateHashCode(keys);\n        return null;\n    }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n</s>        if (read == 0 && inf.finished()) {\n            return -1;\n</s>        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}\n",
      "output": [
        {
          "patch": "        if (read == 0) {\n            if (inf.finished()) {\n                return -1;\n            }\n            crc.update(buffer, start, read);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (read == 0) {\n            throw new ZipException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (read == 0) {\n            crc.update(buffer, start, read);\n            return read;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (read!= 0) {\n            if (inf.finished()) {\n                return -1;\n            }\n            crc.update(buffer, start, read);\n",
          "correctness": "timeout"
        },
        {
          "patch": "        if (read == 0) {\n            return -1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (read == 0) {\n            if (inf.finished()) {\n                break;\n            }\n            crc.update(buffer, start, read);\n            return read;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (read == 0) {\n            if (inf.finished()) {\n                crc.update(buffer, start, read);\n                return read;\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (read == 0) {\n            if (inf.finished()) {\n                continue;\n            }\n            crc.update(buffer, start, read);\n            return read;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (read == 0) {\n            if (inf.finished())\n                return -1;\n            crc.update(buffer, start, read);\n            return read;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (read!= 0 && inf.finished()) {\n            crc.update(buffer, start, read);\n            return read;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n</s>    currEntry = new TarArchiveEntry(headerBuf);\n</s>    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n    if (currEntry.isPaxHeader()){ \n        paxHeaders();\n    }\n    if (currEntry.isGNUSparse()){ \n        readGNUSparse();\n    }\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n",
      "output": [
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, headerBuf.length);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, entrySize);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, hasNext);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, hasHitEOF);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    nextEntry = new TarArchiveEntry(headerBuf);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, 0, headerBuf.length);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, this);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    currEntry = new TarArchiveEntry(headerBuf, readBuf);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n</s>    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i] != 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n</s>        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}\n",
      "output": [
        {
          "patch": "    if (buffer[start]!= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (buffer[start]!= 0)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (buffer[start]!= 0L) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (buffer[start]!= 0 && buffer[start]!= 0)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (buffer[start] == 0L) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (buffer[start]!= 0x0ffffffffL) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (buffer[start]!= 0 || buffer[start]!= 0)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (buffer.length == 0 || buffer.length == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (buffer[start]!= 0 && buffer[start]!= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (!isOctal(buffer, start, end)) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n</s>        if (rawCentralDirectoryData.length != expectedLength) {\n</s>            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "        if (!Arrays.equals(rawCentralDirectoryData.length, expectedLength)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (expectedLength < 0 || rawCentralDirectoryData.length!= expectedLength) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length!= expectedLength + DWORD) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length!= expectedLength &&!hasUncompressedSize) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length!= expectedLength || expectedLength < 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length!= expectedLength && expectedLength > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length < expectedLength) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length!= expectedLength && expectedLength!= expectedLength) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (!hasUncompressedSize || rawCentralDirectoryData.length!= expectedLength) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (rawCentralDirectoryData.length!= expectedLength && expectedLength!= 0) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n</s>        dictSize |= (coder.properties[i + 1] << (8 * i));\n</s>    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}\n",
      "output": [
        {
          "patch": "        dictSize |= (coder.properties[i + 1] & 0xFF) << (8 * i);\n",
          "correctness": "plausible"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] << (8 * i + 2));\n",
          "correctness": "wrong"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] << (8 * i - 1));\n",
          "correctness": "wrong"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] & 0xFFL);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        dictSize |= ((coder.properties[i + 1] & 0xFF) << (8 * i));\n",
          "correctness": "plausible"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] << (8 * i + 3));\n",
          "correctness": "wrong"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] & 0xFF);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] << (8 * i) & 0xFF);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] >>> (8 * i));\n",
          "correctness": "plausible"
        },
        {
          "patch": "        dictSize |= (coder.properties[i + 1] >> (8 * i));\n",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n</s>    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n</s>\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}\n",
      "output": [
        {
          "patch": "    exceptionMessage(buffer, offset, length, start, trailer);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    exceptionMessage(buffer, offset, length, start, trailer));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    exceptionMessage(buffer, offset, length, start, trailer, end);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    checkLength(buffer, offset, length, start, trailer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    exceptionMessage(buffer, start, offset, length, start, trailer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    checkOffset(buffer, offset, length, start, trailer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    exceptionMessage(buffer, offset, length, start, trailer, 0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    IllegalArgumentException exceptionMessage(buffer, offset, length, start, trailer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    ExceptionMessage exceptionMessage(buffer, offset, length, start, trailer);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    checkException(buffer, offset, length, start, trailer);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n</s>        if (currentByte == 0) {\n            break;\n        }\n</s>        \n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}\n",
      "output": [
        {
          "patch": "        currentByte = (currentByte << 3) | (currentByte - '0');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = currentByte & 0xFF;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = (currentByte << 3) | (currentByte & 0xFF);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = (currentByte & 0xFF);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = (currentByte << 3) + (currentByte - '0');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (currentByte == 0)\n            break;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        currentByte = (currentByte << 3) | (currentByte & 0xff);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = (currentByte << 3) | currentByte;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = (currentByte << 4) | (currentByte & 0xFF);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        currentByte = (currentByte >> 3) | (currentByte & 0xFF);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n</s>    if (getName().endsWith(\"/\")) {\n</s>        return true;\n    }\n    return false;\n}\n",
      "output": [
        {
          "patch": "    if (getName().endsWith(\"String_Node_Str\")) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (getName()!= null && getName().endsWith(\"/\")) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (getName().contains(\"String_Node_Str\")) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (getName().endsWith(\"/'\") && file!= null && file.isDirectory()) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (getName().length() > 0 && getName().endsWith(\"/\")) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (getName().equals(\"String_Node_Str\")) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (getName(\"String_Node_Str\")!= null && getName().endsWith(\"/\")) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (getName().equals(\"String_Node_Str\") || getName().endsWith(\"/\")) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (getName().endsWith(\"/'\")) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (getName().endsWith(\"String_Node_Str\") && file!= null) {\n",
          "correctness": "plausible"
        }
      ]
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "private static ZipLong unixTimeToZipLong(long l) {\n</s>    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n</s>        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n    }\n    return new ZipLong(l);\n}\n",
      "output": [
        {
          "patch": "    final long TWO_TO_64 = 0x100000000L;\n    if (l >= TWO_TO_64) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_64 = 0x100000000L;\n    if (l > TWO_TO_64) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_32 = 0x100000000L;\n    if (l > TWO_TO_32) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_64 = 0x1000000L;\n    if (l >= TWO_TO_64) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_LONG = 0x100000000L;\n    if (l >= TWO_TO_LONG) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_LONG = 0x100000000L;\n    if (l > TWO_TO_LONG) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_64 = 0x1000000L;\n    if (l > TWO_TO_64) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32)\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final long TWO_TO_31 = 0x100000000L;\n    if (l >= TWO_TO_31) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n</s>    if (current == '\\n') {\n</s>        lineCounter++;\n    }\n    lastChar = current;\n    return lastChar;\n}\n",
      "output": [
        {
          "patch": "    if (current >= '\\n') {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' || current == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' || current >= lineCounter) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' || current == '\\n') {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' && lineCounter > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' || current == -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' || current == '\\r') {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' && lineCounter < lineCounter) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current < '\\n') {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (current == '\\n' || current == '\\0') {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "public Map<String, Integer> getHeaderMap() {\n</s>    return new LinkedHashMap<String, Integer>(this.headerMap);\n</s>}\n",
      "output": [
        {
          "patch": "    return new LinkedHashMap<>(this.headerMap);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return Collections.unmodifiableMap(this.headerMap);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new LinkedHashMap<String, Integer>(this.headerMap.entrySet());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return this.headerMap == null? null : new LinkedHashMap<String, Integer>(this.headerMap);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    return new LinkedHashMap<String, Integer>(this.headerMap.keySet());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return ImmutableMap.copyOf(this.headerMap, this.headerMap.size());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return this.headerMap.entrySet().toArray(new HashMap<String, Integer>());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return ImmutableMap.of(\"String_Node_Str\", this.headerMap);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new HashMap<String, Integer>(this.headerMap.entrySet());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return this.headerMap.entrySet().toArray(new String[this.headerMap.size()]);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n</s>                final boolean emptyHeader = header.trim().isEmpty();\n</s>                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}\n",
      "output": [
        {
          "patch": "                final boolean emptyHeader =!header.trim().isEmpty();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header!= null && header.trim().isEmpty();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header.trim().isEmpty() &&!format.getIgnoreEmptyHeaders();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header.trim().isEmpty() || header.length() == 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header == null || header.trim().isEmpty();\n",
          "correctness": "plausible"
        },
        {
          "patch": "                final boolean emptyHeader = header == null? false : header.trim().isEmpty();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header.trim().isEmpty();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header.trim().isEmpty() ||!format.getIgnoreEmptyHeaders();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header.trim().isEmpty() || header.trim().isEmpty();\n",
          "correctness": "wrong"
        },
        {
          "patch": "                final boolean emptyHeader = header.trim().length() == 0;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n</s>  TypeAdapter t =\n    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n</s>  t.write(writer, fieldValue);\n}\n",
      "output": [
        {
          "patch": "    TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), context);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final TypeAdapter t =\n    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    TypeAdapter t = (TypeAdapter) new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), fieldType.getType());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "      TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), context);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), this);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), context.getClassLoader());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final TypeAdapter t =\n        new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n",
          "correctness": "wrong"
        },
        {
          "patch": "       TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType(), context);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n</s>  if (Double.isNaN(value) || Double.isInfinite(value)) {\n</s>    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}\n",
      "output": [
        {
          "patch": "    if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "       if (Double.isNaN(value) || Double.isInfinite(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "     if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "      if (Double.isNaN(value) || Double.isInfinite(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (Double.isNaN(value) || Double.isInfinite(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (Double.isNaN(value) || Double.isInfinite(value) || Float.isNaN(value)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (Double.isNaN(value) || Double.isInfinite(value) || Double.isInfinite(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (Double.isNaN(value) || Double.isInfinite(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "     if (Double.isNaN(value) || Double.isInfinite(value)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "      if (Double.isNaN(value) || Double.isInfinite(value) ||!isNaN(value)) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "@Override\npublic Date read(JsonReader in) throws IOException {\n</s>  if (in.peek() != JsonToken.STRING) {\n    throw new JsonParseException(\"The date should be a string value\");\n</s>  }\n  Date date = deserializeToDate(in.nextString());\n  if (dateType == Date.class) {\n    return date;\n  } else if (dateType == Timestamp.class) {\n    return new Timestamp(date.getTime());\n  } else if (dateType == java.sql.Date.class) {\n    return new java.sql.Date(date.getTime());\n  } else {\n    throw new AssertionError();\n  }\n}\n",
      "output": [
        {
          "patch": "    if (in.peek() == JsonToken.STRING) {\n        throw new JsonParseException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING &&!in.isNull()) {\n        throw new JsonParseException(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"String_Node_Str\" + in.nextString());\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING &&!in.isNull()) {\n        throw new JsonParseException(\"String_Node_Str\" + in.nextString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING &&!in.isEmpty()) {\n        throw new JsonParseException(\"String_Node_Str\" + in.nextString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (in.peek() == JsonToken.STRING) {\n        throw new JsonParseException(\"String_Node_Str\" + in.nextString());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"String_Node_Str\" + in.nextString() + \"String_Node_Str\");\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING &&!StringUtils.isEmpty(in.nextString())) {\n        throw new JsonParseException(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (!StringUtils.isEmpty(in.nextString())) {\n        throw new JsonParseException(\"String_Node_Str\" + in.peek() + \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (in.peek()!= JsonToken.STRING &&!in.isEmpty()) {\n        throw new JsonParseException(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n</s>        char c = str.charAt(i++);\n</s>        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}\n",
      "output": [
        {
          "patch": "        char c = str.charAt(i);\n",
          "correctness": "plausible"
        },
        {
          "patch": "        char c = str.charAt(i + 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        char c = str.charAt(i) & 0xFF;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        int c = str.charAt(i++);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        char c = str.charAt(i++);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        char c = str.charAt(i++) & 0xFF;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        char c = str.charAt(i++).toLowerCase();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        char c = str.charAt(i) & 0xff;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        char c = str.charAt(i++) & 0xFF;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        char c = str.charAt(i++).toUpperCase();\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n</s>    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n</s>        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}\n",
      "output": [
        {
          "patch": "    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 0; i < len - 1; ++i) {\n        char c = str.charAt(i);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int j = 0; j < len; ++j) {\n        char c = str.charAt(j);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i - 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i + 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 0; i <= len; ++i) {\n        char c = str.charAt(i);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int c = 0; c < len; ++c) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 1; i < len; ++i) {\n        char c = str.charAt(i);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 0; i < len; ++i) {\n        int c = str.charAt(i);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i).toString();\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n</s>    if (!_hasSegments)  return _currentSegment;\n</s>    \n    return contentsAsArray();\n}\n",
      "output": [
        {
          "patch": "    if (_currentSegment!= null)\n        return _currentSegment;\n    else\n        return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_currentSegment!= null)\n        return _currentSegment;\n    else\n        return \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_hasSegments)\n        return _currentSegment;\n    else\n        return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_currentSegment!= null)\n        return _currentSegment.toCharArray();\n    else\n        return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_currentSegment!= null) {\n        if (!_hasSegments)\n            return _currentSegment;\n    }\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (_currentSegment!= null &&!_hasSegments)\n        return _currentSegment;\n    else\n        return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (!_hasSegments && _currentSegment!= null)\n        return _currentSegment;\n    else\n        return null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_currentSegment!= null)\n        return _currentSegment;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (!_hasSegments) {\n        if (_currentSegment!= null) {\n            return _currentSegment;\n        }\n    }\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (_currentSegment == null)\n        return null;\n    else\n        return _currentSegment;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "public void writeEmbeddedObject(Object object) throws IOException {\n</s>    throw new JsonGenerationException(\"No native support for writing embedded objects\",\n</s>            this);\n}\n",
      "output": [
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + object + \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + object, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + object.toString() + \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + object.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\", object);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + this + \"String_Node_Str\" + object);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + \"String_Node_Str\" + object.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    throw new JsonGenerationException(\"String_Node_Str\" + object + \"String_Node_Str\" + this);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n</s>        if (i <= maxCode) {\n</s>            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n",
      "output": [
        {
          "patch": "        if (i <= maxCode && codes[i]!= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i <= maxCode && (codes[i]!= 0)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i <= maxCode - 1) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (i <= maxCode && i < codes.length) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (i <= maxCode + 1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i >= maxCode) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i <= maxCode && codes[i] == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i <= maxCode && (codes[i] == 0)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i <= maxCode && (codes[i]!= 0))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (i < maxCode && codes[i]!= 0) {\n",
          "correctness": "plausible"
        }
      ]
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "@Override\npublic boolean isCachable() {\n</s>    return (_valueTypeDeserializer == null)\n</s>            && (_ignorableProperties == null);\n}\n",
      "output": [
        {
          "patch": "    return (_valueTypeDeserializer == null) && (_ignorableProperties == null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer == null) || (_ignorableProperties == null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer == null || _ignorableProperties == null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_valueTypeDeserializer == null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer == null && _ignorableProperties == null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer!= null) && (_ignorableProperties == null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer == null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (_valueTypeDeserializer == null) {\n        return false;\n    } else {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer == null) && (_ignorableProperties!= null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (_valueTypeDeserializer == null) || _ignorableProperties == null;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n</s>    return (previous != null) && previous.equals(ann);\n</s>}\n",
      "output": [
        {
          "patch": "    return previous!= null && previous.equals(ann);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (previous!= null) && previous.equals(ann);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (previous!= null) && previous.equals(ann.annotationType());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return previous == null || previous.equals(ann);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    return (previous!= null) && previous.getName().equals(ann);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (previous!= null) &&!previous.equals(ann);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (previous!= null) && previous.getName().equals(ann.name());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return previous == null? false : previous.equals(ann);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (previous!= null) && previous.getName().equals(ann.getName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (previous!= null) && previous.getAnnotation().equals(ann);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n</s>                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n</s>\n    case NON_FINAL:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n    default:\n        return (t.getRawClass() == Object.class);\n    }\n}\n",
      "output": [
        {
          "patch": "                return TreeNode.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return TreeTreeNode.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return (TreeNode.class.isAssignableFrom(t.getRawClass()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return treeNode.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return TreeUtil.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                returnTreeNode.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return TreeType.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return Tree.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return!TreeNode.class.isAssignableFrom(t.getRawClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return TreeNode.class.isAssignableFrom(t);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n</s>                || _hasAnnotation(a, JsonRawValue.class)) {\n</s>            name = \"\";\n        } else {\n            return null;\n        }\n    }\n    return PropertyName.construct(name);\n}\n",
      "output": [
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonRawValue.class)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                || _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonRawValue.class)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonView.class)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonNoValue.class)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                || _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonNoValue.class)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                || _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonView.class)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonRawValue.class))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonBase.class)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                if (_hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonBind.class)) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n</s>            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n</s>        } else {\n             visitor.expectNumberFormat(typeHint);\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "            visitBigDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitFloatFormat(visitor, typeHint, BigDecimal.class);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitBigDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitBigDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_LONG);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitBigDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitLongFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitBigNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitDoubleFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            visitDoubleFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n</s>    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n</s>            _valueHandler, _typeHandler, _asStatic);\n}\n",
      "output": [
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _asStatic);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType( subclass, _bindings, _superClass, _superInterfaces, _asStatic);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _asStatic);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings(), _superClass, _superInterfaces, _asStatic);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _typeHandler);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings(), _superClass, _superInterfaces);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _isStatic);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _method);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n</s>            if (format.getShape() == JsonFormat.Shape.STRING) {\n</s>                TimeZone tz = format.getTimeZone();\n                final String pattern = format.hasPattern()\n                                ? format.getPattern()\n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale loc = format.hasLocale()\n                                ? format.getLocale()\n                                : serializers.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = serializers.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n    }\n    return this;\n}\n",
      "output": [
        {
          "patch": "            if (format!= null && format.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (format.hasShape() && format.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (format.getShape() == JsonFormat.Shape.STRING && format.isNumeric()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            if (shape.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            if (shape.isNumeric() && format.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (format.getShape() == JsonFormat.Shape.STRING && format!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (format.isNumeric() && format.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            if (format.getShape() == JsonFormat.Shape.STRING &&!format.isNull()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            if (format.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (shape.isString() && format.getShape() == JsonFormat.Shape.STRING) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n</s>    sb.append(';');\n</s>    return sb;\n}\n",
      "output": [
        {
          "patch": "    sb.append(':');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(';').append(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (sb!= null)\n        sb.append(';');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(';').append('}');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(';').append(';');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append('}').append(';');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(';').append(':');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(':').append(';');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(';').append('\\n');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    sb.append(';').append(';').append('}');\n",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n</s>    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n</s>            true));\n}\n",
      "output": [
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n, false));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n, true));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, false), \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, true), \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(null, _parserFactory.createParser(src), \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n, null));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, null), \n));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n), false));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n</s>            found = key.equals(prop.getName());\n</s>            if (found) {\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}\n",
      "output": [
        {
          "patch": "            found = key.equalsIgnoreCase(prop.getName());\n",
          "correctness": "plausible"
        },
        {
          "patch": "            if (key!= null) {\n                found = key.equals(prop.getName());\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "            found =!key.equals(prop.getName());\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (key.equals(prop.getName())) {\n                found = true;\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (key.equalsIgnoreCase(prop.getName())) {\n                found = true;\n            }\n",
          "correctness": "plausible"
        },
        {
          "patch": "            if (!key.equals(prop.getName())) {\n                found = false;\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (key.equals(prop.getName())) {\n                found = false;\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (key.equalsIgnoreCase(prop.getName())) {\n                found = false;\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "            if (key.equals(prop.getName())) {\n                continue;\n            }\n",
          "correctness": "wrong"
        },
        {
          "patch": "            found = key.equals(prop.getName() + \"String_Node_Str\" + prop.getName());\n",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n</s>    if (raw == String.class || raw == Object.class) {\n</s>        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}\n",
      "output": [
        {
          "patch": "    if (raw == String.class) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw == String.class || raw == Class.class) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw.equals(String.class)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw == String.class || raw.isAssignableFrom(String.class)) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (raw == Class.class || raw == Object.class) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw == String.class || raw.isInstance(Object.class)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw.equals(String.class) || raw == Object.class) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw == String.class || raw == String.class) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw.equals(\"String_Node_Str\")) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (raw == String.class || raw.isInstance(String.class)) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n</s>        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n</s>                String name = cls.getSimpleName();\n                if (\"AbstractPointcutAdvisor\".equals(name)\n                        || \"AbstractApplicationContext\".equals(name)) {\n                    break main_check;\n                }\n            }\n        }\n        return;\n    } while (false);\n    throw JsonMappingException.from(ctxt,\n            String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n}\n",
      "output": [
        {
          "patch": "        if (full.startsWith(Constants.PREFIX_STRING)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(PREFIX_STRING) || full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(getPrefixString())) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(TYPE_PREFIX_STRING)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(PREFIX_STRING + \"String_Node_Str\")) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(PREFIX_STRING) || full.startsWith(PREFIX_OBJECT)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(\"String_Node_Str\")) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (full.startsWith(PREFIX_STRING) || full.startsWith(PREFIX_CLASS)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls : raw) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n</s>        paramName = candidate.findImplicitParamName(0);\n</s>        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}\n",
      "output": [
        {
          "patch": "        if (paramName!= null) {\n            paramName = candidate.findImplicitParamName(0);\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        paramName = candidate.implicitParamName(0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        paramName = candidate.explicitParamName(0);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        paramName = (paramName!= null)? candidate.findImplicitParamName(0) : null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (candidate.implicitParamName()!= null) {\n            paramName = candidate.findImplicitParamName(0);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (paramName == null) {\n            paramName = candidate.explicitParamName(0);\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (candidate.hasImplicitParamName()) {\n            paramName = candidate.findImplicitParamName(0);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (paramName == null) {\n            paramName = candidate.implicitParamName(0);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (paramDef!= null) {\n            paramName = candidate.findImplicitParamName(0);\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        PropertyName implicitParamName = candidate.findImplicitParamName(0);\n",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n</s>        gen.writeObject(_value);\n</s>    }\n}\n",
      "output": [
        {
          "patch": "        gen.writeObject(_value, ctxt);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        gen.writeObject(value, ctxt);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        _value.serialize(gen, ctxt);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        gen.writeObject((Object) _value);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        serialize(_value, ctxt);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        write(gen, _value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        _value = gen.writeObject(_value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        writer.writeObject(_value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        serialize(_value);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        out.writeObject(_value);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n</s>                buffer.assignParameter(typeProp, typeId);\n</s>            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}\n",
      "output": [
        {
          "patch": "                buffer.assignParameter(typeProp, typeId + 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, values[i]);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, typeId, prop);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, typeId, _typeIds[i]);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, typeId, prop.getType());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, _typeIds[i]);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, typeId, _properties[i]);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, _typeIds[i], typeId);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, typeId, _propertyIds[i]);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                buffer.assignParameter(typeProp, prop.getTypeId());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n</s>                    return null;\n</s>                }\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n",
      "output": [
        {
          "patch": "                    throw new IOException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    return new JsonDeserializer<Object>();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    throw new IllegalStateException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    return null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    throw new IllegalArgumentException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    throw new NotFoundException(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    throw new RuntimeException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    throw new UnsupportedOperationException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "                    return \"String_Node_Str\";\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return _property;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n</s>    _rootNameLookup = src._rootNameLookup;\n</s>}\n",
      "output": [
        {
          "patch": "    if (src!= null) {\n        _rootNameLookup = src._rootNameLookup;\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    _rootNameLookup = src.getRootNameLookup();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (src._rootNameLookup!= null)\n        _rootNameLookup = src._rootNameLookup;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (src!= null)\n        _rootNameLookup = src._rootNameLookup;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (src!= null) {\n        _rootNameLookup = src.rootNameLookup;\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    _rootNameLookup = src._rootNameLookup == null? null : src._rootNameLookup;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    _rootNameLookup = src._rootNameLookup!= null? src._rootNameLookup : null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    _rootNameLookup = src.rootNameLookup == null? null : src._rootNameLookup;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    _rootNameLookup = src.rootNameLookup!= null? src._rootNameLookup : null;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    _rootNameLookup = src.rootNameLookup;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n</s>        body().appendChild(new TextNode(\" \", \"\"));\n        body().appendChild(node);\n</s>    }\n}\n",
      "output": [
        {
          "patch": "        if (node.getText().equals(\"String_Node_Str\")) {\n            body().appendChild(new TextNode(\" \", \"\"));\n            body().appendChild(node);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (node.getText().equals(\"String_Node_Str\"))\n            body().appendChild(new TextNode(\" \", \"\"));\n        else\n            body().appendChild(node);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!node.isBlank())\n            body().appendChild(new TextNode(\" \", \"\"));\n        if (!node.isBlank())\n            body().appendChild(node);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (node.getText().equals(\"String_Node_Str\")) {\n            body().appendChild(new TextNode(\" \",\"\"));\n            body().appendChild(node);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (node.getText().equals(\"String_Node_Str\"))\n            body().appendChild(new TextNode(\" \",\"\"));\n        else\n            body().appendChild(node);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!node.isBlank()) {\n            body().appendChild(new TextNode(\" \", \"\"));\n            body().appendChild(node);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (node.getName().equals(\"String_Node_Str\")) {\n            body().appendChild(new TextNode(\" \", \"\"));\n            body().appendChild(node);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!node.equals(\"String_Node_Str\")) {\n            body().appendChild(new TextNode(\" \", \"\"));\n            body().appendChild(node);\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (node.getNodeName().equals(\"String_Node_Str\")) {\n            body().appendChild(new TextNode(\" \", \"\"));\n            body().appendChild(node);\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (node.getName().equals(\"String_Node_Str\"))\n            body().appendChild(new TextNode(\" \", \"\"));\n        else\n            body().appendChild(node);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n</s>        r.advance();\n</s>        return;\n    }\n    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\f':\n            case ' ':\n                t.transition(BeforeAttributeName);\n                break;\n            case '/':\n                t.transition(SelfClosingStartTag);\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            default:\n                t.dataBuffer.append(c);\n                anythingElse(t, r);\n                break;\n        }\n    } else {\n        anythingElse(t, r);\n    }\n}\n",
      "output": [
        {
          "patch": "        r.advance(1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        r.advanceAndEnd();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        r.advance(0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        r.advance(t.tagPending);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        r.advanceAndClose();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        r.advance(false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        t.advance();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        r.advance(2);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        while (!r.isEmpty()) r.advance();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        r.advanceAndBreak();\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n</s>        if (offset < length) {\n</s>            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) \n                return offset - pos;\n        }\n    }\n    return -1;\n}\n",
      "output": [
        {
          "patch": "        if (offset < length - 1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (offset <= length) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (offset < length + 1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (i < last && offset < length) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (offset + 1 < length) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (last > offset + 1 && offset < length) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (last < length) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (last > offset && offset < length) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (offset < length && offset < last) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (offset < length - 1 && offset < length) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n</s>    return accum.toString().trim();\n</s>}\n",
      "output": [
        {
          "patch": "    return accum.toString().replaceAll(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString().replace(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString().trim().replace(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString().trim().replaceAll(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return accum.toString().replace(\"String_Node_Str\", \"String_Node_Str\").trim();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString().replaceAll(\"String_Node_Str\", \"String_Node_Str\").trim();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString().replaceAll(\"String_Node_Str\", \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return accum.toString() == null? \"String_Node_Str\" : accum.toString().trim();\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n</s>    Validate.notEmpty(name);\n</s>    attr(\"name\", name);\n    attr(\"publicId\", publicId);\n    attr(\"systemId\", systemId);\n}\n",
      "output": [
        {
          "patch": "    Validate.notNull(name, \"String_Node_Str\");\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (name!= null) {\n        Validate.notEmpty(name);\n    }\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Validate.notEmpty(name, \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (name!= null)\n        Validate.notEmpty(name);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Validate.notEmpty(\"String_Node_Str\", name);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    name = Validate.notNull(name);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Validate.isNotNull(name, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name!= null) {\n        validate(name);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (name!= null) {\n        Validate.notNull(name);\n    }\n",
          "correctness": "plausible"
        },
        {
          "patch": "    name = Validate.notEmpty(name);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n</s>    return this == o;\n</s>}\n",
      "output": [
        {
          "patch": "    return this == element;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.equals(element);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return super.equals(element);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    return super.equals(element) && this == o;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.equals(element) || this.equals(element);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this == element && element.getName().equals(this.getName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return this.equals(element) && this.equals(element);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.getName().equals(element.getName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return this.equals(element) && this.equals(o);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.equals(element) || this.equals(o);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n</s>        if (element.equals(search))\n</s>            return i;\n    }\n    return null;\n}\n",
      "output": [
        {
          "patch": "        if (element.equals(search)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (element.getName().equals(search))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (element.getName().equals(search.getName()))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (element.getId().equals(search.getId()))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (element.getId().equals(search))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (element.getNodeName().equals(search.getNodeName()))\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (element!= null && element.equals(search))\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (element == null || element.equals(search))\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (element.getClass().equals(search.getClass()))\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (element.toString().equals(search))\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n</s>        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n</s>            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        }\n    }\n}\n",
      "output": [
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last || \"html\".equals(name)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (\"td\".equals(name) || \"td\".equals(name) &&!last || \"html\".equals(name)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last || (\"html\".equals(name))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last || (\"td\".equals(name))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name) && last || \"html\".equals(name)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (\"td\".equals(name) || \"td\".equals(name) &&!last) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if (\"td\".equals(name) || \"td\".equals(name)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name) || \"td\".equals(name)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n</s>    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n</s>}\n",
      "output": [
        {
          "patch": "    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'Z');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (c >= 'A' && c <= 'z') || (c >= 'a' && c <= 'z');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (c >= 'A' && c < 'Z') || (c >= 'a' && c <= 'z');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (c >= 'A' && c <= 'Y') || (c >= 'a' && c <= 'z');\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (c >= 'A' && c <= 'Z') || c >= 'a' && c <= 'z');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c >= 'a' && c <= 'z');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (c >= 'A' || c <= 'Z') || (c >= 'a' && c <= 'z');\n",
          "correctness": "timeout"
        },
        {
          "patch": "    return (c >= 'A' && c <= 'Z') || (c >= 'A' && c <= 'z');\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n</s>            attributes.remove(attrKey);\n</s>    }\n}\n",
      "output": [
        {
          "patch": "            attributes.remove(attrKey.toLowerCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "            this.attributes.remove(attrKey);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return attributes.remove(attrKey);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            remove(attrKey);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            attributes.remove(attrKey).remove();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            attributes.remove(attrKey.toUpperCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "            attributeMap.remove(attrKey);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            attributes.remove(attrKey.trim());\n",
          "correctness": "wrong"
        },
        {
          "patch": "            attributeSet.remove(attrKey);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            attributes.put(attrKey, null);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "public boolean hasClass(String className) {\n</s>    final String classAttr = attributes.get(\"class\");\n</s>    final int len = classAttr.length();\n    final int wantLen = className.length();\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n    return false;\n}\n",
      "output": [
        {
          "patch": "    final String classAttr = attributes.get(ATTR_CLASS);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = attributes.get(ATTR_NAME);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = getAttribute(\"class\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String classAttr = attributes.get(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final String classAttr = attributes.get(CLASS_ATTR);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = attributes.get(ATTR_KEY);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = attributes.get(XMLConstants.CLASS);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = attributes.get(ATTR);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = attributes.get(CLASS);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String classAttr = attributes.get(KEY_CLASS);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n</s>    int bottom = stack.size() -1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n</s>    final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n    for (int pos = bottom; pos >= top; pos--) {\n        final String elName = stack.get(pos).nodeName();\n        if (inSorted(elName, targetNames))\n            return true;\n        if (inSorted(elName, baseTypes))\n            return false;\n        if (extraTypes != null && inSorted(elName, extraTypes))\n            return false;\n    }\n    return false;\n}\n",
      "output": [
        {
          "patch": "    int bottom = stack.size() - 1;\n",
          "correctness": "plausible"
        },
        {
          "patch": "    int bottom = stack.size();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int bottom = stack.size() - 2;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int bottom = stack.size() - 1;\n",
          "correctness": "plausible"
        },
        {
          "patch": "    int bottom = stack.size() - 1 - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int bottom = getStackSize() - 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int bottom = currentStack.size() - 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int bottom = Stack.size() - 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int top = stack.size() - 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int bottom = maxScopeSearchDepth;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n</s>        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n</s>            accum.append(\"=\\\"\");\n            Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n            accum.append('\"');\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) || Attribute.isBooleanAttribute(key)))) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) || Attribute.isBooleanAttribute(key))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key) || val.equals(key))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key))) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key)) &&!Attribute.isBooleanAttribute(key)) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "private void popStackToClose(Token.EndTag endTag) {\n</s>    String elName = endTag.name();\n</s>    Element firstFound = null;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; \n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}\n",
      "output": [
        {
          "patch": "    String elName = endTag.nodeName();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String elName = endTag.getTagName();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String elName = tag.name();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String elName =EndTag.nodeName();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String elName = endTag.name().toLowerCase();\n",
          "correctness": "plausible"
        },
        {
          "patch": "    String elName = endTag.node();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final String elName = endTag.name();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    String tagName = endTag.name();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    String elName = endTag.name();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (tagName == null)\n        return;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n</s>    if (doc.childNodeSize() > 0) {\n</s>        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}\n",
      "output": [
        {
          "patch": "    if (doc.childNodeSize() > 1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (doc!= null && doc.childNodeSize() > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (doc.childNodeSize() > 0 && doc.childText().length() > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    int childNodeSize = doc.childNodeSize();\n    if (childNodeSize > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (doc.childNodeSize() > 0 && doc.childText().length() > 1) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (doc.childNodeSize() > 0 && data.length() > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (doc.childNodeSize() > 0 && data.startsWith(\"String\")) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (doc.childNodeSize() > 0 &&!doc.isDisposed()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (doc.childNodeSize() > 1 && doc.childNodeSize() > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (doc.childNodeSize() >= 1 && doc.childNodeSize() > 0) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "public String getValue() {\n</s>    return val;\n</s>}\n",
      "output": [
        {
          "patch": "    return value;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringUtils.decode(val, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\";\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.value;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringFormatUtil.format(val, format);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringFormatUtil.format(val);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return val!= null? val : \"String_Node_Str\";\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return getString(\"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return StringEscapeUtils.escapeHtml(val);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n</s>        throw new JXPathException(\n                \"Cannot compare pointers that do not belong to the same tree: '\"\n                        + p1 + \"' and '\" + p2 + \"'\");\n</s>    }\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n    if (r != 0) {\n        return r;\n    }\n    return p1.parent.compareChildNodePointers(p1, p2);\n}\n",
      "output": [
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 +\"'and '\" + p2 + '\"');\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 + '\"' + p2 + '\"');\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 + '\"'and '\" + p2 + '\"');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 + \"'and '\" + p2 + \"'\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 + '\"and '\" + p2 + '\"');\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 +\"'and '\" + p2 + \"'\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 + \"'and '\" + p2 + '\"');\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\"String_Node_Str\" + p1 + '\"' + p2 + '\"');\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new JXPathException(\n                \"String_Node_Str\" + p1 + '\"' and '\" + p2 + '\"');\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "public final Object computeValue(EvalContext context) {\n</s>    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n</s>            ? Boolean.TRUE : Boolean.FALSE;\n}\n",
      "output": [
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context)) ^ Boolean.TRUE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context) < 0? Boolean.TRUE : Boolean.FALSE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return evaluate(args[0].computeValue(context), args[1].computeValue(context)) \n? Boolean.TRUE : Boolean.FALSE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].evaluate(context), args[1].evaluate(context)) \n? Boolean.TRUE : Boolean.FALSE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context) ^ args[1].computeValue(context)) \n? Boolean.TRUE : Boolean.FALSE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context)) ^ Boolean.FALSE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context)) ^ 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return compute(args[0].computeValue(context), args[1].computeValue(context) < 0? Boolean.TRUE : Boolean.FALSE);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n</s>            return equalStrings(namespaceURI, nodeNS);\n</s>        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return nodeType == Node.ELEMENT_NODE\n                        || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT :\n                return nodeType == Node.CDATA_SECTION_NODE\n                    || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT :\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI :\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}\n",
      "output": [
        {
          "patch": "            return equalStrings(namespaceURI, nodeNameTest.getNamespaceURI());\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return compareStrings(namespaceURI, nodeNS);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(namespaceURI, nodeNS, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(namespaceURI, nodeNS, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(testName.getNamespaceURI(), nodeNS);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(namespaceURI, nodeNS, testName);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(namespaceURI, nodeNS, testName.getName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(namespaceURI, nodeNS, testPrefix);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return equalStrings(testName.getName(), nodeNS);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return equalStrings(\"String_Node_Str\", namespaceURI, nodeNS);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "public int getLength() {\n</s>    return ValueUtils.getLength(getBaseValue());\n</s>}\n",
      "output": [
        {
          "patch": "    return ValueUtils.getLength(getValue());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return ValueUtils.getLength(getBaseValue(), false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getValueLength();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return ValueUtils.getLength(getBaseValue(), true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return ValueUtils.getLength(this.getValue());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return ValueUtils.getLength(this.baseValue);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return ValueUtils.getLength(value);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return ValueUtils.getLength(this.getBaseValue());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return BaseValueUtils.getLength(getBaseValue());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return ValueUtils.getLength(baseValue);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n</s>            pos += Character.charCount(Character.codePointAt(input, pos));\n</s>        }\n    }\n}\n",
      "output": [
        {
          "patch": "            pos += Character.toChars(Character.codePointAt(input, pos));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pos + 1));\n",
          "correctness": "wrong"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pos + len));\n",
          "correctness": "wrong"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pos + pt));\n",
          "correctness": "wrong"
        },
        {
          "patch": "            pos += Character.toCharCount(Character.codePointAt(input, pos));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pos + 2));\n",
          "correctness": "wrong"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pt));\n",
          "correctness": "plausible"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pos + pos));\n",
          "correctness": "wrong"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pt + 1));\n",
          "correctness": "wrong"
        },
        {
          "patch": "            pos += Character.charCount(Character.codePointAt(input, pos));\n",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n</s>            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n</s>            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}\n",
      "output": [
        {
          "patch": "            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n",
          "correctness": "plausible"
        },
        {
          "patch": "            cal1.get(Calendar.HOUR_OF_YEAR) == cal2.get(Calendar.HOUR_OF_YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n",
          "correctness": "wrong"
        },
        {
          "patch": "            cal2.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_DAY) == cal2.get(Calendar.DAY_OF_DAY) &&\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_DAY) == cal2.get(Calendar.DAY_OF_DAY) &&\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            cal1.get(Calendar.HOUR_OF_YEAR) == cal2.get(Calendar.HOUR_OF_YEAR) && cal1.get(Calendar.HOUR_OF_YEAR) == cal2.get(Calendar.HOUR_OF_YEAR) &&\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            cal2.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY) == cal2.get(Calendar.DAY) &&\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            cal2.get(Calendar.HOUR_OF_YEAR) == cal2.get(Calendar.HOUR_OF_YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            cal2.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n",
          "correctness": "plausible"
        },
        {
          "patch": "            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n",
          "correctness": "plausible"
        }
      ]
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "public String format(Date date) {\n</s>    Calendar c = new GregorianCalendar(mTimeZone);\n</s>    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}\n",
      "output": [
        {
          "patch": "    Calendar c = new GregorianCalendar(getTimeZone());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(date.getTime());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(timeZone);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(TimeZone.getDefault());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(this.mTimeZone);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(getTimeZone());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(mTimeZone);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(mTimeZone, Locale.US);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(mTime.getTime());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Calendar c = new GregorianCalendar(mTime);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_29_/src/main/java/org/apache/commons/lang3/SystemUtils.java_1672-1673": {
      "loc": "1672-1673",
      "input": "\n</s>static float toJavaVersionInt(String version) {\n</s>    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}\n",
      "output": [
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toJavaVersionInt(version);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    } else {\n        return toVersionInt(version, JAVA_VERSION_TRIM_SIZE);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toVersionInt(version);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.contains(\"String_Node_Str\")) {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toVersionInt(version);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    } else {\n        return toVersionInt(version);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toJavaVersionInt(version, JAVA_VERSION_TRIM_SIZE);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.contains(\"String_Node_Str\")) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    } else {\n        return toVersionInt(version, JAVA_VERSION_TRIM_SIZE);\n    }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (version.startsWith(\"String_Node_Str\")) {\n        return toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE);\n    } else {\n        return toVersionInt(version, JAVA_VERSION_TRIM_SIZE);\n    }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n</s>        classes[i] = array[i].getClass();\n</s>    }\n    return classes;\n}\n",
      "output": [
        {
          "patch": "        classes[i] = array[i].getClass();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (array[i]!= null) {\n            classes[i] = array[i].getClass();\n        }\n",
          "correctness": "plausible"
        },
        {
          "patch": "        classes[i] = array[i].getClass()!= null? array[i].getClass() : null;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        classes[i] = array[i].getClass() == null? null : array[i].getClass();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        classes[i] = array[i].getClass().getClassLoader();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        try {\n            classes[i] = array[i].getClass();\n        } catch (ClassCastException e) {\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (!array[i].isInterface()) {\n            classes[i] = array[i].getClass();\n        }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        classes[i] = array[i].getClass().getCanonicalName();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        Class<?> c = array[i];\n        classes[i] = c == null? null : c.getClass();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        Class<?> c = array[i].getClass();\n        classes[i] = c!= null? c : null;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n</s>    return contains(str.toUpperCase(), searchStr.toUpperCase());\n</s>}\n",
      "output": [
        {
          "patch": "    return containsIgnoreCase(str.toUpperCase(), searchStr.toUpperCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return containsIgnoreCase(str.toUpperCase(), searchStr.toUpperCase(Locale.ENGLISH));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return contains(str.toUpperCase(), searchStr.toUpperCase(Locale.ENGLISH));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return containsIgnoreCase(str.toLowerCase(), searchStr.toLowerCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return containsIgnoreCase(str.toUpperCase(), searchStr.toUpperCase(), str.toLowerCase());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return containsIgnoreCase(str.toLowerCase(), searchStr.toUpperCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return containsIgnoreCase(str.toUpperCase(), searchStr.toLowerCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return containsIgnoreCase(str.toUpperCase(), searchStr.toUpperCase(), str.toUpperCase());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return containsIgnoreCase(str.toUpperCase().toUpperCase(), searchStr.toUpperCase().toUpperCase());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return containsIgnoreCaseIgnoreCase(str.toUpperCase(), searchStr.toUpperCase());\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n</s>        return appendTo == null ? null : appendTo.append(QUOTE);\n</s>    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                    QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch (c[pos.getIndex()]) {\n        case QUOTE:\n            next(pos);\n            return appendTo == null ? null : appendTo.append(c, lastHold,\n                    pos.getIndex() - lastHold);\n        default:\n            next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + start);\n}\n",
      "output": [
        {
          "patch": "        return appendTo == null? \"String_Node_Str\" : appendTo.append(QUOTE);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE + ESCAPED_QUOTE);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE).append(QUOTE);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE_CHAR);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE + \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE.toCharArray());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return appendTo == null? null : appendTo.append(QUOTE) + ESCAPED_QUOTE;\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "public static boolean isAvailableLocale(Locale locale) {\n</s>    return cAvailableLocaleSet.contains(locale);\n</s>}\n",
      "output": [
        {
          "patch": "    return!cAvailableLocaleSet.contains(locale);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return availableLocales.contains(locale);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return cAvailableLocaleSet.contains(locale.toLowerCase(Locale.ENGLISH));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return availableLocaleSet.contains(locale);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return cAvailableLocaleSet.contains(locale.getLanguage());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return locale == null? false : cAvailableLocaleSet.contains(locale);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return cAvailableLocaleSet.contains(locale.getLocalizedName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return cAvailableLocaleSet.contains(locale.getName());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return cAvailableLocaleSet.contains(locale.toLowerCase());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (locale == null)? false : cAvailableLocaleSet.contains(locale);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n</s>            str.getChars(0, strLen, buffer, size);\n</s>        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}\n",
      "output": [
        {
          "patch": "            str.getChars(0, strLen, buffer, size, 0);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            str.getChars(0, strLen, buffer, size);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            str.getChars(0, strLen, buffer, size - 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            str = str.getChars(0, strLen, buffer, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            sb.getChars(0, strLen, buffer, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            buffer = str.getChars(0, strLen, buffer, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            str.getChars(0, size, strLen, buffer, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            bytes = str.getChars(0, strLen, buffer, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            len = str.getChars(0, strLen, buffer, size);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            str.getChars(0, strLen, buffer, size - strLen);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n</s>    int len = thisBuf.length - strLen;\n</s>    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j) != thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n",
      "output": [
        {
          "patch": "    int len = thisBuf.length - strLen - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - strLen + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - 1 - strLen;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - thisBuf.length;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - (strLen + 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - (strLen - 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int len = thisBuf.length - strLen;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length + strLen - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - strLen;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    int len = thisBuf.length - strLen - 1 - strLen;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "public double getNumericalMean() {\n</s>    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n</s>}\n",
      "output": [
        {
          "patch": "    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getProgramulationSize();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize() + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize() - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) ((getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) (mSampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (double) (sampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) (getPopulationSize() - 1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize() + 1d;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (double) (this.sampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n</s>        return NaN;\n</s>    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}\n",
      "output": [
        {
          "patch": "        return ZERO;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        returnNaN;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return ZERO_;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return ZERO.0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new IllegalArgumentException();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        returnNaN.0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new NullPointerException();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return ZERO.;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return NULL_VALUE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return null;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "public Line revert() {\n</s>    final Line reverted = new Line(zero, zero.subtract(direction));\n</s>    return reverted;\n}\n",
      "output": [
        {
          "patch": "    final Line reverted = new Line(zero, direction);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final Line reverted = new Line(zero, direction.subtract(direction));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final Line reverted = new Line(zero, direction).subtract(direction);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final Line reverted = new Line(zero, zero.subtract(direction));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final Line reverted = new Line(zero, this.zero.subtract(direction));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final Line reverted = new Line(zero, direction).subtractSelf(zero);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final Line reverted = new Line(zero, 0.subtract(direction));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final Line reverted = new Line(zero, zero.subtract(direction), direction);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final Line reverted = new Line(ZERO, zero.subtract(direction));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final Line reverted = new Line(zero, direction.add(zero));\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n</s>    return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n</s>        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}\n",
      "output": [
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2.0 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI, dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI, -dim / 2.0) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI, -dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5)",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(1 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI, 1 - dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI + dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(1.0 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return FastMath.pow(2 * FastMath.PI, -dim / 2, 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "public double[] repairAndDecode(final double[] x) {\n</s>    return\n</s>        decode(x);\n}\n",
      "output": [
        {
          "patch": "    return (Double[]) decode(x);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return Arrays.copyOf(x, x.length);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (x == null)? null : decode(x);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (Double) decode(x);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new double[] { Double.parseDouble(x) };\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return Utils.repairAndDecode(x);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (Double) repairAndDecode(x);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new double[] { 0 };\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new double[] { Double.MIN_VALUE };\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return IOUtils.decode(x, \"String_Node_Str\");\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "public double percentageValue() {\n</s>    return multiply(100).doubleValue();\n</s>}\n",
      "output": [
        {
          "patch": "    return multiply(100).doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return multiply(100.doubleValue(), 2);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return multiply(100);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return multiply(100.0).doubleValue();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return multiply(100d).doubleValue();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return multiply(100f).doubleValue();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return multiply(10).doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return multiply(100.doubleValue());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return multiply(100).doubleValue() + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return multiply(100).doubleValue() * 100;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n</s>    final int n1n2prod = n1 * n2;\n</s>\n    final double EU = n1n2prod / 2.0;\n    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n    return 2 * standardNormal.cumulativeProbability(z);\n}\n",
      "output": [
        {
          "patch": "    final int n1n2prod = (n1 + n2) / 12.0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final int n1n2prod = n1 * n2;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int n1n2prod = n1 + n2;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int n1n2prod = (n1 - n2) / 12.0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final int n1n2prod = n1 * n2 + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int n1n2prod = (n1 - 1) * n2;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int n1n2prod = (n1 * n2) / 12.0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    final double n1n2prod = n1 * n2;\n",
          "correctness": "plausible"
        },
        {
          "patch": "    final int n1n2prod = n1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final int n1n2prod = n1 * n2 - 1;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n</s>        if ((Boolean) tree.getAttribute()) {\n</s>            \n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n        if (sum < 0) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "        if (tree!= null && tree.getAttribute()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (tree!= null && (Boolean) tree.getAttribute()) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (tree.getAttribute() instanceof Boolean) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (tree!= null && ((Boolean) tree.getAttribute()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (tree.getAttribute()!= null && tree.getAttribute()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (tree.getAttribute()!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (tree.getAttribute() == null || tree.getAttribute()) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (tree.getAttribute() == null || tree.getAttribute() == null) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (tree.getAttribute() == Euclidean2D.Euclidean2D) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (tree.getAttribute()!= null && tree.getAttribute() instanceof Boolean) {\n",
          "correctness": "plausible"
        }
      ]
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n</s>        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n</s>            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}\n",
      "output": [
        {
          "patch": "        if (entry!= null &&Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (entry >= 0d &&Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (entry == null ||Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (entry!= null && precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (entry < 0d ||Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (entry!= 0d &&Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (entry < 0d &&Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (entry >= 0d && precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (entry == 0d ||Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (entry >= 0d ||Precision.compareTo(entry, 0d, maxUlps) > 0) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "public Iterator<Chromosome> iterator() {\n</s>    return chromosomes.iterator();\n</s>}\n",
      "output": [
        {
          "patch": "    synchronized (this) {\n        return chromosomes.iterator();\n    }\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.chromosomes.iterator();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return new ArrayList<Chromosome>(chromosomes.size());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return chromosomes == null? null : chromosomes.iterator();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return new HashSet<Chromosome>(chromosomes);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new ArrayList<>(chromosomes);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new CountingIterator<Chromosome>(chromosomes.size());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return chromosomes.iterator(this);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new Iterator<Chromosome>(chromosomes.iterator());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return new ArrayList<Chromosome>(chromosomes);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n</s>            for (int i = 0; i < weights.length; i++) {\n</s>                sumWts += weights[i];\n            }\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}\n",
      "output": [
        {
          "patch": "            for (int i = 0; i < weights.length - 1; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = begin; i < begin + length; i++) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "            for (int i = 0; i < weights.length - begin; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 1; i < weights.length; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 0; i < sumWts; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 0; i < values.length; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 0; i < length; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 0; i < weights.length && i < begin; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 0; i < weights.length / 2; i++) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "            for (int i = 0; i < n; i++) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n</s>    return createComplex(real + rhs.getReal(),\n</s>        imaginary + rhs.getImaginary());\n}\n",
      "output": [
        {
          "patch": "    return createComplex(real, rhs.getReal());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(real + rhs.getReal(), real + rhs.getImaginary());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(real + rhs.getReal(),Imaginary);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(real + rhs.getReal(), imaginary);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    Complex r1 = createComplex(real + rhs.getReal());\n    return r1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(real + rhs.getReal() + rhs.getImaginary());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(real + rhs.getReal(),imaginary);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(real, rhs.getReal(), rhs.getImaginary());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return createComplex(this.real + rhs.getReal(),\n",
          "correctness": "wrong"
        },
        {
          "patch": "    Complex result = createComplex(real + rhs.getReal(),\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n</s>    int idx = 1;\n    while (count < index) {\n        count += idx;\n        ++idx;\n    }\n    --idx;\n    indices[last] = idx;\n</s>\n    return indices;\n}\n",
      "output": [
        {
          "patch": "    indices[last] = count;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[index] = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[indices.length - 1] = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[last] = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[index] = count;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[last] = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[0] = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[last] = count - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[indices.length - 1] = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    indices[index] = 0;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n</s>        int sum = 0;\n</s>        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n    return resultSet;\n}\n",
      "output": [
        {
          "patch": "        double sum = 0;\n",
          "correctness": "plausible"
        },
        {
          "patch": "        final double sum = 0;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        double sum = 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        double sum = 0.0;\n",
          "correctness": "plausible"
        },
        {
          "patch": "        double sum = Double.MAX_VALUE;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        double sum = 1.0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int sum = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        long sum = 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        final double sum = 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        double sum = 1d;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n</s>    return fit(new Gaussian.Parametric(), guess);\n</s>}\n",
      "output": [
        {
          "patch": "    return fit(new Gaussian.Parametric(), guess);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(guess));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(), guess, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(), guess, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(), guess.clone());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(), guess, null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric().guess(), guess);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian().Parametric(), guess);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(guess), guess);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return fit(new Gaussian.Parametric(getObservations()));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "public static float max(final float a, final float b) {\n</s>    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n</s>}\n",
      "output": [
        {
          "patch": "    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return a <= b? b : (Float.isNaN(a + b)? Float.NEGATIVE_INFINITY : b);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (a < b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : a);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    return a <= b? b : (Float.isNaN(a + b)? Float.NaN : b);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (a <= b)? b : (Float.isInfinite(a + b)? Float.Infinite : b);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (a <= b)? b : Float.isNaN(a + b)? Float.NEGATIVE_INFINITY : b;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (a <= b)? b : (Float.isNaN(a + b)? Float.Infinite : b);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (a > b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "public static boolean equals(double x, double y) {\n</s>    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n</s>}\n",
      "output": [
        {
          "patch": "    return (Double.isNaN(x) || Double.isNaN(y)) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) || Double.isNaN(y) || Double.isInfinite(x) || Double.isNaN(y) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(x) || Double.isInfinite(y) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) && Double.isNaN(y) || Double.isInfinite(x) || Double.isNaN(y) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) || Double.isNaN(y) || Double.isInfinite(x) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) && Double.isNaN(y) || Double.isNaN(x) || Double.isInfinite(y) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(x) || Double.isNaN(y) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) || Double.isNaN(y) || x == y;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return Double.isNaN(x) && Double.isNaN(y) || Double.isNaN(x) || Double.isNaN(y) || x == y;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n</s>                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n</s>            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}\n",
      "output": [
        {
          "patch": "                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                out[i][j] = 2 * (1 - tDistribution.probability(t));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                out[i][j] = 2d * (1 - tDistribution.cumulativeProbability(t));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                out[i][j] = 2 * Math.sqrt(tDistribution.cumulativeProbability(t));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                out[i][j] = 2d * tDistribution.cumulativeProbability(t);\n",
          "correctness": "wrong"
        },
        {
          "patch": "                out[i][j] = 2 * tDistribution.probability(t);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                out[i][j] = 2 * tDistribution.cumulativeProbability(t, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                out[i][j] = 1d * (1 - tDistribution.cumulativeProbability(t));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                out[i][j] = 2 * (nObs - tDistribution.cumulativeProbability(t));\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n</s>    return solve(min, max);\n</s>}\n",
      "output": [
        {
          "patch": "    return solve(f, min, max);\n",
          "correctness": "plausible"
        },
        {
          "patch": "    return f.solve(min, max);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return solve(f.negate(), min, max);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return solve(f.min, max);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return solve(f, min, max, initial);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return solve(f.getMin(), f.getMax());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    double res = solve(min, max);\n    return res;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double s = solve(min, max);\n    return s;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return solveUnivariateRealFunction(f, min, max);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return solve(f.x, f.y, initial);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n</s>\n</s>    \n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n",
      "output": [
        {
          "patch": "    return solve(f, min, max, yMin, initial, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    solve(f, min, max, yMin, initial, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return solve(f, min, yMin, max, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return solve(f, min, yMin, max, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    solve(f, min, yMin, max, yMax, initial, yInitial);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return solve(f, min, yMin, max, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return solve(f, min, yMin, max, yMax, initial, yInitial);\n            }\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                    return solve(f, min, max, yMin, initial, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return solve(f, min, max, yMin, initial, yMax, initial, yInitial);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                return solve(f, min, max, yMin, initial, yMax, initial, yInitial);\n            }\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "@Deprecated\npublic double getPct(Object v) {\n</s>    return getCumPct((Comparable<?>) v);\n</s>}\n",
      "output": [
        {
          "patch": "    return getCumPct((Comparable<?>) v, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getCumPct((Comparable<?>) v, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return (Double) getCumPct((Comparable<?>) v);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return this.getCumPct((Comparable<?>) v);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return getCumPct(v);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return getCumPct((Comparable<?), v);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getCumPct((Comparable<?) v, true);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getCumPct((Comparable<?>) v.getClass());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getCumPct((Comparable<?) v, false);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return getCumPct((Comparable<?,?>) v);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n</s>        int j = 4 * n - 1;\n</s>        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}\n",
      "output": [
        {
          "patch": "        int j = 4 * (n - 1) - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int j = 4 * n;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int j = n - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int j = 2 * n - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int j = 4 * (n - 1) + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        final int j = 4 * n - 1;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        int j = 4 * (n - 1);\n",
          "correctness": "plausible"
        },
        {
          "patch": "        int j = 5 * n - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int j = 3 * n - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        int j = 4 * n - 1;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n</s>        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n</s>            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i; \n            }\n        }\n    }\n    return minRatioPos;\n}\n",
      "output": [
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, epsilon) <= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, epsilon) >= 0 && rhs > 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, EPSILON) >= 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (MathUtils.compareTo(rhs, 0, epsilon) >= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, epsilon) >= 0 && i!= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, minRatioPos) >= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, 1e-10) >= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareToIgnoreCase(entry, 0, epsilon) >= 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, epsilon) >= 0 && minRatioPos!= -1) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n</s>    if (fa * fb >= 0.0 ) {\n</s>        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n    return new double[]{a, b};\n}\n",
      "output": [
        {
          "patch": "    if (fa * fb > 0.0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (fa * fb > 0.0 && (b * fb > 0.0)) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (fa * fb > 0.0 && numIterations < maximumIterations) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (fa * fb > 0.0 || (fa * fb > 0.0)) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (fa * fb > 0.0 || fa * fb > 0.0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (fa * fb < 0.0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fa * fb <= 0.0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fa * fb > 0.0 || fa * fb >= 0.0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fa * fb == 0.0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (fa * fb + 1.0 >= 0.0) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "public int compareTo(Fraction object) {\n</s>    double nOd = doubleValue();\n    double dOn = object.doubleValue();\n</s>    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}\n",
      "output": [
        {
          "patch": "    double nOd = this.doubleValue();\n    double dOn = this.doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    final double nOd = doubleValue();\n    final double dOn = object.doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double nOd = object.doubleValue();\n    double dOn = object.doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double nOd = Double.valueOf(doubleValue());\n    double dOn = Double.valueOf(doubleValue);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    double nOd = (double) doubleValue();\n    double dOn = (double) object.doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double nOd = Math.abs(doubleValue());\n    double dOn = Math.abs(object.doubleValue());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double nOd = doubleValue();\n    double dOn = object.doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double nOd = Double.valueOf(doubleValue);\n    double dOn = Double.valueOf(doubleValue);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    double nOd = this.doubleValue();\n    double dOn = object.doubleValue();\n",
          "correctness": "wrong"
        },
        {
          "patch": "    double nOd = NumberFormat.getInstance().doubleValue();\n    double dOn = NumberFormat.getInstance().doubleValue();\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "public static int gcd(int u, int v) {\n</s>    if (u * v == 0) {\n</s>        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u > 0) {\n        u = -u;\n    } \n    if (v > 0) {\n        v = -v;\n    } \n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n        u /= 2;\n        v /= 2;\n        k++; \n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    do {\n        while ((t & 1) == 0) { \n            t /= 2; \n        }\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        t = (v - u) / 2;\n    } while (t != 0);\n    return -u * (1 << k); \n}\n",
      "output": [
        {
          "patch": "    if (u == 0 || v == 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if (u == 0) {\n",
          "correctness": "timeout"
        },
        {
          "patch": "    if ((u == 0) || (v == 0)) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    if ((u * v) == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (u < 0 || v < 0) {\n",
          "correctness": "timeout"
        },
        {
          "patch": "    if (u == 0 && v == 0) {\n",
          "correctness": "timeout"
        },
        {
          "patch": "    if (u <= 0 || v <= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if ((u & 1) == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (u * v == 0 || v == 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (u * v == 0 || (v == 0)) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n</s>                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n</s>            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n",
      "output": [
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary)) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary) || Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(real) || Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(real) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(real) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary)) && (Double.doubleToRawLongBits(Imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())));\n",
          "correctness": "wrong"
        },
        {
          "patch": "                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n</s>    if (\n</s>        source.substring(startIndex, endIndex).compareTo(\n        getImaginaryCharacter()) != 0) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}\n",
      "output": [
        {
          "patch": "    if (endIndex >= 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex > 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex!= -1) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex >= 0 && startIndex < endIndex) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex < 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex >= 0 && startIndex <= endIndex) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex!= -1 && endIndex!= startIndex + n) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex > startIndex) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex!= 0) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (endIndex >= 0 && startIndex < endIndex + n) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "public double getSumSquaredErrors() {\n</s>    return sumYY - sumXY * sumXY / sumXX;\n</s>}\n",
      "output": [
        {
          "patch": "    return sumYY - sumXY * sumXY / sumXX;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumYY - sumXY * sumXY;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumXX - sumXY * sumXY / sumXX;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumYY + sumXY * sumXY / sumXX;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumYY - sumXY * sumXY / sumXX + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumYY - sumXY * sumXY / sumXX - 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (sumYY - sumXY) * sumXY / sumXX;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return (sumYY - sumXY * sumXY) / sumXX;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumYY - (sumXY * sumXY) / sumXX;\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return sumXX - sumXY * sumXY;\n",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n</s>        throw new UnsupportedOperationException();\n</s>\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "        throw new UnsupportedOperationException(String.format(\"String_Node_Str\", indexOfVararg));\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(\"String_Node_Str\" + indexOfVararg);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(\"String_Node_Str\" + toString(indexOfVararg));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        throw new UnsupportedOperationException(getClass().getName());\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (indexOfVararg!= -1) {\n            throw new UnsupportedOperationException();\n        }\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(\"String_Node_Str\" + invocation.getMethod().getName());\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(\"String_Node_Str\" + \"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(String.format(\"String_Node_Str\", indexOfVararg, invocation));\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new UnsupportedOperationException(name + \"String_Node_Str\" + indexOfVararg);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n</s>        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n</s>            error = handleVerifyException(e);\n        }\n    }\n    if (error != null) {\n        throw error;\n    }\n}\n",
      "output": [
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentsNotSame e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentNotSame e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentsNotValid e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentsNotSpecified e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentNotValid e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentNotSpecified e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentNotImplemented e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentsNotDifferent e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentsNotImplemented e) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n</s>    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n</s>}\n",
      "output": [
        {
          "patch": "    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable, false));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable, typeVariable.getBounds()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable, true));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable, typeVariable));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(actualTypeArgumentFor(typeVariable));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable.getBounds()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(typeVariable.getActualTypeArgumentFor(typeVariable.getBounds()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(typeVariable.getActualTypeArgumentFor(typeVariable));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(typeVariable.getBounds().getActualTypeArgumentFor(typeVariable));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    registerTypeVariablesOn(typeVariable.getActualTypeArgumentFor(typeVariable, false));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n</s>        } else {\n</s>            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n",
      "output": [
        {
          "patch": "        } else if (actualTypeArgument instanceof WildcardType) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if (!(actualTypeArgument instanceof WildcardType)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if (actualTypeArgument!= WildcardType.ANY) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (actualTypeArgument instanceof Class<?>) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if (actualTypeArgument == WildcardType.ANY) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (actualTypeArgument instanceof VariableType) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (actualTypeArgument!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        } else if (actualTypeArgument instanceofWildcardType) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (actualTypeArgument instanceof ConstantType) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        } else if (actualTypeArgument instanceof NonWildcardType) {\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "public static boolean areEqual(Object o1, Object o2) {\n</s>    if (o1 == null || o2 == null) {\n</s>        return o1 == null && o2 == null;\n    } else if (isArray(o1)) {\n        return isArray(o2) && areArraysEqual(o1, o2);\n    } else {\n        return o1.equals(o2);\n    }\n}\n",
      "output": [
        {
          "patch": "    if (o1 == null || o2 == null)\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (o1 == null || o2 == null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (o1 == null && o2 == null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (o1 == null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (o1 == null || o2 == null ||!isArray(o1)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (o1 == null || o2 == null || isArray(o1)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (o1 == null || o2 == null || (isArray(o1))) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    if (o1 == null || o2 == null || isNull(o1)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if (o1 == null || o2 == null || isCollection(o1)) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    if ((o1 == null) && (o2 == null)) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n</s>        return 1;\n</s>    }\n    Class<?> returnType = invocation.getMethod().getReturnType();\n    return returnValueFor(returnType);\n}\n",
      "output": [
        {
          "patch": "        return \"String_Node_Str\";\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return \"String_Node_Str\" + name;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return \"String_Node_Str\" + 1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return \"String_Node_Str\" + methodName;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return \"String_Node_Str\" + 0;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        return Integer.toString(invocation.getMethod());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        return \"String_Node_Str\" + 2;\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new RuntimeException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "        throw new AssertionError(\"String_Node_Str\");\n",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n</s>    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n</s>    ((Factory) mock).setCallback(0, newFilter);\n}\n",
      "output": [
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    MockHandlerInterface<T> newMockHandler = new MockHandlerInterface<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, MockSettingsImpl.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<? extends T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<T>(newMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    methodInterceptorFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS), null);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    MockHandler<?> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n</s>        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n</s>    }\n}\n",
      "output": [
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n",
          "correctness": "wrong"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n",
          "correctness": "wrong"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance, fieldInstance).thenInject();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance, mockCandidateFilter).thenInject();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(mockCandidate);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance, mockContext).thenInject();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field.getName(), fieldInstance).thenInject();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(this);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance, mockCandidateClass).thenInject();\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(fieldInstance);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n</s>    description.appendText(wanted.toString());\n</s>    appendQuoting(description);\n    description.appendText(\")\");\n}\n",
      "output": [
        {
          "patch": "    description.appendText(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "    description.appendText(wanted.toString(Locale.ENGLISH));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    description.appendText(Math.abs(wanted.toString()));\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    description.appendText(String.valueOf(wanted.toString()));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    description.appendText(wanted);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    description.appendText(leaves.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    description.appendText(String.valueOf(wanted));\n",
          "correctness": "plausible"
        },
        {
          "patch": "    description.appendText(\"String_Node_Str\" +wanted);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    description.appendText(\"String_Node_Str\",wanted.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    description.appendText(wanted.toString(Locale.getDefault()));\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n</s>        if (m instanceof CapturesArguments) {\n</s>            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}\n",
      "output": [
        {
          "patch": "        if (m instanceof CapturesArguments &&!(m instanceof CapturesArguments)) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (m instanceof CapturesArguments && i.getArguments()!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (m instanceof CapturesArguments && i!= null) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (m instanceofCapturesArguments && i.getArguments()[k]!= null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (m instanceof CapturesArguments && k < i.getArguments().length) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (m instanceofCapturesArguments && i.getArguments()[k] == null) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (m.getArguments()[k] instanceof CapturesArguments) {\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        if (m instanceof CapturesArguments && i.getArguments().length > k) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "        if (m instanceof CapturesArguments || m instanceof CapturesArguments) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "        if (m instanceof CapturesArguments &&!(i instanceof CapturesArguments)) {\n",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "private boolean toStringEquals(Matcher m, Object arg) {\n</s>    return StringDescription.toString(m).equals(arg.toString());\n</s>}\n",
      "output": [
        {
          "patch": "    return StringDescription.toString(m).equalsIgnoreCase(arg.toString());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return StringDescription.toString(m).equals(arg);\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return StringUtils.equals(StringDescription.toString(m), arg);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return Objects.equals(StringDescription.toString(m), arg.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\".equals(m.toString());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return \"String_Node_Str\" + StringDescription.toString(m).equals(arg);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return StringDescription.toString(matcher).equals(arg.toString());\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "    return \"String_Node_Str\".equals(StringDescription.toString(m));\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return m == null? false : StringDescription.toString(m).equals(arg.toString());\n",
          "correctness": "wrong"
        },
        {
          "patch": "    return!StringDescription.toString(m).equals(arg.toString());\n",
          "correctness": "wrong"
        }
      ]
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n</s>            return -val1;\n</s>        case 0:\n            return 0L;\n        case 1:\n            return val1;\n    }\n    long total = val1 * val2;\n    if (total / val2 != val1) {\n      throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return total;\n}\n",
      "output": [
        {
          "patch": "            return 0L;\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return val1;\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return Double.MAX_VALUE;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return -1L;\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return Long.valueOf(val1);\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return Double.valueOf(val1);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return Double.NaN;\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "            return Long.MAX_VALUE;\n",
          "correctness": "wrong"
        },
        {
          "patch": "            throw new IllegalArgumentException(\"String_Node_Str\");\n",
          "correctness": "wrong"
        },
        {
          "patch": "            return Math.abs(val1);\n",
          "correctness": "wrong"
        }
      ]
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n</s>        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n</s>    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}\n",
      "output": [
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iOffsetParsed);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iDate);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iDayOfMonth);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, locale);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iYearOffset);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, locale, iPivotYear, defaultYear);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iLocale);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iDayOfYear);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, iYear);\n",
          "correctness": "uncompilable"
        },
        {
          "patch": "        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear, timeZone);\n",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n</s>    } else if (offsetLocal > 0) {\n</s>        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}\n",
      "output": [
        {
          "patch": "    } else if (offsetLocal >= 0) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    } else if ((offsetLocal - offsetAdjusted) < 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (offsetLocal < 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (offsetLocal < instantAdjusted) {\n",
          "correctness": "plausible"
        },
        {
          "patch": "    } else if (offsetLocal > instantAdjusted) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (offsetLocal > 0 && instantAdjusted > offsetLocal) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (offsetLocal <= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (offsetLocal!= 0) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    } else if (offsetLocal > 0 && offsetLocal < instantAdjusted) {\n",
          "correctness": "wrong"
        },
        {
          "patch": "    }\n    if ((offsetLocal - offsetAdjusted) < 0) {\n",
          "correctness": "wrong"
        }
      ]
    }
  }
}