{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-48",
    "Time": {
        "mean": 468.16119611263275,
        "median": 468.16119611263275,
        "std": 0,
        "max": 468.16119611263275,
        "min": 468.16119611263275,
        "count": 1
    },
    "Joules": {
        "mean": 60250.814694249624,
        "median": 60250.814694249624,
        "std": 0,
        "max": 60250.814694249624,
        "min": 60250.814694249624,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 26590.63701275586,
        "median": 26590.63701275586,
        "std": 0,
        "max": 26590.63701275586,
        "min": 26590.63701275586,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        57.37252938747406,
        108.7211127281189,
        160.06969606876373,
        211.41827940940857,
        262.7668627500534,
        314.11544609069824,
        365.4640294313431,
        416.8126127719879,
        468.16119611263275
    ],
    "Joules_Per_PatchMedian": [
        11994.299106156826,
        18026.363554668427,
        24058.42800318003,
        30090.49245169163,
        36122.55690020323,
        42154.62134871483,
        48186.685797226426,
        54218.750245738025,
        60250.814694249624
    ],
    "JoulesNormalized_Per_PatchMedian": [
        4105.879065501688,
        6916.47380890846,
        9727.068552315231,
        12537.663295722003,
        15348.258039128774,
        18158.852782535545,
        20969.447525942316,
        23780.042269349087,
        26590.63701275586
    ],
    "Inf_ExecutionTime": {
        "mean": 6.0235960483551025,
        "median": 6.023946046829224,
        "std": 0.004266649786789741,
        "max": 6.0283849239349365,
        "min": 6.017954111099243,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 5945.1637301564215,
        "median": 5962.2346576452255,
        "std": 71.21441221544391,
        "max": 6037.8147417545315,
        "min": 5843.414946544171,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 1286.3786218047142,
        "median": 1295.2843220949162,
        "std": 64.65058248043712,
        "max": 1352.9622148990638,
        "min": 1178.8987150311468,
        "count": 5
    },
    "Val_ExecutionTime": [
        51.348583340644836,
        102.69716668128967,
        154.0457500219345,
        205.39433336257935,
        256.7429167032242,
        308.091500043869,
        359.44008338451385,
        410.7886667251587,
        462.1372500658035
    ],
    "Val_Joules": [
        6032.064448511601,
        12064.128897023202,
        18096.193345534804,
        24128.257794046403,
        30160.322242558002,
        36192.3866910696,
        42224.4511395812,
        48256.5155880928,
        54288.5800366044
    ],
    "Val_JoulesNormalized": [
        2810.594743406772,
        5621.189486813544,
        8431.784230220315,
        11242.378973627086,
        14052.973717033858,
        16863.568460440627,
        19674.163203847398,
        22484.75794725417,
        25295.35269066094
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong"
    ],
    "patches": [
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        inferred = !(info != null || !scope.isDeclared(qName, false));\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (inferred && rhsValue != null &&\n          rhsValue.isFunction() &&\n          (info != null || !scope.isDeclared(qName, false))) {\n        inferred = false;\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (!(rhsValue != null &&\n          rhsValue.isFunction() &&\n          (info != null || !scope.isDeclared(qName, false)))) {\n        inferred = false;\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (rhsValue != null &&\n          rhsValue.isFunction() &&\n          (info != null || !scope.isDeclared(qName, false))) {\n        inferred = false;\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (!scope.isDeclared(qName, false)) {\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (rhsValue != null && rhsValue.isFunction() &&\n          (info != null || !scope.isDeclared(qName, false))) {\n        inferred = false;\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     inferred = !(rhsValue != null &&\n          rhsValue.isFunction() &&\n          (info != null || !scope.isDeclared(qName, false)));\n      if (inferred) {\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (info != null) {\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      } else {\n        inferred = false;\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     if (info != null) {\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      } else {\n        inferred = !(rhsValue != null && rhsValue.isFunction());\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n// buggy code\n//       if (inferred) {\n//         inferred = !(rhsValue != null &&\n//             rhsValue.isFunction() &&\n//             (info != null || !scope.isDeclared(qName, false)));\n     boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (isExtern || !scope.isDeclared(qName, false)));\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n"
    ]
}