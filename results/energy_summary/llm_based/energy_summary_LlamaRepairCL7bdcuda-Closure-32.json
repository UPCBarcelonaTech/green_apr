{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-32",
    "Time": {
        "mean": 14.234074115753174,
        "median": 14.234074115753174,
        "std": 0,
        "max": 14.234074115753174,
        "min": 14.234074115753174,
        "count": 1
    },
    "Joules": {
        "mean": 14108.792358303072,
        "median": 14108.792358303072,
        "std": 0,
        "max": 14108.792358303072,
        "min": 14108.792358303072,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 3268.0531192064263,
        "median": 3268.0531192064263,
        "std": 0,
        "max": 3268.0531192064263,
        "min": 3268.0531192064263,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [],
    "Joules_Per_PatchMedian": [],
    "JoulesNormalized_Per_PatchMedian": [],
    "Inf_ExecutionTime": {
        "mean": 14.2267982006073,
        "median": 14.234074115753174,
        "std": 0.014995451821435118,
        "max": 14.241137981414795,
        "min": 14.208069801330566,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 14074.745559723377,
        "median": 14108.792358303072,
        "std": 70.75730978501612,
        "max": 14112.590099179744,
        "min": 13949.092089617254,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 3277.2501614737503,
        "median": 3268.0531192064263,
        "std": 97.54482513272698,
        "max": 3421.792459452152,
        "min": 3177.2687055587758,
        "count": 5
    },
    "Val_ExecutionTime": [],
    "Val_Joules": [],
    "Val_JoulesNormalized": [],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (true) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n                     builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (token != JsDocToken.EOC) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          break;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          break;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (true) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          break;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          break;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n                     builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   do {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n            int endL          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (token != JsDocToken.EOC) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          break;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          break;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (token != JsDocToken.EOC &&\n           token != JsDocToken.EOF) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE)          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
        "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n// buggy code\n//     do {\n//       switch (token) {\n//         case STAR:\n//           if (ignoreStar) {\n//           } else {\n//             if (builder.length() > 0) {\n//               builder.append(' ');\n//             }\n//             builder.append('*');\n//           }\n//           token = next();\n//           continue;\n//         case EOL:\n//           if (option != WhitespaceOption.SINGLE_LINE) {\n//             builder.append(\"\\n\");\n//           }\n//           ignoreStar = true;\n//           token = next();\n//           continue;\n//         default:\n//           ignoreStar = false;\n//           state = State.SEARCHING_ANNOTATION;\n//           if (token == JsDocToken.EOC ||\n//               token == JsDocToken.EOF ||\n//               (token == JsDocToken.ANNOTATION &&\n//                option != WhitespaceOption.PRESERVE)) {\n//             String multilineText = builder.toString();\n//             if (option != WhitespaceOption.PRESERVE) {\n//               multilineText = multilineText.trim();\n//             }\n//             int endLineno = stream.getLineno();\n//             int endCharno = stream.getCharno();\n//             if (multilineText.length() > 0) {\n//               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n//                   endLineno, endCharno);\n//             }\n//             return new ExtractionInfo(multilineText, token);\n//           }\n//           if (builder.length() > 0) {\n//             builder.append(' ');\n//           }\n   while (true) {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = trimEnd(multilineText);\n            }\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n"
    ]
}