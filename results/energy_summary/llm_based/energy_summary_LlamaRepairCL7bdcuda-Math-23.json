{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Math-23",
    "Time": {
        "mean": 16.36614990234375,
        "median": 16.36614990234375,
        "std": 0,
        "max": 16.36614990234375,
        "min": 16.36614990234375,
        "count": 1
    },
    "Joules": {
        "mean": 15722.05777103901,
        "median": 15722.05777103901,
        "std": 0,
        "max": 15722.05777103901,
        "min": 15722.05777103901,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 3368.887824749947,
        "median": 3368.887824749947,
        "std": 0,
        "max": 3368.887824749947,
        "min": 3368.887824749947,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [],
    "Joules_Per_PatchMedian": [],
    "JoulesNormalized_Per_PatchMedian": [],
    "Inf_ExecutionTime": {
        "mean": 15.901490736007691,
        "median": 16.36614990234375,
        "std": 1.0139502314024789,
        "max": 16.891983032226562,
        "min": 14.792389869689941,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 15421.76274889946,
        "median": 15722.05777103901,
        "std": 905.0361123014791,
        "max": 16275.192226433752,
        "min": 14427.607951831818,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 3390.3217088985434,
        "median": 3368.887824749947,
        "std": 169.86907526838218,
        "max": 3656.371839070316,
        "min": 3225.3311035156257,
        "count": 5
    },
    "Val_ExecutionTime": [],
    "Val_Joules": [],
    "Val_JoulesNormalized": [],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = 1;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = 1;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) {\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = -1;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n                                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       long iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = 1; \n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q =                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = 1;\n        while (iter <= getMaxEvaluations()) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n       int iter = 1;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                return best(current, previous, isMinim);\n            }\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) { \n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n// buggy code\n//         int iter = 0;\n//         while (true) {\n//             final double m = 0.5 * (a + b);\n//             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n//             final double tol2 = 2 * tol1;\n//             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n//             if (!stop) {\n//                 double p = 0;\n//                 double q = 0;\n//                 double r = 0;\n//                 double u = 0;\n//                 if (FastMath.abs(e) > tol1) { \n//                     r = (x - w) * (fx - fv);\n//                     q = (x - v) * (fx - fw);\n//                     p = (x - v) * q - (x - w) * r;\n//                     q = 2 * (q - r);\n//                     if (q > 0) {\n//                         p = -p;\n//                     } else {\n//                         q = -q;\n//                     }\n//                     r = e;\n//                     e = d;\n//                     if (p > q * (a - x) &&\n//                         p < q * (b - x) &&\n//                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n//                         d = p / q;\n//                         u = x + d;\n//                         if (u - a < tol2 || b - u < tol2) {\n//                             if (x <= m) {\n//                                 d = tol1;\n//                             } else {\n//                                 d = -tol1;\n//                             }\n//                         }\n//                     } else {\n//                         if (x < m) {\n//                             e = b - x;\n//                         } else {\n//                             e = a - x;\n//                         }\n//                         d = GOLDEN_SECTION * e;\n//                     }\n//                 } else {\n//                     if (x < m) {\n//                         e = b - x;\n//                     } else {\n//                         e = a - x;\n//                     }\n//                     d = GOLDEN_SECTION * e;\n//                 }\n//                 if (FastMath.abs(d) < tol1) {\n//                     if (d >= 0) {\n//                         u = x + tol1;\n//                     } else {\n//                         u = x - tol1;\n//                     }\n//                 } else {\n//                     u = x + d;\n//                 }\n//                 double fu = computeObjectiveValue(u);\n//                 if (!isMinim) {\n//                     fu = -fu;\n//                 }\n//                 previous = current;\n//                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n//                 if (checker != null) {\n//                     if (checker.converged(iter, previous, current)) {\n//                         return best(current, previous, isMinim);\n//                     }\n//                 }\n//                 if (fu <= fx) {\n//                     if (u < x) {\n//                         b = x;\n//                     } else {\n//                         a = x;\n//                     }\n//                     v = w;\n//                     fv = fw;\n//                     w = x;\n//                     fw = fx;\n//                     x = u;\n//                     fx = fu;\n//                 } else {\n//                     if (u < x) {\n//                         a = u;\n//                     } else {\n//                         b = u;\n//                     }\n//                     if (fu <= fw ||\n//                         Precision.equals(w, x)) {\n//                         v = w;\n//                         fv = fw;\n//                         w = u;\n//                         fw = fu;\n//                     } else if (fu <= fv ||\n//                                Precision.equals(v, x) ||\n//                                Precision.equals(v, w)) {\n//                         v = u;\n//                         fv = fu;\n//                     }\n//                 }\n//             } else { \n//                 return\n//                             best(current,\n//                                  previous,\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n"
    ]
}