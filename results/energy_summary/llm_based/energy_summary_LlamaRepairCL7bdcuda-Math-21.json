{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Math-21",
    "Time": {
        "mean": 13.815087080001831,
        "median": 13.815087080001831,
        "std": 0,
        "max": 13.815087080001831,
        "min": 13.815087080001831,
        "count": 1
    },
    "Joules": {
        "mean": 13718.047689473628,
        "median": 13718.047689473628,
        "std": 0,
        "max": 13718.047689473628,
        "min": 13718.047689473628,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 3194.8154369115837,
        "median": 3194.8154369115837,
        "std": 0,
        "max": 3194.8154369115837,
        "min": 3194.8154369115837,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [],
    "Joules_Per_PatchMedian": [],
    "JoulesNormalized_Per_PatchMedian": [],
    "Inf_ExecutionTime": {
        "mean": 14.569227457046509,
        "median": 13.815087080001831,
        "std": 1.0744196182831178,
        "max": 15.892822980880737,
        "min": 13.769103050231934,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 14185.595403811933,
        "median": 13718.047689473628,
        "std": 745.3333173065332,
        "max": 15127.14693095684,
        "min": 13587.657050442696,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 3224.1173912692075,
        "median": 3194.8154369115837,
        "std": 61.26344416646693,
        "max": 3322.4600240349755,
        "min": 3168.5760616779335,
        "count": 5
    },
    "Val_ExecutionTime": [],
    "Val_Joules": [],
    "Val_JoulesNormalized": [],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       final int[] swap  = new int[order];\n        final int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] swap  = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] swap = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n                ++r;\n                loop = false;\n            } else {\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                                   for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            final int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n                ++r;\n                loop = false;\n            } else {\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] swap = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            int swap = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap = i;\n                }\n            }\n            if (swap != r) {\n                int tmp = index[r];\n                index[r] = index[swap];\n                index[swap] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int i = r; i < order; ++i)                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            int swap  = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap = i;\n                }\n            }\n            if (swap != r) {\n                int tmp = index[r];\n                index[r] = index[swap];\n                index[swap] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int i = r; i < order; ++i                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       final int[] swap  = new int[order];\n        final int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n            if (swap[r] != r) {\n                final int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
        "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n// buggy code\n//         int[] swap  = new int[order];\n//         int[] index = new int[order];\n//         for (int i = 0; i < order; ++i) {\n//             index[i] = i;\n//         }\n//         int r = 0;\n//         for (boolean loop = true; loop;) {\n//             swap[r] = r;\n//             for (int i = r + 1; i < order; ++i) {\n//                 int ii  = index[i];\n//                 int isi = index[swap[i]];\n//                 if (c[ii][ii] > c[isi][isi]) {\n//                     swap[r] = i;\n//                 }\n//             }\n//             if (swap[r] != r) {\n//                 int tmp = index[r];\n//                 index[r] = index[swap[r]];\n//                 index[swap[r]] = tmp;\n//             }\n//             int ir = index[r];\n//             if (c[ir][ir] < small) {\n//                 if (r == 0) {\n//                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n//                 }\n//                 for (int i = r; i < order; ++i) {\n//                     if (c[index[i]][index[i]] < -small) {\n//                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n//                     }\n//                 }\n//                 ++r;\n//                 loop = false;\n//             } else {\n//                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n//                 b[r][r] = sqrt;\n//                 final double inverse  = 1 / sqrt;\n//                 for (int i = r + 1; i < order; ++i) {\n//                     final int ii = index[i];\n//                     final double e = inverse * c[ii][ir];\n//                     b[i][r] = e;\n//                     c[ii][ii] -= e * e;\n       int[] swap  = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (FastMath.abs(c[ii][ii]) > FastMath.abs(c[isi][isi])) {\n                    swap[r] = i;\n                }\n            }\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n            int ir = index[r];\n            if (FastMath.abs(c[ir][ir]) < small) {\n                if (r == 0) {                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n"
    ]
}