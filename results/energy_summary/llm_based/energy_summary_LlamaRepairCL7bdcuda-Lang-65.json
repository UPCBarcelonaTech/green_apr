{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Lang-65",
    "Time": {
        "mean": 20.929330348968506,
        "median": 20.929330348968506,
        "std": 0,
        "max": 20.929330348968506,
        "min": 20.929330348968506,
        "count": 1
    },
    "Joules": {
        "mean": 11726.878020220995,
        "median": 11726.878020220995,
        "std": 0,
        "max": 11726.878020220995,
        "min": 11726.878020220995,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 2442.7698751270777,
        "median": 2442.7698751270777,
        "std": 0,
        "max": 2442.7698751270777,
        "min": 2442.7698751270777,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        20.929330348968506
    ],
    "Joules_Per_PatchMedian": [
        11726.878020220995
    ],
    "JoulesNormalized_Per_PatchMedian": [
        2442.7698751270777
    ],
    "Inf_ExecutionTime": {
        "mean": 11.375990152359009,
        "median": 11.359829902648926,
        "std": 0.17898364445704648,
        "max": 11.595997095108032,
        "min": 11.1528959274292,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 10908.714830117226,
        "median": 10886.141082262993,
        "std": 147.7509755768907,
        "max": 11080.585703122615,
        "min": 10693.131139099598,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 2231.8126970911026,
        "median": 2196.2417031049736,
        "std": 94.87220076472096,
        "max": 2343.240972554684,
        "min": 2112.0930125355717,
        "count": 5
    },
    "Val_ExecutionTime": [
        9.56950044631958
    ],
    "Val_Joules": [
        840.7369379580014
    ],
    "Val_JoulesNormalized": [
        246.52817202210417
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "wrong",
        "wrong",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset = 0;\n            boolean offsetSet = false;\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       } else {\n            boolean roundUp = false;\n            for (int i = 0; i < fields.length; i++) {\n                for (int j = 0; j < fields[i].length; j++) {\n                    if (fields[i][j] == field) {\n                        if (round && roundUp) {\n                            if (field == DateUtils.SEMI_MONTH) {\n                                if (val.get(Calendar.DATE) == 1) {\n                                    val.add(Calendar.DATE, 15);\n                                } else {\n                                    val.add(Calendar.DATE, -15);\n                                    val.add(Calendar.MONTH, 1);\n                                }\n                            } else {\n                                val.add(fields[i][0], 1);\n                            }\n                        }\n                        return;\n                    }\n                }\n                int offset = 0;\n                boolean offsetSet = false;\n                switch (field) {\n                    case DateUtils.SEMI_MONTH:\n                        if (fields[        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       } else if (val.get(Calendar.YEAR) < -280000000) {\n            throw new ArithmeticException(\"Calendar value too small for accurate calculations\");\n        }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset =         }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       } else if (val.get(Calendar.YEAR) < -280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset =         }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       }\n        if (round) {\n            boolean roundUp = false;\n            for (int i = 0; i < fields.length; i++) {\n                for (int j = 0; j < fields[i].length; j++) {\n                    if (fields[i][j] == field) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                        return;\n                    }\n                }\n                int offset = 0;\n                boolean offsetSet = false;\n                switch (field) {\n                    case DateUtils.SEMI_MONTH:\n                        if (fields[i][0] == Calendar.DATE) {\n                                   }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       } else if (val.get(Calendar.YEAR) < 0) {\n            throw new ArithmeticException(\"Calendar value too small for accurate calculations\");\n        }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset = 0;\n            boolean offsetSet =        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       }\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       }\n        if (round) {\n            boolean roundUp = false;\n            for (int i = 0; i < fields.length; i++) {\n                for (int j = 0; j < fields[i].length; j++) {\n                    if (fields[i][j] == field) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                }\n                int offset = 0;\n                boolean offsetSet = false;\n                switch (field) {\n                    case DateUtils.SEMI_MONTH:\n                        if (fields[i][0] == Calendar.DATE) {\n                            offset = val.get        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset = 0;\n            boolean offsetSet = false;\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
        "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n// buggy code\n//         }\n//         boolean roundUp = false;\n//         for (int i = 0; i < fields.length; i++) {\n//             for (int j = 0; j < fields[i].length; j++) {\n//                 if (fields[i][j] == field) {\n//                     if (round && roundUp) {\n//                         if (field == DateUtils.SEMI_MONTH) {\n//                             if (val.get(Calendar.DATE) == 1) {\n//                                 val.add(Calendar.DATE, 15);\n//                             } else {\n//                                 val.add(Calendar.DATE, -15);\n//                                 val.add(Calendar.MONTH, 1);\n//                             }\n//                         } else {\n//                             val.add(fields[i][0], 1);\n//                         }\n//                     }\n//                     return;\n//                 }\n//             }\n//             int offset = 0;\n//             boolean offsetSet = false;\n//             switch (field) {\n//                 case DateUtils.SEMI_MONTH:\n//                     if (fields[i][0] == Calendar.DATE) {\n//                         offset = val.get(Calendar.DATE) - 1;\n//                         if (offset >= 15) {\n//                             offset -= 15;\n//                         }\n//                         roundUp = offset > 7;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//                 case Calendar.AM_PM:\n//                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//                         offset = val.get(Calendar.HOUR_OF_DAY);\n//                         if (offset >= 12) {\n//                             offset -= 12;\n//                         }\n//                         roundUp = offset > 6;\n//                         offsetSet = true;\n//                     }\n//                     break;\n//             }\n//             if (!offsetSet) {\n//                 int min = val.getActualMinimum(fields[i][0]);\n//                 int max = val.getActualMaximum(fields[i][0]);\n//                 offset = val.get(fields[i][0]) - min;\n//                 roundUp = offset > ((max - min) / 2);\n//             }\n//                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n       }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset = 0;\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        offset = val        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n"
    ]
}