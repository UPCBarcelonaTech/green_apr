{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-14",
    "Time": {
        "mean": 175.24276995658875,
        "median": 175.24276995658875,
        "std": 0,
        "max": 175.24276995658875,
        "min": 175.24276995658875,
        "count": 1
    },
    "Joules": {
        "mean": 28566.780024361608,
        "median": 28566.780024361608,
        "std": 0,
        "max": 28566.780024361608,
        "min": 28566.780024361608,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 11544.821437031029,
        "median": 11544.821437031029,
        "std": 0,
        "max": 11544.821437031029,
        "min": 11544.821437031029,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        64.18490195274353,
        119.71383595466614,
        175.24276995658875
    ],
    "Joules_Per_PatchMedian": [
        15211.758842492103,
        21889.269433426856,
        28566.780024361608
    ],
    "JoulesNormalized_Per_PatchMedian": [
        5239.796026867628,
        8392.308731949328,
        11544.821437031029
    ],
    "Inf_ExecutionTime": {
        "mean": 8.652905607223511,
        "median": 8.655967950820923,
        "std": 0.008441096752432351,
        "max": 8.661091089248657,
        "min": 8.641118049621582,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 8529.459553053379,
        "median": 8534.24825155735,
        "std": 85.27414589769506,
        "max": 8633.975731503964,
        "min": 8428.786369466781,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 2057.8133127856254,
        "median": 2087.283321785927,
        "std": 85.20403794482007,
        "max": 2152.20511534214,
        "min": 1955.8127712249734,
        "count": 5
    },
    "Val_ExecutionTime": [
        55.52893400192261,
        111.05786800384521,
        166.58680200576782
    ],
    "Val_Joules": [
        6677.510590934753,
        13355.021181869506,
        20032.531772804257
    ],
    "Val_JoulesNormalized": [
        3152.512705081701,
        6305.025410163401,
        9457.538115245101
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "wrong",
        "wrong",
        "uncompilable",
        "wrong",
        "wrong",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "wrong",
        "wrong"
    ],
    "patches": [
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(finallyNode, Branch.UNCOND, fromNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.RETURN, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(node, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.NORMAL, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.FINALLY, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.RET, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(parent, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.UNCOND, finallyNode,\n                  false);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.UNCOND, finallyNode,\n                  \"finally\");\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n// buggy code\n//               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             cfa.createEdge(fromNode, Branch.UNCOND, finallyNode,\n                  false, false);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n"
    ]
}