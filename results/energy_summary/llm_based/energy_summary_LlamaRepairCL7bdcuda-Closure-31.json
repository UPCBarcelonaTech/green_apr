{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-31",
    "Time": {
        "mean": 328.4429931640625,
        "median": 328.4429931640625,
        "std": 0,
        "max": 328.4429931640625,
        "min": 328.4429931640625,
        "count": 1
    },
    "Joules": {
        "mean": 43597.19380136729,
        "median": 43597.19380136729,
        "std": 0,
        "max": 43597.19380136729,
        "min": 43597.19380136729,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 19436.83107303381,
        "median": 19436.83107303381,
        "std": 0,
        "max": 19436.83107303381,
        "min": 19436.83107303381,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        58.398157954216,
        112.4071249961853,
        166.4160920381546,
        220.4250590801239,
        274.4340261220932,
        328.4429931640625
    ],
    "Joules_Per_PatchMedian": [
        10881.035762929918,
        17424.267370617392,
        23967.498978304866,
        30510.73058599234,
        37053.962193679814,
        43597.19380136729
    ],
    "JoulesNormalized_Per_PatchMedian": [
        4089.7306991100318,
        7159.150773894788,
        10228.570848679543,
        13297.990923464298,
        16367.410998249054,
        19436.83107303381
    ],
    "Inf_ExecutionTime": {
        "mean": 4.385826206207275,
        "median": 4.389190912246704,
        "std": 0.005340500983279441,
        "max": 4.390002965927124,
        "min": 4.379825115203857,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 4350.11611307621,
        "median": 4337.804155242444,
        "std": 20.76598993987244,
        "max": 4381.904338479042,
        "min": 4334.39135812521,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 1016.7527666044236,
        "median": 1020.3106243252764,
        "std": 33.36371520936938,
        "max": 1059.5501158475872,
        "min": 975.691545712948,
        "count": 5
    },
    "Val_ExecutionTime": [
        54.0089670419693,
        108.0179340839386,
        162.0269011259079,
        216.0358681678772,
        270.0448352098465,
        324.0538022518158
    ],
    "Val_Joules": [
        6543.231607687474,
        13086.463215374948,
        19629.694823062422,
        26172.926430749896,
        32716.15803843737,
        39259.38964612485
    ],
    "Val_JoulesNormalized": [
        3069.4200747847553,
        6138.840149569511,
        9208.260224354266,
        12277.680299139021,
        15347.100373923777,
        18416.520448708532
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "I",
        "W",
        "C",
        "W",
        "W",
        "I",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "uncompilable",
        "correct",
        "uncompilable",
        "wrong"
    ],
    "patches": [
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses &&\n          !options.processCommonJSModules &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses ||\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses) {\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses &&\n          !options.onlyClosurePass &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses && !options.processCommonJSModules &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         options.skipAllPasses ||\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses &&\n          !options.manageDependencies &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n// buggy code\n//           !options.skipAllPasses &&\n         !options.skipAllPasses && !options.closurePass) {\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"
    ]
}