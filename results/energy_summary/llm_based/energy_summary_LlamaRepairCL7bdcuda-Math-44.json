{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Math-44",
    "Time": {
        "mean": 13.7603280544281,
        "median": 13.7603280544281,
        "std": 0,
        "max": 13.7603280544281,
        "min": 13.7603280544281,
        "count": 1
    },
    "Joules": {
        "mean": 13663.438036167621,
        "median": 13663.438036167621,
        "std": 0,
        "max": 13663.438036167621,
        "min": 13663.438036167621,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 3038.792121279239,
        "median": 3038.792121279239,
        "std": 0,
        "max": 3038.792121279239,
        "min": 3038.792121279239,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [],
    "Joules_Per_PatchMedian": [],
    "JoulesNormalized_Per_PatchMedian": [],
    "Inf_ExecutionTime": {
        "mean": 14.473374080657958,
        "median": 13.7603280544281,
        "std": 0.9824589704253146,
        "max": 15.561012983322144,
        "min": 13.751144170761108,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 14138.408315811157,
        "median": 13663.438036167621,
        "std": 733.7448754086186,
        "max": 14957.758483374118,
        "min": 13571.972024309634,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 3030.0696896171567,
        "median": 3038.792121279239,
        "std": 145.12882276751338,
        "max": 3194.6580439209956,
        "min": 2804.28697066307,
        "count": 5
    },
    "Val_ExecutionTime": [],
    "Val_Joules": [],
    "Val_JoulesNormalized": [],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           isLastStep = false;\n            resetOccurred = false;\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           resetOccurred = true;\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           boolean resetOccurred = false;\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = current                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           boolean resetOccurred = false;\n            resetOccurred = false;\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           statesInitialized = false;\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           if (!statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n// buggy code\n//             resetOccurred = false;\n//             if (! statesInitialized) {\n//                 for (EventState state : eventsStates) {\n//                     state.reinitializeBegin(interpolator);\n//                 }\n//                 statesInitialized = true;\n//             }\n//             final int orderingSign = interpolator.isForward() ? +1 : -1;\n//             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n//                 public int compare(EventState es0, EventState es1) {\n//                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n//                 }\n//             });\n//             for (final EventState state : eventsStates) {\n//                 if (state.evaluateStep(interpolator)) {\n//                     occuringEvents.add(state);\n//                 }\n//             }\n//             while (!occuringEvents.isEmpty()) {\n//                 final Iterator<EventState> iterator = occuringEvents.iterator();\n//                 final EventState currentEvent = iterator.next();\n//                 iterator.remove();\n//                 final double eventT = currentEvent.getEventTime();\n//                 interpolator.setSoftPreviousTime(previousT);\n//                 interpolator.setSoftCurrentTime(eventT);\n//                 interpolator.setInterpolatedTime(eventT);\n//                 final double[] eventY = interpolator.getInterpolatedState();\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     return eventT;\n//                 }\n//                 if (currentEvent.reset(eventT, eventY)) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n           if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            boolean resetOccurred = false;\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = current                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n"
    ]
}