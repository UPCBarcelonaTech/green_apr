{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-105",
    "Time": {
        "mean": 189.37669348716736,
        "median": 189.37669348716736,
        "std": 0,
        "max": 189.37669348716736,
        "min": 189.37669348716736,
        "count": 1
    },
    "Joules": {
        "mean": 27035.65682329535,
        "median": 27035.65682329535,
        "std": 0,
        "max": 27035.65682329535,
        "min": 27035.65682329535,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 10641.046347171068,
        "median": 10641.046347171068,
        "std": 0,
        "max": 10641.046347171068,
        "min": 10641.046347171068,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        33.01870656013489,
        59.07837104797363,
        85.13803553581238,
        111.19770002365112,
        137.25736451148987,
        163.3170289993286,
        189.37669348716736
    ],
    "Joules_Per_PatchMedian": [
        9665.576213866472,
        12560.589648771285,
        15455.603083676098,
        18350.61651858091,
        21245.629953485724,
        24140.643388390537,
        27035.65682329535
    ],
    "JoulesNormalized_Per_PatchMedian": [
        2786.410272926092,
        4095.516285300255,
        5404.6222976744175,
        6713.72831004858,
        8022.834322422743,
        9331.940334796906,
        10641.046347171068
    ],
    "Inf_ExecutionTime": {
        "mean": 6.956385517120362,
        "median": 6.959042072296143,
        "std": 0.012412614825825976,
        "max": 6.972152948379517,
        "min": 6.940254211425781,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 6788.472065386773,
        "median": 6770.562778961659,
        "std": 105.14950077638828,
        "max": 6969.278190493584,
        "min": 6702.382749128342,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 1511.6348588562007,
        "median": 1477.3042605519295,
        "std": 96.22671583694,
        "max": 1682.1598481893534,
        "min": 1447.22226023674,
        "count": 5
    },
    "Val_ExecutionTime": [
        26.059664487838745,
        52.11932897567749,
        78.17899346351624,
        104.23865795135498,
        130.29832243919373,
        156.35798692703247,
        182.41765141487122
    ],
    "Val_Joules": [
        2895.013434904813,
        5790.026869809626,
        8685.04030471444,
        11580.053739619252,
        14475.067174524065,
        17370.08060942888,
        20265.09404433369
    ],
    "Val_JoulesNormalized": [
        1309.1060123741627,
        2618.2120247483253,
        3927.318037122488,
        5236.424049496651,
        6545.530061870813,
        7854.636074244976,
        9163.742086619139
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong"
    ],
    "patches": [
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        foldedSize += NodeUtil.getStringValue(elem).length();\n      } else {\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    StringBuilder sb = new StringBuilder();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      foldedSize += sb.length() + 2;\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    StringBuilder sb = new StringBuilder();\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      foldedSize += sb.length() + 2;\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   StringBuffer sb = new StringBuffer();\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuffer();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      sb.append(joinString);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    StringBuilder sb = new StringBuilder();\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      foldedSize += sb.length();\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    StringBuilder sb = new StringBuilder();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      foldedSize += sb.length();\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        foldedSize += NodeUtil.getStringValue(elem).length();\n      } else {\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (joinString != null) {\n      foldedSize += joinString.length();\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    StringBuilder sb = new StringBuilder();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    StringBuilder sb = new StringBuilder();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n      foldedSize += sb.length();\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n",
        "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n// buggy code\n//     StringBuilder sb = new StringBuilder();\n//     int foldedSize = 0;\n//     Node elem = arrayNode.getFirstChild();\n//     while (elem != null) {\n//       if (NodeUtil.isImmutableValue(elem)) {\n//         if (sb.length() > 0) {\n//           sb.append(joinString);\n//         }\n//         sb.append(NodeUtil.getStringValue(elem));\n//       } else {\n//         if (sb.length() > 0) {\n//           foldedSize += sb.length() + 2;\n//           arrayFoldedChildren.add(Node.newString(sb.toString()));\n//           sb = new StringBuilder();\n//         }\n//         foldedSize += InlineCostEstimator.getCost(elem);\n//         arrayFoldedChildren.add(elem);\n//       }\n//       elem = elem.getNext();\n//     }\n//     if (sb.length() > 0) {\n   int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        foldedSize += NodeUtil.getStringValue(elem).length();\n      } else {\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (foldedSize > 0) {\n      foldedSize += joinString.length();\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n"
    ]
}