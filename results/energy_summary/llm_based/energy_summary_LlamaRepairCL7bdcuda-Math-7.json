{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Math-7",
    "Time": {
        "mean": 419.4238398075104,
        "median": 419.4238398075104,
        "std": 0,
        "max": 419.4238398075104,
        "min": 419.4238398075104,
        "count": 1
    },
    "Joules": {
        "mean": 57542.9391870141,
        "median": 57542.9391870141,
        "std": 0,
        "max": 57542.9391870141,
        "min": 57542.9391870141,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 24617.324390590195,
        "median": 24617.324390590195,
        "std": 0,
        "max": 24617.324390590195,
        "min": 24617.324390590195,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        77.67985498905182,
        146.02865195274353,
        214.37744891643524,
        282.72624588012695,
        351.07504284381866,
        419.4238398075104
    ],
    "Joules_Per_PatchMedian": [
        17282.366142833234,
        25334.48075166941,
        33386.595360505584,
        41438.709969341755,
        49490.824578177926,
        57542.9391870141
    ],
    "JoulesNormalized_Per_PatchMedian": [
        5935.851056098938,
        9672.14572299719,
        13408.44038989544,
        17144.735056793692,
        20881.029723691943,
        24617.324390590195
    ],
    "Inf_ExecutionTime": {
        "mean": 9.346330213546754,
        "median": 9.331058025360107,
        "std": 0.035774656176807904,
        "max": 9.410187005996704,
        "min": 9.32823920249939,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 9264.961070058347,
        "median": 9230.25153399706,
        "std": 78.85629951478924,
        "max": 9362.48866429329,
        "min": 9174.17727470398,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 2165.8342694139483,
        "median": 2199.5563892006876,
        "std": 97.71740500403469,
        "max": 2253.0923812627807,
        "min": 2012.8880389451979,
        "count": 5
    },
    "Val_ExecutionTime": [
        68.34879696369171,
        136.69759392738342,
        205.04639089107513,
        273.39518785476685,
        341.74398481845856,
        410.09278178215027
    ],
    "Val_Joules": [
        8052.114608836175,
        16104.22921767235,
        24156.343826508524,
        32208.458435344695,
        40260.57304418087,
        48312.68765301704
    ],
    "Val_JoulesNormalized": [
        3736.2946668982504,
        7472.589333796502,
        11208.884000694754,
        14945.178667593005,
        18681.473334491257,
        22417.768001389508
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "wrong",
        "wrong",
        "uncompilable",
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "wrong"
    ],
    "patches": [
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                    isLastStep = currentEvent.stop();\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n                    if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return eventT;\n                    }\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                    isLastStep = currentEvent.stop();\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n                    if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return eventT;\n                    }\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return event                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || currentEvent.stop();\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n                    if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return eventT;\n                    }\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                    isLastStep = currentEvent.stop();\n                    for (StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n                    if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return eventT;\n                    }\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n               currentEvent.stepAccepted(eventT, eventY.clone());\n                isLastStep = currentEvent.stop();\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY.clone());\n                    }\n                    return eventT;\n                }\n                boolean needReset = currentEvent.reset(eventT, eventY.clone());\n                if (needReset) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY.clone());\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                    isLastStep = currentEvent.stop();\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n                    if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return eventT;\n                    }\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        for (final EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n               isLastStep = currentEvent.stop();\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                    isLastStep = currentEvent.stop();\n                    for (StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n                    if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        for (EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                        return eventT;\n                    }\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        for (EventState remaining : occuringEvents) {\n                            remaining.stepAccepted(eventT, eventY);\n                        }\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n                   currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
        "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n// buggy code\n//                 currentEvent.stepAccepted(eventT, eventY);\n//                 isLastStep = currentEvent.stop();\n//                 for (final StepHandler handler : stepHandlers) {\n//                     handler.handleStep(interpolator, isLastStep);\n//                 }\n//                 if (isLastStep) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n//                     return eventT;\n//                 }\n//                 boolean needReset = currentEvent.reset(eventT, eventY);\n//                 if (needReset) {\n//                     System.arraycopy(eventY, 0, y, 0, y.length);\n//                     computeDerivatives(eventT, y, yDot);\n//                     resetOccurred = true;\n//                     for (final EventState remaining : occuringEvents) {\n//                         remaining.stepAccepted(eventT, eventY);\n//                     }\n               System.arraycopy(eventY, 0, y, 0, y.length);\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (isLastStep) {\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n"
    ]
}