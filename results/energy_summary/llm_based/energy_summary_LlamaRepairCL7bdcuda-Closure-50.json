{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-50",
    "Time": {
        "mean": 313.1400771141052,
        "median": 313.1400771141052,
        "std": 0,
        "max": 313.1400771141052,
        "min": 313.1400771141052,
        "count": 1
    },
    "Joules": {
        "mean": 42972.54294463397,
        "median": 42972.54294463397,
        "std": 0,
        "max": 42972.54294463397,
        "min": 42972.54294463397,
        "count": 1
    },
    "JoulesNormalized": {
        "mean": 18409.1497389555,
        "median": 18409.1497389555,
        "std": 0,
        "max": 18409.1497389555,
        "min": 18409.1497389555,
        "count": 1
    },
    "NrExecutions": 1,
    "ExecutionsIds": [
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "ExecutionTime_Per_PatchMedian": [
        58.09594702720642,
        109.10477304458618,
        160.11359906196594,
        211.1224250793457,
        262.13125109672546,
        313.1400771141052
    ],
    "Joules_Per_PatchMedian": [
        13055.164004141094,
        19038.639792239668,
        25022.115580338243,
        31005.591368436817,
        36989.06715653539,
        42972.54294463397
    ],
    "JoulesNormalized_Per_PatchMedian": [
        4435.468459653855,
        7230.204715514184,
        10024.940971374512,
        12819.67722723484,
        15614.41348309517,
        18409.1497389555
    ],
    "Inf_ExecutionTime": {
        "mean": 7.083348226547241,
        "median": 7.08712100982666,
        "std": 0.006731011461959911,
        "max": 7.088926076889038,
        "min": 7.073122024536133,
        "count": 5
    },
    "Inf_Joules": {
        "mean": 7014.606534402371,
        "median": 7071.688216042518,
        "std": 100.33400652418597,
        "max": 7098.688051962853,
        "min": 6893.53759483099,
        "count": 5
    },
    "Inf_JoulesNormalized": {
        "mean": 1619.576996099949,
        "median": 1640.7322037935255,
        "std": 118.56934939423607,
        "max": 1740.824568533898,
        "min": 1459.8757568955416,
        "count": 5
    },
    "Val_ExecutionTime": [
        51.00882601737976,
        102.01765203475952,
        153.02647805213928,
        204.03530406951904,
        255.0441300868988,
        306.05295610427856
    ],
    "Val_Joules": [
        5983.475788098575,
        11966.951576197149,
        17950.427364295723,
        23933.903152394298,
        29917.378940492872,
        35900.854728591454
    ],
    "Val_JoulesNormalized": [
        2794.736255860329,
        5589.472511720658,
        8384.208767580985,
        11178.945023441316,
        13973.681279301643,
        16768.417535161974
    ],
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "wrong",
        "wrong",
        "wrong",
        "wrong",
        "uncompilable",
        "uncompilable",
        "wrong",
        "wrong",
        "uncompilable",
        "wrong"
    ],
    "patches": [
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     return n;\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (right.getType() != Token.STRING) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (right.getType() != Token.STRING) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (!NodeUtil.isImmutableValue(right) || right.getType() == Token.EMPTY) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (!NodeUtil.isImmutableValue(right) || right.getType() != Token.STRING) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (!NodeUtil.isImmutableValue(right) || right.getType() != Token.STRING) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n",
        "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n// buggy code\n//       if (!NodeUtil.isImmutableValue(right)) {\n//         return n;\n//       }\n//     }\n//     Node arrayNode = callTarget.getFirstChild();\n//     Node functionName = arrayNode.getNext();\n//     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n//         !functionName.getString().equals(\"join\")) {\n//       return n;\n     if (!NodeUtil.isImmutableValue(right) && right.getType() != Token.ARRAYLIT) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n"
    ]
}