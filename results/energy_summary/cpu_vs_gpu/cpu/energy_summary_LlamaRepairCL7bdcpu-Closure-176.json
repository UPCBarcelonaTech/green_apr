{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcpu-Closure-176",
    "Time": {
        "mean": 271.0300168991089,
        "median": 271.0300168991089,
        "std": 0.0,
        "max": 271.0300168991089,
        "min": 271.0300168991089,
        "count": 4
    },
    "Joules": {
        "mean": 278298.20956606866,
        "median": 278298.20956606866,
        "std": 0.0,
        "max": 278298.20956606866,
        "min": 278298.20956606866,
        "count": 4
    },
    "JoulesNormalized": {
        "mean": 74451.42228349447,
        "median": 74451.42228349447,
        "std": 0.0,
        "max": 74451.42228349447,
        "min": 74451.42228349447,
        "count": 4
    },
    "NrExecutions": 4,
    "ExecutionsIds": [
        "s1",
        "s2",
        "s3",
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cpu",
        "s4_cpu",
        "s5_cpu"
    ],
    "NrExecutionsInference": 3,
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "wrong",
        "wrong",
        "uncompilable",
        "wrong",
        "wrong",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "wrong",
        "wrong"
    ],
    "patches": [
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n",
        "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n"
    ]
}