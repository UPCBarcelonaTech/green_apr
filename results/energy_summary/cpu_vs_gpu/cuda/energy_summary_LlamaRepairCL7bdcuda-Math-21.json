{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Math-21",
    "Time": {
        "mean": 13.815087080001831,
        "median": 13.815087080001831,
        "std": 0.0,
        "max": 13.815087080001831,
        "min": 13.815087080001831,
        "count": 4
    },
    "Joules": {
        "mean": 13718.047689473628,
        "median": 13718.047689473628,
        "std": 0.0,
        "max": 13718.047689473628,
        "min": 13718.047689473628,
        "count": 4
    },
    "JoulesNormalized": {
        "mean": 3194.8154369115837,
        "median": 3194.8154369115837,
        "std": 0.0,
        "max": 3194.8154369115837,
        "min": 3194.8154369115837,
        "count": 4
    },
    "NrExecutions": 4,
    "ExecutionsIds": [
        "s1",
        "s2",
        "s3",
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n"
    ]
}