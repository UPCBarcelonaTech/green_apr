{
    "TOOL_BUG_ID": "LlamaRepairCL7bdcuda-Closure-22",
    "Time": {
        "mean": 13.12109899520874,
        "median": 13.12109899520874,
        "std": 0.0,
        "max": 13.12109899520874,
        "min": 13.12109899520874,
        "count": 4
    },
    "Joules": {
        "mean": 13052.630812227726,
        "median": 13052.630812227726,
        "std": 0.0,
        "max": 13052.630812227726,
        "min": 13052.630812227726,
        "count": 4
    },
    "JoulesNormalized": {
        "mean": 2706.292773771287,
        "median": 2706.292773771287,
        "std": 0.0,
        "max": 2706.292773771287,
        "min": 2706.292773771287,
        "count": 4
    },
    "NrExecutions": 4,
    "ExecutionsIds": [
        "s1",
        "s2",
        "s3",
        "s4"
    ],
    "ExecutionsInferenceIds": [
        "s1_cuda",
        "s2_cuda",
        "s3_cuda",
        "s4_cuda",
        "s5_cuda"
    ],
    "NrExecutionsInference": 5,
    "NrPatches": {
        "median": 0,
        "std": 0.0,
        "max": 0,
        "min": 0
    },
    "Correctness_Per_Patch": [
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W",
        "W"
    ],
    "Correctness_Per_Patch_original": [
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable",
        "uncompilable"
    ],
    "patches": [
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n"
    ]
}